<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="5" skipped="3" tests="129" time="802.283" timestamp="2025-01-08T16:01:26.088527" hostname="starlight"><testcase classname="examples.eps.test_eps.epsTests" name="test_all_faults" time="0.479" /><testcase classname="examples.eps.test_eps.epsTests" name="test_backward_fault_prop_1" time="0.033" /><testcase classname="examples.eps.test_eps.epsTests" name="test_backward_fault_prop_2" time="0.037" /><testcase classname="examples.eps.test_eps.epsTests" name="test_fault_app" time="92.114" /><testcase classname="examples.eps.test_eps.epsTests" name="test_multfault_saving" time="0.135" /><testcase classname="examples.eps.test_eps.epsTests" name="test_nominal_saving" time="0.094" /><testcase classname="examples.eps.test_eps.epsTests" name="test_pickleability" time="0.010" /><testcase classname="examples.eps.test_eps.epsTests" name="test_save_load_onefault" time="0.107" /><testcase classname="examples.eps.test_eps.epsTests" name="test_save_load_singlefaults" time="1.555" /><testcase classname="examples.multiflow_demo.test_multiflow.define_Tests" name="test_multiflow_combination" time="0.156" /><testcase classname="examples.multiflow_demo.test_multiflow.define_Tests" name="test_multiflow_passing" time="0.158" /><testcase classname="examples.multiflow_demo.test_multiflow.define_Tests" name="test_mutliflow_copying" time="0.163" /><testcase classname="examples.multirotor.test_multirotor.DroneParameterTests" name="test_objectives" time="0.319" /><testcase classname="examples.multirotor.test_multirotor.DroneParameterTests" name="test_param_domain_1" time="0.001" /><testcase classname="examples.multirotor.test_multirotor.DroneParameterTests" name="test_param_domain_2" time="0.001" /><testcase classname="examples.multirotor.test_multirotor.DroneParameterTests" name="test_set_constraints_1" time="0.001" /><testcase classname="examples.multirotor.test_multirotor.DroneParameterTests" name="test_set_constraints_2" time="0.001" /><testcase classname="examples.multirotor.test_multirotor.DroneParameterTests" name="test_sim_mdl" time="0.163" /><testcase classname="examples.multirotor.test_multirotor.DroneScenarioTest" name="test_scenprob_results" time="0.462"><failure message="Exception: Error in scenario SingleFaultScenario(sequence={4.0: Injection(faults={'affect_dof': ['rf_propwarp']}, disturbances={})}, times=(4,), function='affect_dof', fault='rf_propwarp', rate=1.0000000000000001e-07, name='affect_dof_rf_propwarp_t4', time=2.0, phase='')">self = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults=set())
store_ee StoreEE
- St..., y=0.0, z=100.0)
des_traj DesTraj flow: DesTrajState(dx=100.0, dy=0.0, dz=0.0, power=1.0)
environment DroneEnvironment
time = 4.0, fxnfaults = {'affect_dof': ['rf_propwarp']}, disturbances = {}
proptype = 'both', run_stochastic = False

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mpropagate#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m, time, fxnfaults={}, disturbances={}, proptype=#x1B[33m"#x1B[39;49;00m#x1B[33mboth#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                  run_stochastic=#x1B[94mFalse#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Inject and propagates faults through the graph at one time-step.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    time : float#x1B[39;49;00m
    #x1B[33m        The current time-step.#x1B[39;49;00m
    #x1B[33m    fxnfaults : dict#x1B[39;49;00m
    #x1B[33m        Faults to inject during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function':['fault1', 'fault2'...]}#x1B[39;49;00m
    #x1B[33m    disturbances : dict#x1B[39;49;00m
    #x1B[33m        Variables to change during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function.var1':value}#x1B[39;49;00m
    #x1B[33m    proptype : str#x1B[39;49;00m
    #x1B[33m        Whether the propagate 'static' or 'dynamic' behaviors, or 'both'. Default#x1B[39;49;00m
    #x1B[33m        is 'both'.#x1B[39;49;00m
    #x1B[33m    run_stochastic : bool#x1B[39;49;00m
    #x1B[33m        Whether to run stochastic behaviors or use default values. Default is False.#x1B[39;49;00m
    #x1B[33m        Can set as 'track_pdf' to calculate/track the probability densities of#x1B[39;49;00m
    #x1B[33m        random states over time.#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 0: Update model states with disturbances and faults#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[96mself#x1B[39;49;00m.set_vars(**disturbances)#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m fxnfaults:#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.inject_faults(fxnfaults)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 1: Run Dynamic Propagation Methods in Order Specified#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m fxnname #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.dynamicfxns:#x1B[90m#x1B[39;49;00m
            fxn = #x1B[96mself#x1B[39;49;00m.fxns[fxnname]#x1B[90m#x1B[39;49;00m
            fxn(#x1B[33m'#x1B[39;49;00m#x1B[33mdynamic#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, time=time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 2: Run Static Propagation Methods#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
&gt;           #x1B[96mself#x1B[39;49;00m.prop_static(time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m

#x1B[1m#x1B[31mfmdtools\define\architecture\function.py#x1B[0m:794: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
#x1B[1m#x1B[31mfmdtools\define\architecture\function.py#x1B[0m:824: in prop_static
    #x1B[0m#x1B[96mself#x1B[39;49;00m.fxns[fxnname](#x1B[33m'#x1B[39;49;00m#x1B[33mstatic#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, time=time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\define\block\function.py#x1B[0m:187: in __call__
    #x1B[0m#x1B[96mself#x1B[39;49;00m.static_behavior(time)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mexamples\multirotor\drone_mdl_hierarchical.py#x1B[0m:165: in static_behavior
    #x1B[0m#x1B[96mself#x1B[39;49;00m.reconfig_faults()#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mexamples\multirotor\drone_mdl_rural.py#x1B[0m:496: in reconfig_faults
    #x1B[0mAffectDOFHierarchical.reconfig_faults(#x1B[96mself#x1B[39;49;00m)#x1B[90m#x1B[39;49;00m
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = affect_dof AffectDOF
- OverallAffectDOFState(lrstab=0.0, frstab=-0.5, amp_factor=1.0)
- AffectMode(mode=nominal, faults={'rf_propwarp'})

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mreconfig_faults#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""Corrects for individual line faultmodes by turning off the opposite rotor#x1B[39;49;00m
    #x1B[33m    and upping the throttle (amp_factor)"""#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m fault #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.m.faults:#x1B[90m#x1B[39;49;00m
&gt;           #x1B[94mif#x1B[39;49;00m fault #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.ca.faultmodes:#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mE           AttributeError: 'AffectDOFArch' object has no attribute 'faultmodes'#x1B[0m

#x1B[1m#x1B[31mexamples\multirotor\drone_mdl_hierarchical.py#x1B[0m:172: AttributeError

#x1B[33mThe above exception was the direct cause of the following exception:#x1B[0m

mdl = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults=set())
store_ee StoreEE
- St..., y=0.0, z=100.0)
des_traj DesTraj flow: DesTrajState(dx=100.0, dy=0.0, dz=0.0, power=1.0)
environment DroneEnvironment
scen = SingleFaultScenario(sequence={4.0: Injection(faults={'affect_dof': ['rf_propwarp']}, disturbances={})}, times=(4,), fu...n='affect_dof', fault='rf_propwarp', rate=1.0000000000000001e-07, name='affect_dof_rf_propwarp_t4', time=2.0, phase='')
ctimes = []
nomhist = flows.force_st.s.support:      array(16)
flows.force_lin.s.support:     array(16)
flows.hsig_dofs.s.hstate:      array...payload.m.faults.break: array(16)
fxns.hold_payload.m.faults.deform: array(16)
time:                          array(16)
nomresult = t15p0: 
--plan_path.t.time:                 15.0
--dofs.s.x:                          0.0
kwargs = {'cut_hist': True, 'desired_result': {15: ['plan_path.t.time', 'dofs.s.x']}, 'run_stochastic': False, 'staged': True, ...}
desired_result = {15: ['plan_path.t.time', 'dofs.s.x']}, staged = True
cut_hist = True, run_stochastic = False, use_end_condition = True
warn_faults = True, start_time = 2.0

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mprop_one_scen#x1B[39;49;00m(mdl, scen, ctimes=[], nomhist={}, nomresult={}, **kwargs):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Simulate a single scenario in the model over time.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    mdl : Simulable#x1B[39;49;00m
    #x1B[33m        The model to inject faults in.#x1B[39;49;00m
    #x1B[33m    scen : Scenario#x1B[39;49;00m
    #x1B[33m        The Scenario to run.#x1B[39;49;00m
    #x1B[33m    ctimes : list, optional#x1B[39;49;00m
    #x1B[33m        List of times to copy the model (for use in staged execution).#x1B[39;49;00m
    #x1B[33m        The default is [].#x1B[39;49;00m
    #x1B[33m    nomhist : dict, optional#x1B[39;49;00m
    #x1B[33m        Model history dictionary from previous runs, for use in creating the new#x1B[39;49;00m
    #x1B[33m        mdlhist. The default is {}.#x1B[39;49;00m
    #x1B[33m    nomresult : dict, optional#x1B[39;49;00m
    #x1B[33m        Nominal result dictionary (to compare with current if desired)#x1B[39;49;00m
    #x1B[33m    **kwargs : kwargs#x1B[39;49;00m
    #x1B[33m        simulation options, see :data:`sim_kwargs`#x1B[39;49;00m
    #x1B[33m    Returns#x1B[39;49;00m
    #x1B[33m    -------#x1B[39;49;00m
    #x1B[33m    result: Result#x1B[39;49;00m
    #x1B[33m        dict of result corresponding to desired_result.#x1B[39;49;00m
    #x1B[33m    mdlhist : dict#x1B[39;49;00m
    #x1B[33m        A dictionary with a history of modelstates.#x1B[39;49;00m
    #x1B[33m    c_mdl : dict#x1B[39;49;00m
    #x1B[33m        A dictionary of models at each time given in ctimes with structure {time:model}#x1B[39;49;00m
    #x1B[33m    t_end: float#x1B[39;49;00m
    #x1B[33m        Last sim time#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        desired_result, staged, cut_hist, run_stochastic, use_end_condition, warn_faults = unpack_sim_kwargs(**kwargs)#x1B[90m#x1B[39;49;00m
        #x1B[90m# if staged, we want it to start a new run from the starting time of the scenario,#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# using a copy of the input model (which is the nominal run) at this time#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m staged:#x1B[90m#x1B[39;49;00m
            start_time = scen.time#x1B[90m#x1B[39;49;00m
        #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
            start_time = #x1B[94m0#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        timerange = mdl.sp.get_timerange(start_time)#x1B[90m#x1B[39;49;00m
        #x1B[90m# check if sequence is out of timerange#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
            #x1B[94mif#x1B[39;49;00m t #x1B[95mnot#x1B[39;49;00m #x1B[95min#x1B[39;49;00m timerange:#x1B[90m#x1B[39;49;00m
                #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mt=#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m+#x1B[96mstr#x1B[39;49;00m(t)+#x1B[33m"#x1B[39;49;00m#x1B[33m from sequence not in timerange: #x1B[39;49;00m#x1B[33m"#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
                                + #x1B[96mstr#x1B[39;49;00m(timerange))#x1B[90m#x1B[39;49;00m
        shift = mdl.sp.get_shift(start_time)#x1B[90m#x1B[39;49;00m
        mdl.init_time_hist()#x1B[90m#x1B[39;49;00m
        #x1B[90m# run model through the time range defined in the object#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        c_mdl = #x1B[96mdict#x1B[39;49;00m.fromkeys(ctimes)#x1B[90m#x1B[39;49;00m
        result = Result()#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t_ind, t #x1B[95min#x1B[39;49;00m #x1B[96menumerate#x1B[39;49;00m(timerange):#x1B[90m#x1B[39;49;00m
            #x1B[90m# inject fault when it occurs, track defined flow states and graph#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
            #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m ctimes:#x1B[90m#x1B[39;49;00m
                    c_mdl[t] = mdl.copy()#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
                    fxnfaults = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mfaults#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                    disturbances = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mdisturbances#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                    fxnfaults = {}#x1B[90m#x1B[39;49;00m
                    disturbances = {}#x1B[90m#x1B[39;49;00m
                #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
&gt;                   mdl.propagate(t, fxnfaults, disturbances, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m

#x1B[1m#x1B[31mfmdtools\sim\propagate.py#x1B[0m:1111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults=set())
store_ee StoreEE
- St..., y=0.0, z=100.0)
des_traj DesTraj flow: DesTrajState(dx=100.0, dy=0.0, dz=0.0, power=1.0)
environment DroneEnvironment
time = 4.0, fxnfaults = {'affect_dof': ['rf_propwarp']}, disturbances = {}
proptype = 'both', run_stochastic = False

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mpropagate#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m, time, fxnfaults={}, disturbances={}, proptype=#x1B[33m"#x1B[39;49;00m#x1B[33mboth#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                  run_stochastic=#x1B[94mFalse#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Inject and propagates faults through the graph at one time-step.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    time : float#x1B[39;49;00m
    #x1B[33m        The current time-step.#x1B[39;49;00m
    #x1B[33m    fxnfaults : dict#x1B[39;49;00m
    #x1B[33m        Faults to inject during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function':['fault1', 'fault2'...]}#x1B[39;49;00m
    #x1B[33m    disturbances : dict#x1B[39;49;00m
    #x1B[33m        Variables to change during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function.var1':value}#x1B[39;49;00m
    #x1B[33m    proptype : str#x1B[39;49;00m
    #x1B[33m        Whether the propagate 'static' or 'dynamic' behaviors, or 'both'. Default#x1B[39;49;00m
    #x1B[33m        is 'both'.#x1B[39;49;00m
    #x1B[33m    run_stochastic : bool#x1B[39;49;00m
    #x1B[33m        Whether to run stochastic behaviors or use default values. Default is False.#x1B[39;49;00m
    #x1B[33m        Can set as 'track_pdf' to calculate/track the probability densities of#x1B[39;49;00m
    #x1B[33m        random states over time.#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 0: Update model states with disturbances and faults#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[96mself#x1B[39;49;00m.set_vars(**disturbances)#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m fxnfaults:#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.inject_faults(fxnfaults)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 1: Run Dynamic Propagation Methods in Order Specified#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m fxnname #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.dynamicfxns:#x1B[90m#x1B[39;49;00m
            fxn = #x1B[96mself#x1B[39;49;00m.fxns[fxnname]#x1B[90m#x1B[39;49;00m
            fxn(#x1B[33m'#x1B[39;49;00m#x1B[33mdynamic#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, time=time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 2: Run Static Propagation Methods#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.prop_static(time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
        #x1B[94mexcept#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m #x1B[94mas#x1B[39;49;00m e:#x1B[90m#x1B[39;49;00m
&gt;           #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mError in static propagation at time t=#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m + #x1B[96mstr#x1B[39;49;00m(time)) #x1B[94mfrom#x1B[39;49;00m #x1B[04m#x1B[96me#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mE           Exception: Error in static propagation at time t=4.0#x1B[0m

#x1B[1m#x1B[31mfmdtools\define\architecture\function.py#x1B[0m:796: Exception

#x1B[33mThe above exception was the direct cause of the following exception:#x1B[0m

self = &lt;examples.multirotor.test_multirotor.DroneScenarioTest testMethod=test_scenprob_results&gt;

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mtest_scenprob_results#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""Test that the objective lines up with expected results at the given time."""#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# fault should cause the final x (f5) to match the nominal x at the fault time#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        x_nominal = #x1B[96mself#x1B[39;49;00m.hist.flows.dofs.s.x[#x1B[96mself#x1B[39;49;00m.time]#x1B[90m#x1B[39;49;00m
&gt;       x_failure = sp.f2(#x1B[96mself#x1B[39;49;00m.time)#x1B[90m#x1B[39;49;00m

#x1B[1m#x1B[31mexamples\multirotor\test_multirotor.py#x1B[0m:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:216: in newobj
    #x1B[0m#x1B[94mreturn#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.call_objective(*x, objective=name)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:279: in call_objective
    #x1B[0m#x1B[96mself#x1B[39;49;00m.update_objectives(*x)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:713: in update_objectives
    #x1B[0m#x1B[96mself#x1B[39;49;00m.res, #x1B[96mself#x1B[39;49;00m.hist = #x1B[96mself#x1B[39;49;00m.sim_mdl(*#x1B[96mself#x1B[39;49;00m.current_x())#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:894: in sim_mdl
    #x1B[0mres, hist, _, t_end = #x1B[96mself#x1B[39;49;00m.prop_method(mdl,#x1B[90m#x1B[39;49;00m
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

mdl = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults=set())
store_ee StoreEE
- St..., y=0.0, z=100.0)
des_traj DesTraj flow: DesTrajState(dx=100.0, dy=0.0, dz=0.0, power=1.0)
environment DroneEnvironment
scen = SingleFaultScenario(sequence={4.0: Injection(faults={'affect_dof': ['rf_propwarp']}, disturbances={})}, times=(4,), fu...n='affect_dof', fault='rf_propwarp', rate=1.0000000000000001e-07, name='affect_dof_rf_propwarp_t4', time=2.0, phase='')
ctimes = []
nomhist = flows.force_st.s.support:      array(16)
flows.force_lin.s.support:     array(16)
flows.hsig_dofs.s.hstate:      array...payload.m.faults.break: array(16)
fxns.hold_payload.m.faults.deform: array(16)
time:                          array(16)
nomresult = t15p0: 
--plan_path.t.time:                 15.0
--dofs.s.x:                          0.0
kwargs = {'cut_hist': True, 'desired_result': {15: ['plan_path.t.time', 'dofs.s.x']}, 'run_stochastic': False, 'staged': True, ...}
desired_result = {15: ['plan_path.t.time', 'dofs.s.x']}, staged = True
cut_hist = True, run_stochastic = False, use_end_condition = True
warn_faults = True, start_time = 2.0

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mprop_one_scen#x1B[39;49;00m(mdl, scen, ctimes=[], nomhist={}, nomresult={}, **kwargs):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Simulate a single scenario in the model over time.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    mdl : Simulable#x1B[39;49;00m
    #x1B[33m        The model to inject faults in.#x1B[39;49;00m
    #x1B[33m    scen : Scenario#x1B[39;49;00m
    #x1B[33m        The Scenario to run.#x1B[39;49;00m
    #x1B[33m    ctimes : list, optional#x1B[39;49;00m
    #x1B[33m        List of times to copy the model (for use in staged execution).#x1B[39;49;00m
    #x1B[33m        The default is [].#x1B[39;49;00m
    #x1B[33m    nomhist : dict, optional#x1B[39;49;00m
    #x1B[33m        Model history dictionary from previous runs, for use in creating the new#x1B[39;49;00m
    #x1B[33m        mdlhist. The default is {}.#x1B[39;49;00m
    #x1B[33m    nomresult : dict, optional#x1B[39;49;00m
    #x1B[33m        Nominal result dictionary (to compare with current if desired)#x1B[39;49;00m
    #x1B[33m    **kwargs : kwargs#x1B[39;49;00m
    #x1B[33m        simulation options, see :data:`sim_kwargs`#x1B[39;49;00m
    #x1B[33m    Returns#x1B[39;49;00m
    #x1B[33m    -------#x1B[39;49;00m
    #x1B[33m    result: Result#x1B[39;49;00m
    #x1B[33m        dict of result corresponding to desired_result.#x1B[39;49;00m
    #x1B[33m    mdlhist : dict#x1B[39;49;00m
    #x1B[33m        A dictionary with a history of modelstates.#x1B[39;49;00m
    #x1B[33m    c_mdl : dict#x1B[39;49;00m
    #x1B[33m        A dictionary of models at each time given in ctimes with structure {time:model}#x1B[39;49;00m
    #x1B[33m    t_end: float#x1B[39;49;00m
    #x1B[33m        Last sim time#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        desired_result, staged, cut_hist, run_stochastic, use_end_condition, warn_faults = unpack_sim_kwargs(**kwargs)#x1B[90m#x1B[39;49;00m
        #x1B[90m# if staged, we want it to start a new run from the starting time of the scenario,#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# using a copy of the input model (which is the nominal run) at this time#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m staged:#x1B[90m#x1B[39;49;00m
            start_time = scen.time#x1B[90m#x1B[39;49;00m
        #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
            start_time = #x1B[94m0#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        timerange = mdl.sp.get_timerange(start_time)#x1B[90m#x1B[39;49;00m
        #x1B[90m# check if sequence is out of timerange#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
            #x1B[94mif#x1B[39;49;00m t #x1B[95mnot#x1B[39;49;00m #x1B[95min#x1B[39;49;00m timerange:#x1B[90m#x1B[39;49;00m
                #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mt=#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m+#x1B[96mstr#x1B[39;49;00m(t)+#x1B[33m"#x1B[39;49;00m#x1B[33m from sequence not in timerange: #x1B[39;49;00m#x1B[33m"#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
                                + #x1B[96mstr#x1B[39;49;00m(timerange))#x1B[90m#x1B[39;49;00m
        shift = mdl.sp.get_shift(start_time)#x1B[90m#x1B[39;49;00m
        mdl.init_time_hist()#x1B[90m#x1B[39;49;00m
        #x1B[90m# run model through the time range defined in the object#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        c_mdl = #x1B[96mdict#x1B[39;49;00m.fromkeys(ctimes)#x1B[90m#x1B[39;49;00m
        result = Result()#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t_ind, t #x1B[95min#x1B[39;49;00m #x1B[96menumerate#x1B[39;49;00m(timerange):#x1B[90m#x1B[39;49;00m
            #x1B[90m# inject fault when it occurs, track defined flow states and graph#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
            #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m ctimes:#x1B[90m#x1B[39;49;00m
                    c_mdl[t] = mdl.copy()#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
                    fxnfaults = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mfaults#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                    disturbances = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mdisturbances#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                    fxnfaults = {}#x1B[90m#x1B[39;49;00m
                    disturbances = {}#x1B[90m#x1B[39;49;00m
                #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                    mdl.propagate(t, fxnfaults, disturbances, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
                #x1B[94mexcept#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m #x1B[94mas#x1B[39;49;00m e:#x1B[90m#x1B[39;49;00m
&gt;                   #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mError in scenario #x1B[39;49;00m#x1B[33m"#x1B[39;49;00m + #x1B[96mstr#x1B[39;49;00m(scen)) #x1B[94mfrom#x1B[39;49;00m #x1B[04m#x1B[96me#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mE                   Exception: Error in scenario SingleFaultScenario(sequence={4.0: Injection(faults={'affect_dof': ['rf_propwarp']}, disturbances={})}, times=(4,), function='affect_dof', fault='rf_propwarp', rate=1.0000000000000001e-07, name='affect_dof_rf_propwarp_t4', time=2.0, phase='')#x1B[0m

#x1B[1m#x1B[31mfmdtools\sim\propagate.py#x1B[0m:1113: Exception</failure></testcase><testcase classname="examples.multirotor.test_multirotor.DroneScenarioTest2" name="test_scenprob_results" time="0.274"><failure message="Exception: Error in scenario SingleFaultScenario(sequence={5.0: Injection(faults={'affect_dof': ['rf_propwarp']}, disturbances={})}, times=(5,), function='affect_dof', fault='rf_propwarp', rate=1.0000000000000001e-07, name='affect_dof_rf_propwarp_t5', time=2.0, phase='')">self = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults=set())
store_ee StoreEE
- St...y=100.0, z=100.0)
des_traj DesTraj flow: DesTrajState(dx=0.0, dy=100.0, dz=0.0, power=1.0)
environment DroneEnvironment
time = 5.0, fxnfaults = {'affect_dof': ['rf_propwarp']}, disturbances = {}
proptype = 'both', run_stochastic = False

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mpropagate#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m, time, fxnfaults={}, disturbances={}, proptype=#x1B[33m"#x1B[39;49;00m#x1B[33mboth#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                  run_stochastic=#x1B[94mFalse#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Inject and propagates faults through the graph at one time-step.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    time : float#x1B[39;49;00m
    #x1B[33m        The current time-step.#x1B[39;49;00m
    #x1B[33m    fxnfaults : dict#x1B[39;49;00m
    #x1B[33m        Faults to inject during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function':['fault1', 'fault2'...]}#x1B[39;49;00m
    #x1B[33m    disturbances : dict#x1B[39;49;00m
    #x1B[33m        Variables to change during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function.var1':value}#x1B[39;49;00m
    #x1B[33m    proptype : str#x1B[39;49;00m
    #x1B[33m        Whether the propagate 'static' or 'dynamic' behaviors, or 'both'. Default#x1B[39;49;00m
    #x1B[33m        is 'both'.#x1B[39;49;00m
    #x1B[33m    run_stochastic : bool#x1B[39;49;00m
    #x1B[33m        Whether to run stochastic behaviors or use default values. Default is False.#x1B[39;49;00m
    #x1B[33m        Can set as 'track_pdf' to calculate/track the probability densities of#x1B[39;49;00m
    #x1B[33m        random states over time.#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 0: Update model states with disturbances and faults#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[96mself#x1B[39;49;00m.set_vars(**disturbances)#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m fxnfaults:#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.inject_faults(fxnfaults)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 1: Run Dynamic Propagation Methods in Order Specified#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m fxnname #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.dynamicfxns:#x1B[90m#x1B[39;49;00m
            fxn = #x1B[96mself#x1B[39;49;00m.fxns[fxnname]#x1B[90m#x1B[39;49;00m
            fxn(#x1B[33m'#x1B[39;49;00m#x1B[33mdynamic#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, time=time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 2: Run Static Propagation Methods#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
&gt;           #x1B[96mself#x1B[39;49;00m.prop_static(time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m

#x1B[1m#x1B[31mfmdtools\define\architecture\function.py#x1B[0m:794: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
#x1B[1m#x1B[31mfmdtools\define\architecture\function.py#x1B[0m:824: in prop_static
    #x1B[0m#x1B[96mself#x1B[39;49;00m.fxns[fxnname](#x1B[33m'#x1B[39;49;00m#x1B[33mstatic#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, time=time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\define\block\function.py#x1B[0m:187: in __call__
    #x1B[0m#x1B[96mself#x1B[39;49;00m.static_behavior(time)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mexamples\multirotor\drone_mdl_hierarchical.py#x1B[0m:165: in static_behavior
    #x1B[0m#x1B[96mself#x1B[39;49;00m.reconfig_faults()#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mexamples\multirotor\drone_mdl_rural.py#x1B[0m:496: in reconfig_faults
    #x1B[0mAffectDOFHierarchical.reconfig_faults(#x1B[96mself#x1B[39;49;00m)#x1B[90m#x1B[39;49;00m
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = affect_dof AffectDOF
- OverallAffectDOFState(lrstab=0.0, frstab=-0.5, amp_factor=1.0)
- AffectMode(mode=nominal, faults={'rf_propwarp'})

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mreconfig_faults#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""Corrects for individual line faultmodes by turning off the opposite rotor#x1B[39;49;00m
    #x1B[33m    and upping the throttle (amp_factor)"""#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m fault #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.m.faults:#x1B[90m#x1B[39;49;00m
&gt;           #x1B[94mif#x1B[39;49;00m fault #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.ca.faultmodes:#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mE           AttributeError: 'AffectDOFArch' object has no attribute 'faultmodes'#x1B[0m

#x1B[1m#x1B[31mexamples\multirotor\drone_mdl_hierarchical.py#x1B[0m:172: AttributeError

#x1B[33mThe above exception was the direct cause of the following exception:#x1B[0m

mdl = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults=set())
store_ee StoreEE
- St...y=100.0, z=100.0)
des_traj DesTraj flow: DesTrajState(dx=0.0, dy=100.0, dz=0.0, power=1.0)
environment DroneEnvironment
scen = SingleFaultScenario(sequence={5.0: Injection(faults={'affect_dof': ['rf_propwarp']}, disturbances={})}, times=(5,), fu...n='affect_dof', fault='rf_propwarp', rate=1.0000000000000001e-07, name='affect_dof_rf_propwarp_t5', time=2.0, phase='')
ctimes = []
nomhist = flows.force_st.s.support:      array(16)
flows.force_lin.s.support:     array(16)
flows.hsig_dofs.s.hstate:      array...payload.m.faults.break: array(16)
fxns.hold_payload.m.faults.deform: array(16)
time:                          array(16)
nomresult = t15p0: 
--plan_path.t.time:                 15.0
--dofs.s.x:                          0.0
kwargs = {'cut_hist': True, 'desired_result': {15: ['plan_path.t.time', 'dofs.s.x']}, 'run_stochastic': False, 'staged': True, ...}
desired_result = {15: ['plan_path.t.time', 'dofs.s.x']}, staged = True
cut_hist = True, run_stochastic = False, use_end_condition = True
warn_faults = True, start_time = 2.0

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mprop_one_scen#x1B[39;49;00m(mdl, scen, ctimes=[], nomhist={}, nomresult={}, **kwargs):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Simulate a single scenario in the model over time.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    mdl : Simulable#x1B[39;49;00m
    #x1B[33m        The model to inject faults in.#x1B[39;49;00m
    #x1B[33m    scen : Scenario#x1B[39;49;00m
    #x1B[33m        The Scenario to run.#x1B[39;49;00m
    #x1B[33m    ctimes : list, optional#x1B[39;49;00m
    #x1B[33m        List of times to copy the model (for use in staged execution).#x1B[39;49;00m
    #x1B[33m        The default is [].#x1B[39;49;00m
    #x1B[33m    nomhist : dict, optional#x1B[39;49;00m
    #x1B[33m        Model history dictionary from previous runs, for use in creating the new#x1B[39;49;00m
    #x1B[33m        mdlhist. The default is {}.#x1B[39;49;00m
    #x1B[33m    nomresult : dict, optional#x1B[39;49;00m
    #x1B[33m        Nominal result dictionary (to compare with current if desired)#x1B[39;49;00m
    #x1B[33m    **kwargs : kwargs#x1B[39;49;00m
    #x1B[33m        simulation options, see :data:`sim_kwargs`#x1B[39;49;00m
    #x1B[33m    Returns#x1B[39;49;00m
    #x1B[33m    -------#x1B[39;49;00m
    #x1B[33m    result: Result#x1B[39;49;00m
    #x1B[33m        dict of result corresponding to desired_result.#x1B[39;49;00m
    #x1B[33m    mdlhist : dict#x1B[39;49;00m
    #x1B[33m        A dictionary with a history of modelstates.#x1B[39;49;00m
    #x1B[33m    c_mdl : dict#x1B[39;49;00m
    #x1B[33m        A dictionary of models at each time given in ctimes with structure {time:model}#x1B[39;49;00m
    #x1B[33m    t_end: float#x1B[39;49;00m
    #x1B[33m        Last sim time#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        desired_result, staged, cut_hist, run_stochastic, use_end_condition, warn_faults = unpack_sim_kwargs(**kwargs)#x1B[90m#x1B[39;49;00m
        #x1B[90m# if staged, we want it to start a new run from the starting time of the scenario,#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# using a copy of the input model (which is the nominal run) at this time#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m staged:#x1B[90m#x1B[39;49;00m
            start_time = scen.time#x1B[90m#x1B[39;49;00m
        #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
            start_time = #x1B[94m0#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        timerange = mdl.sp.get_timerange(start_time)#x1B[90m#x1B[39;49;00m
        #x1B[90m# check if sequence is out of timerange#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
            #x1B[94mif#x1B[39;49;00m t #x1B[95mnot#x1B[39;49;00m #x1B[95min#x1B[39;49;00m timerange:#x1B[90m#x1B[39;49;00m
                #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mt=#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m+#x1B[96mstr#x1B[39;49;00m(t)+#x1B[33m"#x1B[39;49;00m#x1B[33m from sequence not in timerange: #x1B[39;49;00m#x1B[33m"#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
                                + #x1B[96mstr#x1B[39;49;00m(timerange))#x1B[90m#x1B[39;49;00m
        shift = mdl.sp.get_shift(start_time)#x1B[90m#x1B[39;49;00m
        mdl.init_time_hist()#x1B[90m#x1B[39;49;00m
        #x1B[90m# run model through the time range defined in the object#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        c_mdl = #x1B[96mdict#x1B[39;49;00m.fromkeys(ctimes)#x1B[90m#x1B[39;49;00m
        result = Result()#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t_ind, t #x1B[95min#x1B[39;49;00m #x1B[96menumerate#x1B[39;49;00m(timerange):#x1B[90m#x1B[39;49;00m
            #x1B[90m# inject fault when it occurs, track defined flow states and graph#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
            #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m ctimes:#x1B[90m#x1B[39;49;00m
                    c_mdl[t] = mdl.copy()#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
                    fxnfaults = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mfaults#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                    disturbances = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mdisturbances#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                    fxnfaults = {}#x1B[90m#x1B[39;49;00m
                    disturbances = {}#x1B[90m#x1B[39;49;00m
                #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
&gt;                   mdl.propagate(t, fxnfaults, disturbances, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m

#x1B[1m#x1B[31mfmdtools\sim\propagate.py#x1B[0m:1111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults=set())
store_ee StoreEE
- St...y=100.0, z=100.0)
des_traj DesTraj flow: DesTrajState(dx=0.0, dy=100.0, dz=0.0, power=1.0)
environment DroneEnvironment
time = 5.0, fxnfaults = {'affect_dof': ['rf_propwarp']}, disturbances = {}
proptype = 'both', run_stochastic = False

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mpropagate#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m, time, fxnfaults={}, disturbances={}, proptype=#x1B[33m"#x1B[39;49;00m#x1B[33mboth#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                  run_stochastic=#x1B[94mFalse#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Inject and propagates faults through the graph at one time-step.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    time : float#x1B[39;49;00m
    #x1B[33m        The current time-step.#x1B[39;49;00m
    #x1B[33m    fxnfaults : dict#x1B[39;49;00m
    #x1B[33m        Faults to inject during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function':['fault1', 'fault2'...]}#x1B[39;49;00m
    #x1B[33m    disturbances : dict#x1B[39;49;00m
    #x1B[33m        Variables to change during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function.var1':value}#x1B[39;49;00m
    #x1B[33m    proptype : str#x1B[39;49;00m
    #x1B[33m        Whether the propagate 'static' or 'dynamic' behaviors, or 'both'. Default#x1B[39;49;00m
    #x1B[33m        is 'both'.#x1B[39;49;00m
    #x1B[33m    run_stochastic : bool#x1B[39;49;00m
    #x1B[33m        Whether to run stochastic behaviors or use default values. Default is False.#x1B[39;49;00m
    #x1B[33m        Can set as 'track_pdf' to calculate/track the probability densities of#x1B[39;49;00m
    #x1B[33m        random states over time.#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 0: Update model states with disturbances and faults#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[96mself#x1B[39;49;00m.set_vars(**disturbances)#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m fxnfaults:#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.inject_faults(fxnfaults)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 1: Run Dynamic Propagation Methods in Order Specified#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m fxnname #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.dynamicfxns:#x1B[90m#x1B[39;49;00m
            fxn = #x1B[96mself#x1B[39;49;00m.fxns[fxnname]#x1B[90m#x1B[39;49;00m
            fxn(#x1B[33m'#x1B[39;49;00m#x1B[33mdynamic#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, time=time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 2: Run Static Propagation Methods#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.prop_static(time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
        #x1B[94mexcept#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m #x1B[94mas#x1B[39;49;00m e:#x1B[90m#x1B[39;49;00m
&gt;           #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mError in static propagation at time t=#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m + #x1B[96mstr#x1B[39;49;00m(time)) #x1B[94mfrom#x1B[39;49;00m #x1B[04m#x1B[96me#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mE           Exception: Error in static propagation at time t=5.0#x1B[0m

#x1B[1m#x1B[31mfmdtools\define\architecture\function.py#x1B[0m:796: Exception

#x1B[33mThe above exception was the direct cause of the following exception:#x1B[0m

self = &lt;examples.multirotor.test_multirotor.DroneScenarioTest2 testMethod=test_scenprob_results&gt;

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mtest_scenprob_results#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""Test that the objective lines up with expected results at the given time."""#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# fault should cause the final x (f5) to match the nominal x at the fault time#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        x_nominal = #x1B[96mself#x1B[39;49;00m.hist.flows.dofs.s.x[#x1B[96mself#x1B[39;49;00m.time]#x1B[90m#x1B[39;49;00m
&gt;       x_failure = sp.f2(#x1B[96mself#x1B[39;49;00m.time)#x1B[90m#x1B[39;49;00m

#x1B[1m#x1B[31mexamples\multirotor\test_multirotor.py#x1B[0m:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:216: in newobj
    #x1B[0m#x1B[94mreturn#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.call_objective(*x, objective=name)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:279: in call_objective
    #x1B[0m#x1B[96mself#x1B[39;49;00m.update_objectives(*x)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:713: in update_objectives
    #x1B[0m#x1B[96mself#x1B[39;49;00m.res, #x1B[96mself#x1B[39;49;00m.hist = #x1B[96mself#x1B[39;49;00m.sim_mdl(*#x1B[96mself#x1B[39;49;00m.current_x())#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:894: in sim_mdl
    #x1B[0mres, hist, _, t_end = #x1B[96mself#x1B[39;49;00m.prop_method(mdl,#x1B[90m#x1B[39;49;00m
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

mdl = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults=set())
store_ee StoreEE
- St...y=100.0, z=100.0)
des_traj DesTraj flow: DesTrajState(dx=0.0, dy=100.0, dz=0.0, power=1.0)
environment DroneEnvironment
scen = SingleFaultScenario(sequence={5.0: Injection(faults={'affect_dof': ['rf_propwarp']}, disturbances={})}, times=(5,), fu...n='affect_dof', fault='rf_propwarp', rate=1.0000000000000001e-07, name='affect_dof_rf_propwarp_t5', time=2.0, phase='')
ctimes = []
nomhist = flows.force_st.s.support:      array(16)
flows.force_lin.s.support:     array(16)
flows.hsig_dofs.s.hstate:      array...payload.m.faults.break: array(16)
fxns.hold_payload.m.faults.deform: array(16)
time:                          array(16)
nomresult = t15p0: 
--plan_path.t.time:                 15.0
--dofs.s.x:                          0.0
kwargs = {'cut_hist': True, 'desired_result': {15: ['plan_path.t.time', 'dofs.s.x']}, 'run_stochastic': False, 'staged': True, ...}
desired_result = {15: ['plan_path.t.time', 'dofs.s.x']}, staged = True
cut_hist = True, run_stochastic = False, use_end_condition = True
warn_faults = True, start_time = 2.0

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mprop_one_scen#x1B[39;49;00m(mdl, scen, ctimes=[], nomhist={}, nomresult={}, **kwargs):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Simulate a single scenario in the model over time.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    mdl : Simulable#x1B[39;49;00m
    #x1B[33m        The model to inject faults in.#x1B[39;49;00m
    #x1B[33m    scen : Scenario#x1B[39;49;00m
    #x1B[33m        The Scenario to run.#x1B[39;49;00m
    #x1B[33m    ctimes : list, optional#x1B[39;49;00m
    #x1B[33m        List of times to copy the model (for use in staged execution).#x1B[39;49;00m
    #x1B[33m        The default is [].#x1B[39;49;00m
    #x1B[33m    nomhist : dict, optional#x1B[39;49;00m
    #x1B[33m        Model history dictionary from previous runs, for use in creating the new#x1B[39;49;00m
    #x1B[33m        mdlhist. The default is {}.#x1B[39;49;00m
    #x1B[33m    nomresult : dict, optional#x1B[39;49;00m
    #x1B[33m        Nominal result dictionary (to compare with current if desired)#x1B[39;49;00m
    #x1B[33m    **kwargs : kwargs#x1B[39;49;00m
    #x1B[33m        simulation options, see :data:`sim_kwargs`#x1B[39;49;00m
    #x1B[33m    Returns#x1B[39;49;00m
    #x1B[33m    -------#x1B[39;49;00m
    #x1B[33m    result: Result#x1B[39;49;00m
    #x1B[33m        dict of result corresponding to desired_result.#x1B[39;49;00m
    #x1B[33m    mdlhist : dict#x1B[39;49;00m
    #x1B[33m        A dictionary with a history of modelstates.#x1B[39;49;00m
    #x1B[33m    c_mdl : dict#x1B[39;49;00m
    #x1B[33m        A dictionary of models at each time given in ctimes with structure {time:model}#x1B[39;49;00m
    #x1B[33m    t_end: float#x1B[39;49;00m
    #x1B[33m        Last sim time#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        desired_result, staged, cut_hist, run_stochastic, use_end_condition, warn_faults = unpack_sim_kwargs(**kwargs)#x1B[90m#x1B[39;49;00m
        #x1B[90m# if staged, we want it to start a new run from the starting time of the scenario,#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# using a copy of the input model (which is the nominal run) at this time#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m staged:#x1B[90m#x1B[39;49;00m
            start_time = scen.time#x1B[90m#x1B[39;49;00m
        #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
            start_time = #x1B[94m0#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        timerange = mdl.sp.get_timerange(start_time)#x1B[90m#x1B[39;49;00m
        #x1B[90m# check if sequence is out of timerange#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
            #x1B[94mif#x1B[39;49;00m t #x1B[95mnot#x1B[39;49;00m #x1B[95min#x1B[39;49;00m timerange:#x1B[90m#x1B[39;49;00m
                #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mt=#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m+#x1B[96mstr#x1B[39;49;00m(t)+#x1B[33m"#x1B[39;49;00m#x1B[33m from sequence not in timerange: #x1B[39;49;00m#x1B[33m"#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
                                + #x1B[96mstr#x1B[39;49;00m(timerange))#x1B[90m#x1B[39;49;00m
        shift = mdl.sp.get_shift(start_time)#x1B[90m#x1B[39;49;00m
        mdl.init_time_hist()#x1B[90m#x1B[39;49;00m
        #x1B[90m# run model through the time range defined in the object#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        c_mdl = #x1B[96mdict#x1B[39;49;00m.fromkeys(ctimes)#x1B[90m#x1B[39;49;00m
        result = Result()#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t_ind, t #x1B[95min#x1B[39;49;00m #x1B[96menumerate#x1B[39;49;00m(timerange):#x1B[90m#x1B[39;49;00m
            #x1B[90m# inject fault when it occurs, track defined flow states and graph#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
            #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m ctimes:#x1B[90m#x1B[39;49;00m
                    c_mdl[t] = mdl.copy()#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
                    fxnfaults = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mfaults#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                    disturbances = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mdisturbances#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                    fxnfaults = {}#x1B[90m#x1B[39;49;00m
                    disturbances = {}#x1B[90m#x1B[39;49;00m
                #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                    mdl.propagate(t, fxnfaults, disturbances, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
                #x1B[94mexcept#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m #x1B[94mas#x1B[39;49;00m e:#x1B[90m#x1B[39;49;00m
&gt;                   #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mError in scenario #x1B[39;49;00m#x1B[33m"#x1B[39;49;00m + #x1B[96mstr#x1B[39;49;00m(scen)) #x1B[94mfrom#x1B[39;49;00m #x1B[04m#x1B[96me#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mE                   Exception: Error in scenario SingleFaultScenario(sequence={5.0: Injection(faults={'affect_dof': ['rf_propwarp']}, disturbances={})}, times=(5,), function='affect_dof', fault='rf_propwarp', rate=1.0000000000000001e-07, name='affect_dof_rf_propwarp_t5', time=2.0, phase='')#x1B[0m

#x1B[1m#x1B[31mfmdtools\sim\propagate.py#x1B[0m:1113: Exception</failure></testcase><testcase classname="examples.multirotor.test_multirotor.DroneScenarioTest3" name="test_scenprob_results" time="0.290"><failure message="Exception: Error in scenario SingleFaultScenario(sequence={6.0: Injection(faults={'affect_dof': ['rf_propwarp']}, disturbances={})}, times=(6,), function='affect_dof', fault='rf_propwarp', rate=1.0000000000000001e-07, name='affect_dof_rf_propwarp_t6', time=2.0, phase='')">self = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults=set())
store_ee StoreEE
- St...y=150.0, z=100.0)
des_traj DesTraj flow: DesTrajState(dx=50.0, dy=50.0, dz=0.0, power=1.0)
environment DroneEnvironment
time = 6.0, fxnfaults = {'affect_dof': ['rf_propwarp']}, disturbances = {}
proptype = 'both', run_stochastic = False

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mpropagate#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m, time, fxnfaults={}, disturbances={}, proptype=#x1B[33m"#x1B[39;49;00m#x1B[33mboth#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                  run_stochastic=#x1B[94mFalse#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Inject and propagates faults through the graph at one time-step.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    time : float#x1B[39;49;00m
    #x1B[33m        The current time-step.#x1B[39;49;00m
    #x1B[33m    fxnfaults : dict#x1B[39;49;00m
    #x1B[33m        Faults to inject during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function':['fault1', 'fault2'...]}#x1B[39;49;00m
    #x1B[33m    disturbances : dict#x1B[39;49;00m
    #x1B[33m        Variables to change during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function.var1':value}#x1B[39;49;00m
    #x1B[33m    proptype : str#x1B[39;49;00m
    #x1B[33m        Whether the propagate 'static' or 'dynamic' behaviors, or 'both'. Default#x1B[39;49;00m
    #x1B[33m        is 'both'.#x1B[39;49;00m
    #x1B[33m    run_stochastic : bool#x1B[39;49;00m
    #x1B[33m        Whether to run stochastic behaviors or use default values. Default is False.#x1B[39;49;00m
    #x1B[33m        Can set as 'track_pdf' to calculate/track the probability densities of#x1B[39;49;00m
    #x1B[33m        random states over time.#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 0: Update model states with disturbances and faults#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[96mself#x1B[39;49;00m.set_vars(**disturbances)#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m fxnfaults:#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.inject_faults(fxnfaults)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 1: Run Dynamic Propagation Methods in Order Specified#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m fxnname #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.dynamicfxns:#x1B[90m#x1B[39;49;00m
            fxn = #x1B[96mself#x1B[39;49;00m.fxns[fxnname]#x1B[90m#x1B[39;49;00m
            fxn(#x1B[33m'#x1B[39;49;00m#x1B[33mdynamic#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, time=time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 2: Run Static Propagation Methods#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
&gt;           #x1B[96mself#x1B[39;49;00m.prop_static(time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m

#x1B[1m#x1B[31mfmdtools\define\architecture\function.py#x1B[0m:794: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
#x1B[1m#x1B[31mfmdtools\define\architecture\function.py#x1B[0m:824: in prop_static
    #x1B[0m#x1B[96mself#x1B[39;49;00m.fxns[fxnname](#x1B[33m'#x1B[39;49;00m#x1B[33mstatic#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, time=time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\define\block\function.py#x1B[0m:187: in __call__
    #x1B[0m#x1B[96mself#x1B[39;49;00m.static_behavior(time)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mexamples\multirotor\drone_mdl_hierarchical.py#x1B[0m:165: in static_behavior
    #x1B[0m#x1B[96mself#x1B[39;49;00m.reconfig_faults()#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mexamples\multirotor\drone_mdl_rural.py#x1B[0m:496: in reconfig_faults
    #x1B[0mAffectDOFHierarchical.reconfig_faults(#x1B[96mself#x1B[39;49;00m)#x1B[90m#x1B[39;49;00m
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = affect_dof AffectDOF
- OverallAffectDOFState(lrstab=0.0, frstab=-0.5, amp_factor=1.0)
- AffectMode(mode=nominal, faults={'rf_propwarp'})

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mreconfig_faults#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""Corrects for individual line faultmodes by turning off the opposite rotor#x1B[39;49;00m
    #x1B[33m    and upping the throttle (amp_factor)"""#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m fault #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.m.faults:#x1B[90m#x1B[39;49;00m
&gt;           #x1B[94mif#x1B[39;49;00m fault #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.ca.faultmodes:#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mE           AttributeError: 'AffectDOFArch' object has no attribute 'faultmodes'#x1B[0m

#x1B[1m#x1B[31mexamples\multirotor\drone_mdl_hierarchical.py#x1B[0m:172: AttributeError

#x1B[33mThe above exception was the direct cause of the following exception:#x1B[0m

mdl = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults=set())
store_ee StoreEE
- St...y=150.0, z=100.0)
des_traj DesTraj flow: DesTrajState(dx=50.0, dy=50.0, dz=0.0, power=1.0)
environment DroneEnvironment
scen = SingleFaultScenario(sequence={6.0: Injection(faults={'affect_dof': ['rf_propwarp']}, disturbances={})}, times=(6,), fu...n='affect_dof', fault='rf_propwarp', rate=1.0000000000000001e-07, name='affect_dof_rf_propwarp_t6', time=2.0, phase='')
ctimes = []
nomhist = flows.force_st.s.support:      array(16)
flows.force_lin.s.support:     array(16)
flows.hsig_dofs.s.hstate:      array...payload.m.faults.break: array(16)
fxns.hold_payload.m.faults.deform: array(16)
time:                          array(16)
nomresult = t15p0: 
--plan_path.t.time:                 15.0
--dofs.s.x:                          0.0
kwargs = {'cut_hist': True, 'desired_result': {15: ['plan_path.t.time', 'dofs.s.x']}, 'run_stochastic': False, 'staged': True, ...}
desired_result = {15: ['plan_path.t.time', 'dofs.s.x']}, staged = True
cut_hist = True, run_stochastic = False, use_end_condition = True
warn_faults = True, start_time = 2.0

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mprop_one_scen#x1B[39;49;00m(mdl, scen, ctimes=[], nomhist={}, nomresult={}, **kwargs):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Simulate a single scenario in the model over time.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    mdl : Simulable#x1B[39;49;00m
    #x1B[33m        The model to inject faults in.#x1B[39;49;00m
    #x1B[33m    scen : Scenario#x1B[39;49;00m
    #x1B[33m        The Scenario to run.#x1B[39;49;00m
    #x1B[33m    ctimes : list, optional#x1B[39;49;00m
    #x1B[33m        List of times to copy the model (for use in staged execution).#x1B[39;49;00m
    #x1B[33m        The default is [].#x1B[39;49;00m
    #x1B[33m    nomhist : dict, optional#x1B[39;49;00m
    #x1B[33m        Model history dictionary from previous runs, for use in creating the new#x1B[39;49;00m
    #x1B[33m        mdlhist. The default is {}.#x1B[39;49;00m
    #x1B[33m    nomresult : dict, optional#x1B[39;49;00m
    #x1B[33m        Nominal result dictionary (to compare with current if desired)#x1B[39;49;00m
    #x1B[33m    **kwargs : kwargs#x1B[39;49;00m
    #x1B[33m        simulation options, see :data:`sim_kwargs`#x1B[39;49;00m
    #x1B[33m    Returns#x1B[39;49;00m
    #x1B[33m    -------#x1B[39;49;00m
    #x1B[33m    result: Result#x1B[39;49;00m
    #x1B[33m        dict of result corresponding to desired_result.#x1B[39;49;00m
    #x1B[33m    mdlhist : dict#x1B[39;49;00m
    #x1B[33m        A dictionary with a history of modelstates.#x1B[39;49;00m
    #x1B[33m    c_mdl : dict#x1B[39;49;00m
    #x1B[33m        A dictionary of models at each time given in ctimes with structure {time:model}#x1B[39;49;00m
    #x1B[33m    t_end: float#x1B[39;49;00m
    #x1B[33m        Last sim time#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        desired_result, staged, cut_hist, run_stochastic, use_end_condition, warn_faults = unpack_sim_kwargs(**kwargs)#x1B[90m#x1B[39;49;00m
        #x1B[90m# if staged, we want it to start a new run from the starting time of the scenario,#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# using a copy of the input model (which is the nominal run) at this time#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m staged:#x1B[90m#x1B[39;49;00m
            start_time = scen.time#x1B[90m#x1B[39;49;00m
        #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
            start_time = #x1B[94m0#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        timerange = mdl.sp.get_timerange(start_time)#x1B[90m#x1B[39;49;00m
        #x1B[90m# check if sequence is out of timerange#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
            #x1B[94mif#x1B[39;49;00m t #x1B[95mnot#x1B[39;49;00m #x1B[95min#x1B[39;49;00m timerange:#x1B[90m#x1B[39;49;00m
                #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mt=#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m+#x1B[96mstr#x1B[39;49;00m(t)+#x1B[33m"#x1B[39;49;00m#x1B[33m from sequence not in timerange: #x1B[39;49;00m#x1B[33m"#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
                                + #x1B[96mstr#x1B[39;49;00m(timerange))#x1B[90m#x1B[39;49;00m
        shift = mdl.sp.get_shift(start_time)#x1B[90m#x1B[39;49;00m
        mdl.init_time_hist()#x1B[90m#x1B[39;49;00m
        #x1B[90m# run model through the time range defined in the object#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        c_mdl = #x1B[96mdict#x1B[39;49;00m.fromkeys(ctimes)#x1B[90m#x1B[39;49;00m
        result = Result()#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t_ind, t #x1B[95min#x1B[39;49;00m #x1B[96menumerate#x1B[39;49;00m(timerange):#x1B[90m#x1B[39;49;00m
            #x1B[90m# inject fault when it occurs, track defined flow states and graph#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
            #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m ctimes:#x1B[90m#x1B[39;49;00m
                    c_mdl[t] = mdl.copy()#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
                    fxnfaults = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mfaults#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                    disturbances = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mdisturbances#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                    fxnfaults = {}#x1B[90m#x1B[39;49;00m
                    disturbances = {}#x1B[90m#x1B[39;49;00m
                #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
&gt;                   mdl.propagate(t, fxnfaults, disturbances, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m

#x1B[1m#x1B[31mfmdtools\sim\propagate.py#x1B[0m:1111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults=set())
store_ee StoreEE
- St...y=150.0, z=100.0)
des_traj DesTraj flow: DesTrajState(dx=50.0, dy=50.0, dz=0.0, power=1.0)
environment DroneEnvironment
time = 6.0, fxnfaults = {'affect_dof': ['rf_propwarp']}, disturbances = {}
proptype = 'both', run_stochastic = False

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mpropagate#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m, time, fxnfaults={}, disturbances={}, proptype=#x1B[33m"#x1B[39;49;00m#x1B[33mboth#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                  run_stochastic=#x1B[94mFalse#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Inject and propagates faults through the graph at one time-step.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    time : float#x1B[39;49;00m
    #x1B[33m        The current time-step.#x1B[39;49;00m
    #x1B[33m    fxnfaults : dict#x1B[39;49;00m
    #x1B[33m        Faults to inject during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function':['fault1', 'fault2'...]}#x1B[39;49;00m
    #x1B[33m    disturbances : dict#x1B[39;49;00m
    #x1B[33m        Variables to change during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function.var1':value}#x1B[39;49;00m
    #x1B[33m    proptype : str#x1B[39;49;00m
    #x1B[33m        Whether the propagate 'static' or 'dynamic' behaviors, or 'both'. Default#x1B[39;49;00m
    #x1B[33m        is 'both'.#x1B[39;49;00m
    #x1B[33m    run_stochastic : bool#x1B[39;49;00m
    #x1B[33m        Whether to run stochastic behaviors or use default values. Default is False.#x1B[39;49;00m
    #x1B[33m        Can set as 'track_pdf' to calculate/track the probability densities of#x1B[39;49;00m
    #x1B[33m        random states over time.#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 0: Update model states with disturbances and faults#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[96mself#x1B[39;49;00m.set_vars(**disturbances)#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m fxnfaults:#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.inject_faults(fxnfaults)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 1: Run Dynamic Propagation Methods in Order Specified#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m fxnname #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.dynamicfxns:#x1B[90m#x1B[39;49;00m
            fxn = #x1B[96mself#x1B[39;49;00m.fxns[fxnname]#x1B[90m#x1B[39;49;00m
            fxn(#x1B[33m'#x1B[39;49;00m#x1B[33mdynamic#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, time=time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 2: Run Static Propagation Methods#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.prop_static(time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
        #x1B[94mexcept#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m #x1B[94mas#x1B[39;49;00m e:#x1B[90m#x1B[39;49;00m
&gt;           #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mError in static propagation at time t=#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m + #x1B[96mstr#x1B[39;49;00m(time)) #x1B[94mfrom#x1B[39;49;00m #x1B[04m#x1B[96me#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mE           Exception: Error in static propagation at time t=6.0#x1B[0m

#x1B[1m#x1B[31mfmdtools\define\architecture\function.py#x1B[0m:796: Exception

#x1B[33mThe above exception was the direct cause of the following exception:#x1B[0m

self = &lt;examples.multirotor.test_multirotor.DroneScenarioTest3 testMethod=test_scenprob_results&gt;

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mtest_scenprob_results#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""Test that the objective lines up with expected results at the given time."""#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# fault should cause the final x (f5) to match the nominal x at the fault time#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        x_nominal = #x1B[96mself#x1B[39;49;00m.hist.flows.dofs.s.x[#x1B[96mself#x1B[39;49;00m.time]#x1B[90m#x1B[39;49;00m
&gt;       x_failure = sp.f2(#x1B[96mself#x1B[39;49;00m.time)#x1B[90m#x1B[39;49;00m

#x1B[1m#x1B[31mexamples\multirotor\test_multirotor.py#x1B[0m:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:216: in newobj
    #x1B[0m#x1B[94mreturn#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.call_objective(*x, objective=name)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:279: in call_objective
    #x1B[0m#x1B[96mself#x1B[39;49;00m.update_objectives(*x)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:713: in update_objectives
    #x1B[0m#x1B[96mself#x1B[39;49;00m.res, #x1B[96mself#x1B[39;49;00m.hist = #x1B[96mself#x1B[39;49;00m.sim_mdl(*#x1B[96mself#x1B[39;49;00m.current_x())#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:894: in sim_mdl
    #x1B[0mres, hist, _, t_end = #x1B[96mself#x1B[39;49;00m.prop_method(mdl,#x1B[90m#x1B[39;49;00m
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

mdl = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults=set())
store_ee StoreEE
- St...y=150.0, z=100.0)
des_traj DesTraj flow: DesTrajState(dx=50.0, dy=50.0, dz=0.0, power=1.0)
environment DroneEnvironment
scen = SingleFaultScenario(sequence={6.0: Injection(faults={'affect_dof': ['rf_propwarp']}, disturbances={})}, times=(6,), fu...n='affect_dof', fault='rf_propwarp', rate=1.0000000000000001e-07, name='affect_dof_rf_propwarp_t6', time=2.0, phase='')
ctimes = []
nomhist = flows.force_st.s.support:      array(16)
flows.force_lin.s.support:     array(16)
flows.hsig_dofs.s.hstate:      array...payload.m.faults.break: array(16)
fxns.hold_payload.m.faults.deform: array(16)
time:                          array(16)
nomresult = t15p0: 
--plan_path.t.time:                 15.0
--dofs.s.x:                          0.0
kwargs = {'cut_hist': True, 'desired_result': {15: ['plan_path.t.time', 'dofs.s.x']}, 'run_stochastic': False, 'staged': True, ...}
desired_result = {15: ['plan_path.t.time', 'dofs.s.x']}, staged = True
cut_hist = True, run_stochastic = False, use_end_condition = True
warn_faults = True, start_time = 2.0

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mprop_one_scen#x1B[39;49;00m(mdl, scen, ctimes=[], nomhist={}, nomresult={}, **kwargs):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Simulate a single scenario in the model over time.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    mdl : Simulable#x1B[39;49;00m
    #x1B[33m        The model to inject faults in.#x1B[39;49;00m
    #x1B[33m    scen : Scenario#x1B[39;49;00m
    #x1B[33m        The Scenario to run.#x1B[39;49;00m
    #x1B[33m    ctimes : list, optional#x1B[39;49;00m
    #x1B[33m        List of times to copy the model (for use in staged execution).#x1B[39;49;00m
    #x1B[33m        The default is [].#x1B[39;49;00m
    #x1B[33m    nomhist : dict, optional#x1B[39;49;00m
    #x1B[33m        Model history dictionary from previous runs, for use in creating the new#x1B[39;49;00m
    #x1B[33m        mdlhist. The default is {}.#x1B[39;49;00m
    #x1B[33m    nomresult : dict, optional#x1B[39;49;00m
    #x1B[33m        Nominal result dictionary (to compare with current if desired)#x1B[39;49;00m
    #x1B[33m    **kwargs : kwargs#x1B[39;49;00m
    #x1B[33m        simulation options, see :data:`sim_kwargs`#x1B[39;49;00m
    #x1B[33m    Returns#x1B[39;49;00m
    #x1B[33m    -------#x1B[39;49;00m
    #x1B[33m    result: Result#x1B[39;49;00m
    #x1B[33m        dict of result corresponding to desired_result.#x1B[39;49;00m
    #x1B[33m    mdlhist : dict#x1B[39;49;00m
    #x1B[33m        A dictionary with a history of modelstates.#x1B[39;49;00m
    #x1B[33m    c_mdl : dict#x1B[39;49;00m
    #x1B[33m        A dictionary of models at each time given in ctimes with structure {time:model}#x1B[39;49;00m
    #x1B[33m    t_end: float#x1B[39;49;00m
    #x1B[33m        Last sim time#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        desired_result, staged, cut_hist, run_stochastic, use_end_condition, warn_faults = unpack_sim_kwargs(**kwargs)#x1B[90m#x1B[39;49;00m
        #x1B[90m# if staged, we want it to start a new run from the starting time of the scenario,#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# using a copy of the input model (which is the nominal run) at this time#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m staged:#x1B[90m#x1B[39;49;00m
            start_time = scen.time#x1B[90m#x1B[39;49;00m
        #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
            start_time = #x1B[94m0#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        timerange = mdl.sp.get_timerange(start_time)#x1B[90m#x1B[39;49;00m
        #x1B[90m# check if sequence is out of timerange#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
            #x1B[94mif#x1B[39;49;00m t #x1B[95mnot#x1B[39;49;00m #x1B[95min#x1B[39;49;00m timerange:#x1B[90m#x1B[39;49;00m
                #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mt=#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m+#x1B[96mstr#x1B[39;49;00m(t)+#x1B[33m"#x1B[39;49;00m#x1B[33m from sequence not in timerange: #x1B[39;49;00m#x1B[33m"#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
                                + #x1B[96mstr#x1B[39;49;00m(timerange))#x1B[90m#x1B[39;49;00m
        shift = mdl.sp.get_shift(start_time)#x1B[90m#x1B[39;49;00m
        mdl.init_time_hist()#x1B[90m#x1B[39;49;00m
        #x1B[90m# run model through the time range defined in the object#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        c_mdl = #x1B[96mdict#x1B[39;49;00m.fromkeys(ctimes)#x1B[90m#x1B[39;49;00m
        result = Result()#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t_ind, t #x1B[95min#x1B[39;49;00m #x1B[96menumerate#x1B[39;49;00m(timerange):#x1B[90m#x1B[39;49;00m
            #x1B[90m# inject fault when it occurs, track defined flow states and graph#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
            #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m ctimes:#x1B[90m#x1B[39;49;00m
                    c_mdl[t] = mdl.copy()#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
                    fxnfaults = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mfaults#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                    disturbances = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mdisturbances#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                    fxnfaults = {}#x1B[90m#x1B[39;49;00m
                    disturbances = {}#x1B[90m#x1B[39;49;00m
                #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                    mdl.propagate(t, fxnfaults, disturbances, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
                #x1B[94mexcept#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m #x1B[94mas#x1B[39;49;00m e:#x1B[90m#x1B[39;49;00m
&gt;                   #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mError in scenario #x1B[39;49;00m#x1B[33m"#x1B[39;49;00m + #x1B[96mstr#x1B[39;49;00m(scen)) #x1B[94mfrom#x1B[39;49;00m #x1B[04m#x1B[96me#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mE                   Exception: Error in scenario SingleFaultScenario(sequence={6.0: Injection(faults={'affect_dof': ['rf_propwarp']}, disturbances={})}, times=(6,), function='affect_dof', fault='rf_propwarp', rate=1.0000000000000001e-07, name='affect_dof_rf_propwarp_t6', time=2.0, phase='')#x1B[0m

#x1B[1m#x1B[31mfmdtools\sim\propagate.py#x1B[0m:1113: Exception</failure></testcase><testcase classname="examples.multirotor.test_multirotor.DroneDisturbanceTest" name="test_disturbance_set" time="0.193"><failure message="Exception: Error in scenario Scenario(sequence={5.0: Injection(faults={}, disturbances={'store_ee.ca.comps.s1p1.s.soc': 10.0})}, times=(), rate=1.0, name='disturbance', time=5.0)">self = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults={'lostfunction'})
store_ee S...=0.0, y=0.0, z=0.0)
des_traj DesTraj flow: DesTrajState(dx=0.0, dy=0.0, dz=0.0, power=0.0)
environment DroneEnvironment
time = 6.0, fxnfaults = {}, disturbances = {}, proptype = 'both'
run_stochastic = False

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mpropagate#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m, time, fxnfaults={}, disturbances={}, proptype=#x1B[33m"#x1B[39;49;00m#x1B[33mboth#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                  run_stochastic=#x1B[94mFalse#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Inject and propagates faults through the graph at one time-step.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    time : float#x1B[39;49;00m
    #x1B[33m        The current time-step.#x1B[39;49;00m
    #x1B[33m    fxnfaults : dict#x1B[39;49;00m
    #x1B[33m        Faults to inject during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function':['fault1', 'fault2'...]}#x1B[39;49;00m
    #x1B[33m    disturbances : dict#x1B[39;49;00m
    #x1B[33m        Variables to change during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function.var1':value}#x1B[39;49;00m
    #x1B[33m    proptype : str#x1B[39;49;00m
    #x1B[33m        Whether the propagate 'static' or 'dynamic' behaviors, or 'both'. Default#x1B[39;49;00m
    #x1B[33m        is 'both'.#x1B[39;49;00m
    #x1B[33m    run_stochastic : bool#x1B[39;49;00m
    #x1B[33m        Whether to run stochastic behaviors or use default values. Default is False.#x1B[39;49;00m
    #x1B[33m        Can set as 'track_pdf' to calculate/track the probability densities of#x1B[39;49;00m
    #x1B[33m        random states over time.#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 0: Update model states with disturbances and faults#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[96mself#x1B[39;49;00m.set_vars(**disturbances)#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m fxnfaults:#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.inject_faults(fxnfaults)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 1: Run Dynamic Propagation Methods in Order Specified#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m fxnname #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.dynamicfxns:#x1B[90m#x1B[39;49;00m
            fxn = #x1B[96mself#x1B[39;49;00m.fxns[fxnname]#x1B[90m#x1B[39;49;00m
            fxn(#x1B[33m'#x1B[39;49;00m#x1B[33mdynamic#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, time=time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 2: Run Static Propagation Methods#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
&gt;           #x1B[96mself#x1B[39;49;00m.prop_static(time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m

#x1B[1m#x1B[31mfmdtools\define\architecture\function.py#x1B[0m:794: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
#x1B[1m#x1B[31mfmdtools\define\architecture\function.py#x1B[0m:824: in prop_static
    #x1B[0m#x1B[96mself#x1B[39;49;00m.fxns[fxnname](#x1B[33m'#x1B[39;49;00m#x1B[33mstatic#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, time=time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\define\block\function.py#x1B[0m:187: in __call__
    #x1B[0m#x1B[96mself#x1B[39;49;00m.static_behavior(time)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mexamples\multirotor\drone_mdl_hierarchical.py#x1B[0m:165: in static_behavior
    #x1B[0m#x1B[96mself#x1B[39;49;00m.reconfig_faults()#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mexamples\multirotor\drone_mdl_rural.py#x1B[0m:496: in reconfig_faults
    #x1B[0mAffectDOFHierarchical.reconfig_faults(#x1B[96mself#x1B[39;49;00m)#x1B[90m#x1B[39;49;00m
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = affect_dof AffectDOF
- OverallAffectDOFState(lrstab=0.0, frstab=0.0, amp_factor=1.0)
- AffectMode(mode=nominal, faults...reak', 'lr_propbreak', 'rr_mechbreak', 'lf_mechbreak', 'rf_mechbreak', 'rr_propbreak', 'lf_propbreak', 'lr_mechbreak'})

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mreconfig_faults#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""Corrects for individual line faultmodes by turning off the opposite rotor#x1B[39;49;00m
    #x1B[33m    and upping the throttle (amp_factor)"""#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m fault #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.m.faults:#x1B[90m#x1B[39;49;00m
&gt;           #x1B[94mif#x1B[39;49;00m fault #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.ca.faultmodes:#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mE           AttributeError: 'AffectDOFArch' object has no attribute 'faultmodes'#x1B[0m

#x1B[1m#x1B[31mexamples\multirotor\drone_mdl_hierarchical.py#x1B[0m:172: AttributeError

#x1B[33mThe above exception was the direct cause of the following exception:#x1B[0m

mdl = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults={'lostfunction'})
store_ee S...=0.0, y=0.0, z=0.0)
des_traj DesTraj flow: DesTrajState(dx=0.0, dy=0.0, dz=0.0, power=0.0)
environment DroneEnvironment
scen = Scenario(sequence={5.0: Injection(faults={}, disturbances={'store_ee.ca.comps.s1p1.s.soc': 10.0})}, times=(), rate=1.0, name='disturbance', time=5.0)
ctimes = []
nomhist = flows.force_st.s.support:      array(11)
flows.force_lin.s.support:     array(11)
flows.hsig_dofs.s.hstate:      array...payload.m.faults.break: array(11)
fxns.hold_payload.m.faults.deform: array(11)
time:                          array(11)
nomresult = t5p0: 
--store_ee.s.soc:      91.33834586466166
t10p0: 
--store_ee.s.soc:      79.93984962406016
kwargs = {'cut_hist': True, 'desired_result': {5: ['store_ee.s.soc'], 10: ['store_ee.s.soc']}, 'run_stochastic': False, 'staged': True, ...}
desired_result = {5: ['store_ee.s.soc'], 10: ['store_ee.s.soc']}, staged = True
cut_hist = True, run_stochastic = False, use_end_condition = True
warn_faults = True, start_time = 5.0

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mprop_one_scen#x1B[39;49;00m(mdl, scen, ctimes=[], nomhist={}, nomresult={}, **kwargs):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Simulate a single scenario in the model over time.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    mdl : Simulable#x1B[39;49;00m
    #x1B[33m        The model to inject faults in.#x1B[39;49;00m
    #x1B[33m    scen : Scenario#x1B[39;49;00m
    #x1B[33m        The Scenario to run.#x1B[39;49;00m
    #x1B[33m    ctimes : list, optional#x1B[39;49;00m
    #x1B[33m        List of times to copy the model (for use in staged execution).#x1B[39;49;00m
    #x1B[33m        The default is [].#x1B[39;49;00m
    #x1B[33m    nomhist : dict, optional#x1B[39;49;00m
    #x1B[33m        Model history dictionary from previous runs, for use in creating the new#x1B[39;49;00m
    #x1B[33m        mdlhist. The default is {}.#x1B[39;49;00m
    #x1B[33m    nomresult : dict, optional#x1B[39;49;00m
    #x1B[33m        Nominal result dictionary (to compare with current if desired)#x1B[39;49;00m
    #x1B[33m    **kwargs : kwargs#x1B[39;49;00m
    #x1B[33m        simulation options, see :data:`sim_kwargs`#x1B[39;49;00m
    #x1B[33m    Returns#x1B[39;49;00m
    #x1B[33m    -------#x1B[39;49;00m
    #x1B[33m    result: Result#x1B[39;49;00m
    #x1B[33m        dict of result corresponding to desired_result.#x1B[39;49;00m
    #x1B[33m    mdlhist : dict#x1B[39;49;00m
    #x1B[33m        A dictionary with a history of modelstates.#x1B[39;49;00m
    #x1B[33m    c_mdl : dict#x1B[39;49;00m
    #x1B[33m        A dictionary of models at each time given in ctimes with structure {time:model}#x1B[39;49;00m
    #x1B[33m    t_end: float#x1B[39;49;00m
    #x1B[33m        Last sim time#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        desired_result, staged, cut_hist, run_stochastic, use_end_condition, warn_faults = unpack_sim_kwargs(**kwargs)#x1B[90m#x1B[39;49;00m
        #x1B[90m# if staged, we want it to start a new run from the starting time of the scenario,#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# using a copy of the input model (which is the nominal run) at this time#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m staged:#x1B[90m#x1B[39;49;00m
            start_time = scen.time#x1B[90m#x1B[39;49;00m
        #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
            start_time = #x1B[94m0#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        timerange = mdl.sp.get_timerange(start_time)#x1B[90m#x1B[39;49;00m
        #x1B[90m# check if sequence is out of timerange#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
            #x1B[94mif#x1B[39;49;00m t #x1B[95mnot#x1B[39;49;00m #x1B[95min#x1B[39;49;00m timerange:#x1B[90m#x1B[39;49;00m
                #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mt=#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m+#x1B[96mstr#x1B[39;49;00m(t)+#x1B[33m"#x1B[39;49;00m#x1B[33m from sequence not in timerange: #x1B[39;49;00m#x1B[33m"#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
                                + #x1B[96mstr#x1B[39;49;00m(timerange))#x1B[90m#x1B[39;49;00m
        shift = mdl.sp.get_shift(start_time)#x1B[90m#x1B[39;49;00m
        mdl.init_time_hist()#x1B[90m#x1B[39;49;00m
        #x1B[90m# run model through the time range defined in the object#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        c_mdl = #x1B[96mdict#x1B[39;49;00m.fromkeys(ctimes)#x1B[90m#x1B[39;49;00m
        result = Result()#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t_ind, t #x1B[95min#x1B[39;49;00m #x1B[96menumerate#x1B[39;49;00m(timerange):#x1B[90m#x1B[39;49;00m
            #x1B[90m# inject fault when it occurs, track defined flow states and graph#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
            #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m ctimes:#x1B[90m#x1B[39;49;00m
                    c_mdl[t] = mdl.copy()#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
                    fxnfaults = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mfaults#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                    disturbances = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mdisturbances#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                    fxnfaults = {}#x1B[90m#x1B[39;49;00m
                    disturbances = {}#x1B[90m#x1B[39;49;00m
                #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
&gt;                   mdl.propagate(t, fxnfaults, disturbances, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m

#x1B[1m#x1B[31mfmdtools\sim\propagate.py#x1B[0m:1111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults={'lostfunction'})
store_ee S...=0.0, y=0.0, z=0.0)
des_traj DesTraj flow: DesTrajState(dx=0.0, dy=0.0, dz=0.0, power=0.0)
environment DroneEnvironment
time = 6.0, fxnfaults = {}, disturbances = {}, proptype = 'both'
run_stochastic = False

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mpropagate#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m, time, fxnfaults={}, disturbances={}, proptype=#x1B[33m"#x1B[39;49;00m#x1B[33mboth#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                  run_stochastic=#x1B[94mFalse#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Inject and propagates faults through the graph at one time-step.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    time : float#x1B[39;49;00m
    #x1B[33m        The current time-step.#x1B[39;49;00m
    #x1B[33m    fxnfaults : dict#x1B[39;49;00m
    #x1B[33m        Faults to inject during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function':['fault1', 'fault2'...]}#x1B[39;49;00m
    #x1B[33m    disturbances : dict#x1B[39;49;00m
    #x1B[33m        Variables to change during this propagation step.#x1B[39;49;00m
    #x1B[33m        With structure {'function.var1':value}#x1B[39;49;00m
    #x1B[33m    proptype : str#x1B[39;49;00m
    #x1B[33m        Whether the propagate 'static' or 'dynamic' behaviors, or 'both'. Default#x1B[39;49;00m
    #x1B[33m        is 'both'.#x1B[39;49;00m
    #x1B[33m    run_stochastic : bool#x1B[39;49;00m
    #x1B[33m        Whether to run stochastic behaviors or use default values. Default is False.#x1B[39;49;00m
    #x1B[33m        Can set as 'track_pdf' to calculate/track the probability densities of#x1B[39;49;00m
    #x1B[33m        random states over time.#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 0: Update model states with disturbances and faults#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[96mself#x1B[39;49;00m.set_vars(**disturbances)#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m fxnfaults:#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.inject_faults(fxnfaults)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 1: Run Dynamic Propagation Methods in Order Specified#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m fxnname #x1B[95min#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.dynamicfxns:#x1B[90m#x1B[39;49;00m
            fxn = #x1B[96mself#x1B[39;49;00m.fxns[fxnname]#x1B[90m#x1B[39;49;00m
            fxn(#x1B[33m'#x1B[39;49;00m#x1B[33mdynamic#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, time=time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
    #x1B[90m#x1B[39;49;00m
        #x1B[90m# Step 2: Run Static Propagation Methods#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.prop_static(time, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
        #x1B[94mexcept#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m #x1B[94mas#x1B[39;49;00m e:#x1B[90m#x1B[39;49;00m
&gt;           #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mError in static propagation at time t=#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m + #x1B[96mstr#x1B[39;49;00m(time)) #x1B[94mfrom#x1B[39;49;00m #x1B[04m#x1B[96me#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mE           Exception: Error in static propagation at time t=6.0#x1B[0m

#x1B[1m#x1B[31mfmdtools\define\architecture\function.py#x1B[0m:796: Exception

#x1B[33mThe above exception was the direct cause of the following exception:#x1B[0m

self = &lt;examples.multirotor.test_multirotor.DroneDisturbanceTest testMethod=test_disturbance_set&gt;

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mtest_disturbance_set#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""Test that disturbance objectives set and call properly."""#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# make sure the disturbance is set (note that we correct by amt b/c of use)#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        soc_set = #x1B[94m10.0#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        amt = mdl.fxns[#x1B[33m'#x1B[39;49;00m#x1B[33mstore_ee#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m].ca.comps[#x1B[33m'#x1B[39;49;00m#x1B[33ms1p1#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m].p.amt#x1B[90m#x1B[39;49;00m
        soc_expected = soc_set - #x1B[94m100#x1B[39;49;00m/amt#x1B[90m#x1B[39;49;00m
&gt;       soc_res = sp2.f2(soc_set)#x1B[90m#x1B[39;49;00m

#x1B[1m#x1B[31mexamples\multirotor\test_multirotor.py#x1B[0m:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:216: in newobj
    #x1B[0m#x1B[94mreturn#x1B[39;49;00m #x1B[96mself#x1B[39;49;00m.call_objective(*x, objective=name)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:279: in call_objective
    #x1B[0m#x1B[96mself#x1B[39;49;00m.update_objectives(*x)#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:713: in update_objectives
    #x1B[0m#x1B[96mself#x1B[39;49;00m.res, #x1B[96mself#x1B[39;49;00m.hist = #x1B[96mself#x1B[39;49;00m.sim_mdl(*#x1B[96mself#x1B[39;49;00m.current_x())#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mfmdtools\sim\search.py#x1B[0m:894: in sim_mdl
    #x1B[0mres, hist, _, t_end = #x1B[96mself#x1B[39;49;00m.prop_method(mdl,#x1B[90m#x1B[39;49;00m
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

mdl = drone Drone
FUNCTIONS:
manage_health ManageHealth
- ManageHealthMode(mode=nominal, faults={'lostfunction'})
store_ee S...=0.0, y=0.0, z=0.0)
des_traj DesTraj flow: DesTrajState(dx=0.0, dy=0.0, dz=0.0, power=0.0)
environment DroneEnvironment
scen = Scenario(sequence={5.0: Injection(faults={}, disturbances={'store_ee.ca.comps.s1p1.s.soc': 10.0})}, times=(), rate=1.0, name='disturbance', time=5.0)
ctimes = []
nomhist = flows.force_st.s.support:      array(11)
flows.force_lin.s.support:     array(11)
flows.hsig_dofs.s.hstate:      array...payload.m.faults.break: array(11)
fxns.hold_payload.m.faults.deform: array(11)
time:                          array(11)
nomresult = t5p0: 
--store_ee.s.soc:      91.33834586466166
t10p0: 
--store_ee.s.soc:      79.93984962406016
kwargs = {'cut_hist': True, 'desired_result': {5: ['store_ee.s.soc'], 10: ['store_ee.s.soc']}, 'run_stochastic': False, 'staged': True, ...}
desired_result = {5: ['store_ee.s.soc'], 10: ['store_ee.s.soc']}, staged = True
cut_hist = True, run_stochastic = False, use_end_condition = True
warn_faults = True, start_time = 5.0

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mprop_one_scen#x1B[39;49;00m(mdl, scen, ctimes=[], nomhist={}, nomresult={}, **kwargs):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""#x1B[39;49;00m
    #x1B[33m    Simulate a single scenario in the model over time.#x1B[39;49;00m
    #x1B[33m#x1B[39;49;00m
    #x1B[33m    Parameters#x1B[39;49;00m
    #x1B[33m    ----------#x1B[39;49;00m
    #x1B[33m    mdl : Simulable#x1B[39;49;00m
    #x1B[33m        The model to inject faults in.#x1B[39;49;00m
    #x1B[33m    scen : Scenario#x1B[39;49;00m
    #x1B[33m        The Scenario to run.#x1B[39;49;00m
    #x1B[33m    ctimes : list, optional#x1B[39;49;00m
    #x1B[33m        List of times to copy the model (for use in staged execution).#x1B[39;49;00m
    #x1B[33m        The default is [].#x1B[39;49;00m
    #x1B[33m    nomhist : dict, optional#x1B[39;49;00m
    #x1B[33m        Model history dictionary from previous runs, for use in creating the new#x1B[39;49;00m
    #x1B[33m        mdlhist. The default is {}.#x1B[39;49;00m
    #x1B[33m    nomresult : dict, optional#x1B[39;49;00m
    #x1B[33m        Nominal result dictionary (to compare with current if desired)#x1B[39;49;00m
    #x1B[33m    **kwargs : kwargs#x1B[39;49;00m
    #x1B[33m        simulation options, see :data:`sim_kwargs`#x1B[39;49;00m
    #x1B[33m    Returns#x1B[39;49;00m
    #x1B[33m    -------#x1B[39;49;00m
    #x1B[33m    result: Result#x1B[39;49;00m
    #x1B[33m        dict of result corresponding to desired_result.#x1B[39;49;00m
    #x1B[33m    mdlhist : dict#x1B[39;49;00m
    #x1B[33m        A dictionary with a history of modelstates.#x1B[39;49;00m
    #x1B[33m    c_mdl : dict#x1B[39;49;00m
    #x1B[33m        A dictionary of models at each time given in ctimes with structure {time:model}#x1B[39;49;00m
    #x1B[33m    t_end: float#x1B[39;49;00m
    #x1B[33m        Last sim time#x1B[39;49;00m
    #x1B[33m    """#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        desired_result, staged, cut_hist, run_stochastic, use_end_condition, warn_faults = unpack_sim_kwargs(**kwargs)#x1B[90m#x1B[39;49;00m
        #x1B[90m# if staged, we want it to start a new run from the starting time of the scenario,#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[90m# using a copy of the input model (which is the nominal run) at this time#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mif#x1B[39;49;00m staged:#x1B[90m#x1B[39;49;00m
            start_time = scen.time#x1B[90m#x1B[39;49;00m
        #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
            start_time = #x1B[94m0#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        timerange = mdl.sp.get_timerange(start_time)#x1B[90m#x1B[39;49;00m
        #x1B[90m# check if sequence is out of timerange#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
            #x1B[94mif#x1B[39;49;00m t #x1B[95mnot#x1B[39;49;00m #x1B[95min#x1B[39;49;00m timerange:#x1B[90m#x1B[39;49;00m
                #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mt=#x1B[39;49;00m#x1B[33m"#x1B[39;49;00m+#x1B[96mstr#x1B[39;49;00m(t)+#x1B[33m"#x1B[39;49;00m#x1B[33m from sequence not in timerange: #x1B[39;49;00m#x1B[33m"#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
                                + #x1B[96mstr#x1B[39;49;00m(timerange))#x1B[90m#x1B[39;49;00m
        shift = mdl.sp.get_shift(start_time)#x1B[90m#x1B[39;49;00m
        mdl.init_time_hist()#x1B[90m#x1B[39;49;00m
        #x1B[90m# run model through the time range defined in the object#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        c_mdl = #x1B[96mdict#x1B[39;49;00m.fromkeys(ctimes)#x1B[90m#x1B[39;49;00m
        result = Result()#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m t_ind, t #x1B[95min#x1B[39;49;00m #x1B[96menumerate#x1B[39;49;00m(timerange):#x1B[90m#x1B[39;49;00m
            #x1B[90m# inject fault when it occurs, track defined flow states and graph#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
            #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m ctimes:#x1B[90m#x1B[39;49;00m
                    c_mdl[t] = mdl.copy()#x1B[90m#x1B[39;49;00m
                #x1B[94mif#x1B[39;49;00m t #x1B[95min#x1B[39;49;00m scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m]:#x1B[90m#x1B[39;49;00m
                    fxnfaults = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mfaults#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                    disturbances = scen[#x1B[33m'#x1B[39;49;00m#x1B[33msequence#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m][t].get(#x1B[33m'#x1B[39;49;00m#x1B[33mdisturbances#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m, {})#x1B[90m#x1B[39;49;00m
                #x1B[94melse#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                    fxnfaults = {}#x1B[90m#x1B[39;49;00m
                    disturbances = {}#x1B[90m#x1B[39;49;00m
                #x1B[94mtry#x1B[39;49;00m:#x1B[90m#x1B[39;49;00m
                    mdl.propagate(t, fxnfaults, disturbances, run_stochastic=run_stochastic)#x1B[90m#x1B[39;49;00m
                #x1B[94mexcept#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m #x1B[94mas#x1B[39;49;00m e:#x1B[90m#x1B[39;49;00m
&gt;                   #x1B[94mraise#x1B[39;49;00m #x1B[96mException#x1B[39;49;00m(#x1B[33m"#x1B[39;49;00m#x1B[33mError in scenario #x1B[39;49;00m#x1B[33m"#x1B[39;49;00m + #x1B[96mstr#x1B[39;49;00m(scen)) #x1B[94mfrom#x1B[39;49;00m #x1B[04m#x1B[96me#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mE                   Exception: Error in scenario Scenario(sequence={5.0: Injection(faults={}, disturbances={'store_ee.ca.comps.s1p1.s.soc': 10.0})}, times=(), rate=1.0, name='disturbance', time=5.0)#x1B[0m

#x1B[1m#x1B[31mfmdtools\sim\propagate.py#x1B[0m:1113: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_app_prop_values" time="0.373" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_approach_cost_calc" time="36.855" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_approach_parallelism" time="26.805" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_dynamic_prop_values" time="0.390" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_dynamic_prop_values_2" time="0.585" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_fault_sample_isave" time="4.771" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_fault_sample_save" time="4.420" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_fmea_options" time="0.587" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_hist_tracking_setup" time="0.024" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_model_copy_different" time="1.863" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_model_copy_same" time="3.446" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_model_reset" time="0.001"><skipped type="pytest.skip" message="Reset not fully implemented yet and unused throughout.">C:\Users\dhulse\Documents\GitHub\fmdtools\examples\pump\test_pump.py:137: Reset not fully implemented yet and unused throughout.</skipped></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_nested_sample_isave" time="47.561" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_nested_sample_save" time="49.766" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_nominal_save" time="0.232" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_one_run_csv" time="0.142" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_one_run_json" time="0.155" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_one_run_pickle" time="0.151" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_onefault_save" time="0.409" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_param_sample" time="0.015" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_param_sample_isave" time="2.006" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_param_sample_save" time="1.949" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_pickleability" time="0.018" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_save_load_multfault" time="0.449" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_single_faults_isave" time="2.028" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_single_faults_save" time="1.807" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_value_setting" time="0.014" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_value_setting_dict" time="0.014" /><testcase classname="examples.pump.test_pump.IndivPumpTests" name="test_mutable_setup" time="0.028" /><testcase classname="examples.pump.test_pump_example.ImportEE_Tests" name="test_behave_inf_v" time="0.002" /><testcase classname="examples.pump.test_pump_example.ImportEE_Tests" name="test_behave_no_v" time="0.002" /><testcase classname="examples.pump.test_pump_example.ImportEE_Tests" name="test_behave_nom" time="0.002" /><testcase classname="examples.pump.test_pump_example.ImportEE_Tests" name="test_condfaults_hi" time="0.002" /><testcase classname="examples.pump.test_pump_example.ImportEE_Tests" name="test_condfaults_nom" time="0.002" /><testcase classname="examples.pump.test_pump_example.ImportEE_Tests" name="test_initialization" time="0.002" /><testcase classname="examples.pump.test_pump_example.MoveWat_Tests" name="test_condfaults_dynamic" time="0.003" /><testcase classname="examples.pump.test_pump_example.MoveWat_Tests" name="test_initialization" time="0.002" /><testcase classname="examples.pump.test_pump_example.MoveWat_Tests" name="test_nom" time="0.002" /><testcase classname="examples.pump.test_pump_example.Integration_Tests" name="test_blockage_results" time="0.187" /><testcase classname="examples.pump.test_pump_example.Integration_Tests" name="test_blockage_static" time="0.018" /><testcase classname="examples.pump.test_pump_example.Integration_Tests" name="test_nominal_results" time="0.090" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_mdl_pickle" time="0.631" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_model_copy_different" time="2.273" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_model_copy_same" time="3.297" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_model_reset" time="0.001"><skipped type="pytest.skip" message="Reset not fully implemented yet and unused throughout.">C:\Users\dhulse\Documents\GitHub\fmdtools\examples\pump\test_pump_stochastic.py:115: Reset not fully implemented yet and unused throughout.</skipped></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_model_set_vars" time="0.013" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_nested_sample_isave" time="89.113" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_nested_sample_save" time="87.556" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_param_sample_isave" time="9.848" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_param_sample_save" time="9.664" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_plot_nested_hists" time="10.962" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_plot_nominal_vals" time="1.134" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_plot_nominal_vals_xd" time="58.641" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_rand_paramsample_plot" time="4.422" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_run_approach" time="100.929" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_run_safety" time="5.543" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_set_seeds" time="0.042" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_stochastic_pdf" time="0.009"><failure message="AssertionError: 35.23570453993965 != 6.634978895402383 within 7 places (28.600725644537263 difference)">self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_stochastic_pdf&gt;

    #x1B[0m#x1B[94mdef#x1B[39;49;00m #x1B[92mtest_stochastic_pdf#x1B[39;49;00m(#x1B[96mself#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
    #x1B[90m    #x1B[39;49;00m#x1B[33m"""Tests that (1) track_pdf option runs and (2) gives repeated#x1B[39;49;00m
    #x1B[33m    probability density results under the same seed(s)"""#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
        testvals = [#x1B[94m6.634978895402383#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                    #x1B[94m7.52240849998729#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                    #x1B[94m0.015351713962842411#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                    #x1B[94m4.19649888042945#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                    #x1B[94m0.11203099056041071#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                    #x1B[94m1.5036852812847645#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                    #x1B[94m7.936686476148655#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                    #x1B[94m0.0853617670950819#x1B[39;49;00m,#x1B[90m#x1B[39;49;00m
                    #x1B[94m3.0182506814918377#x1B[39;49;00m]#x1B[90m#x1B[39;49;00m
        #x1B[94mfor#x1B[39;49;00m i #x1B[95min#x1B[39;49;00m #x1B[96mrange#x1B[39;49;00m(#x1B[94m1#x1B[39;49;00m, #x1B[94m10#x1B[39;49;00m):#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.mdl.update_seed(i)#x1B[90m#x1B[39;49;00m
            #x1B[96mself#x1B[39;49;00m.mdl.propagate(i, run_stochastic=#x1B[33m'#x1B[39;49;00m#x1B[33mtrack_pdf#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m)#x1B[90m#x1B[39;49;00m
            pd = #x1B[96mself#x1B[39;49;00m.mdl.return_probdens()#x1B[90m#x1B[39;49;00m
            #x1B[90m# print(pd)#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
&gt;           #x1B[96mself#x1B[39;49;00m.assertAlmostEqual(pd, testvals[i-#x1B[94m1#x1B[39;49;00m])#x1B[90m#x1B[39;49;00m
#x1B[1m#x1B[31mE           AssertionError: 35.23570453993965 != 6.634978895402383 within 7 places (28.600725644537263 difference)#x1B[0m

#x1B[1m#x1B[31mexamples\pump\test_pump_stochastic.py#x1B[0m:61: AssertionError</failure></testcase><testcase classname="examples.rover.test_rover.RoverTests" name="test_obj_values" time="1.990" /><testcase classname="examples.tank.test_tank.TankTests" name="test_approach" time="2.983" /><testcase classname="examples.tank.test_tank.TankTests" name="test_approach_parallelism_0" time="8.507" /><testcase classname="examples.tank.test_tank.TankTests" name="test_approach_parallelism_1" time="13.388" /><testcase classname="examples.tank.test_tank.TankTests" name="test_approach_parallelism_notrack" time="7.994" /><testcase classname="examples.tank.test_tank.TankTests" name="test_comp_mode_inj" time="0.082" /><testcase classname="examples.tank.test_tank.TankTests" name="test_different_components" time="0.031" /><testcase classname="examples.tank.test_tank.TankTests" name="test_epc_math" time="0.019" /><testcase classname="examples.tank.test_tank.TankTests" name="test_fault_sample_isave" time="3.388" /><testcase classname="examples.tank.test_tank.TankTests" name="test_fault_sample_save" time="3.027" /><testcase classname="examples.tank.test_tank.TankTests" name="test_local_tstep" time="0.218" /><testcase classname="examples.tank.test_tank.TankTests" name="test_model_copy_different" time="0.976" /><testcase classname="examples.tank.test_tank.TankTests" name="test_model_copy_same" time="1.867" /><testcase classname="examples.tank.test_tank.TankTests" name="test_model_reset" time="0.001"><skipped type="pytest.skip" message="Reset not fully implemented yet and unused throughout.">C:\Users\dhulse\Documents\GitHub\fmdtools\examples\tank\test_tank.py:69: Reset not fully implemented yet and unused throughout.</skipped></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_nested_sample_isave" time="31.147" /><testcase classname="examples.tank.test_tank.TankTests" name="test_nested_sample_save" time="30.672" /><testcase classname="examples.tank.test_tank.TankTests" name="test_param_sample_save" time="1.103" /><testcase classname="examples.tank.test_tank.TankTests" name="test_save_load_multfault" time="0.223" /><testcase classname="examples.tank.test_tank.TankTests" name="test_save_load_nominal" time="0.152" /><testcase classname="examples.tank.test_tank.TankTests" name="test_save_load_onefault" time="0.216" /><testcase classname="examples.tank.test_tank.TankTests" name="test_save_load_singlefaults" time="1.593" /><testcase classname="examples.tank.test_tank.TankTests" name="test_singlefaults_isave" time="1.796" /><testcase classname="examples.tank.test_tank.TankTests" name="test_tank_copy_args" time="0.037" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_avoid" time="0.082" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_avoid_plot" time="0.356" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_heli_cycle" time="0.036" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_heli_cycle_plot" time="0.225" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_lost_sight" time="0.438" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_lost_sight_plot" time="0.608" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_one_cycle" time="0.061" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_one_cycle_plot" time="0.174" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_atc_lost_ground_perception" time="1.691" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_atc_lost_ground_perception_plot" time="1.713" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_atc_wrong_land_command" time="1.778" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_atc_wrong_land_command_lost_sight" time="1.840" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_atc_wrong_land_command_sight_plot" time="3.191" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_default_plots" time="2.492" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_scen" time="0.421" /><testcase classname="tests.test_graph.ModelGraphTests" name="test_fault_plot" time="0.241" /><testcase classname="tests.test_graph.ModelGraphTests" name="test_flowgraph_plot" time="0.261" /><testcase classname="tests.test_graph.ModelGraphTests" name="test_fxngraph_plot" time="0.175" /><testcase classname="tests.test_graph.ModelGraphTests" name="test_modelgraph_plot" time="0.219" /><testcase classname="tests.test_graph.ModelGraphTests" name="test_result_from_plot" time="0.204" /><testcase classname="tests.test_graph.ModelGraphTests" name="test_typegraph_plot" time="0.092" /><testcase classname="tests.test_hierarchical.define_Tests" name="test_fault_injection" time="0.004" /><testcase classname="tests.test_hierarchical.define_Tests" name="test_prop_method" time="0.084" /><testcase classname="tests.test_hierarchical.define_Tests" name="test_propagation" time="0.004" /><testcase classname="tests.test_hierarchical.define_Tests" name="test_top_level_injection" time="0.004" /><testcase classname="tests.test_packages.define_Tests" name="test_pdf_translation_options" time="0.005" /></testsuite></testsuites>