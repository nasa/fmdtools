<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="4" failures="104" skipped="3" tests="382" time="910.616" timestamp="2025-09-02T11:04:31.941150-07:00" hostname="bamboo-r3.ndc.nasa.gov"><testcase classname="" name="examples.multirotor.opt_drone_rural" time="0.000"><error message="collection failure">examples/multirotor/opt_drone_rural.py:47: in &lt;module&gt;
    def_mdl = Drone()
              ^^^^^^^
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/multirotor/drone_mdl_rural.py:701: in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/component.py:73: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
fmdtools/define/architecture/base.py:255: in init_flexible_roles
    setattr(self, rname, {**kwargs[role]})
                            ^^^^^^^^^^^^
E   KeyError: 'flow'</error></testcase><testcase classname="" name="examples.rover.optimization.search_rover" time="0.000"><error message="collection failure">fmdtools/analyze/result.py:365: in __getattr__
    return get_dict_attr(obj.data, self.__class__, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/analyze/result.py:96: in get_dict_attr
    sub_dict = dict_in[attr[0]]
               ^^^^^^^^^^^^^^^^
E   KeyError: 'endclass'

During handling of the above exception, another exception occurred:
fmdtools/analyze/result.py:368: in __getattr__
    return self.all_with(argstr)
           ^^^^^^^^^^^^^^^^^^^^^
fmdtools/analyze/result.py:442: in all_with
    raise Exception(attr+" not in Result keys: "+str(self.keys()))
E   Exception: endclass not in Result keys: dict_keys(['nominal.tend.classify.rate', 'nominal.tend.classify.cost', 'nominal.tend.classify.prob', 'nominal.tend.classify.expected_cost', 'nominal.tend.classify.in_bound', 'nominal.tend.classify.at_finish', 'nominal.tend.classify.line_dist', 'nominal.tend.classify.num_modes', 'nominal.tend.classify.end_dist', 'nominal.tend.classify.tot_deviation', 'nominal.tend.classify.faults', 'nominal.tend.classify.classification', 'nominal.tend.classify.end_x', 'nominal.tend.classify.end_y', 'nominal.tend.classify.endpt', 'sequence.tend.classify.rate', 'sequence.tend.classify.cost', 'sequence.tend.classify.prob', 'sequence.tend.classify.expected_cost', 'sequence.tend.classify.in_bound', 'sequence.tend.classify.at_finish', 'sequence.tend.classify.line_dist', 'sequence.tend.classify.num_modes', 'sequence.tend.classify.end_dist', 'sequence.tend.classify.tot_deviation', 'sequence.tend.classify.faults', 'sequence.tend.classify.classification', 'sequence.tend.classify.end_x', 'sequence.tend.classify.end_y', 'sequence.tend.classify.endpt'])

During handling of the above exception, another exception occurred:
examples/rover/optimization/search_rover.py:760: in &lt;module&gt;
    line_dist([0, 0, 0])
examples/rover/optimization/search_rover.py:40: in line_dist
    dist = res.endclass['line_dist']
           ^^^^^^^^^^^^
fmdtools/analyze/result.py:370: in __getattr__
    raise AttributeError("Not in dict: "+str(argstr))
E   AttributeError: Not in dict: endclass</error></testcase><testcase classname="" name="examples.rover.test_rover" time="0.000"><error message="collection failure">fmdtools/analyze/result.py:365: in __getattr__
    return get_dict_attr(obj.data, self.__class__, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/analyze/result.py:96: in get_dict_attr
    sub_dict = dict_in[attr[0]]
               ^^^^^^^^^^^^^^^^
E   KeyError: 'endclass'

During handling of the above exception, another exception occurred:
fmdtools/analyze/result.py:368: in __getattr__
    return self.all_with(argstr)
           ^^^^^^^^^^^^^^^^^^^^^
fmdtools/analyze/result.py:442: in all_with
    raise Exception(attr+" not in Result keys: "+str(self.keys()))
E   Exception: endclass not in Result keys: dict_keys(['nominal.tend.classify.rate', 'nominal.tend.classify.cost', 'nominal.tend.classify.prob', 'nominal.tend.classify.expected_cost', 'nominal.tend.classify.in_bound', 'nominal.tend.classify.at_finish', 'nominal.tend.classify.line_dist', 'nominal.tend.classify.num_modes', 'nominal.tend.classify.end_dist', 'nominal.tend.classify.tot_deviation', 'nominal.tend.classify.faults', 'nominal.tend.classify.classification', 'nominal.tend.classify.end_x', 'nominal.tend.classify.end_y', 'nominal.tend.classify.endpt', 'sequence.tend.classify.rate', 'sequence.tend.classify.cost', 'sequence.tend.classify.prob', 'sequence.tend.classify.expected_cost', 'sequence.tend.classify.in_bound', 'sequence.tend.classify.at_finish', 'sequence.tend.classify.line_dist', 'sequence.tend.classify.num_modes', 'sequence.tend.classify.end_dist', 'sequence.tend.classify.tot_deviation', 'sequence.tend.classify.faults', 'sequence.tend.classify.classification', 'sequence.tend.classify.end_x', 'sequence.tend.classify.end_y', 'sequence.tend.classify.endpt'])

During handling of the above exception, another exception occurred:
examples/rover/test_rover.py:19: in &lt;module&gt;
    from examples.rover.optimization.search_rover import line_dist, line_dist_faster
examples/rover/optimization/search_rover.py:760: in &lt;module&gt;
    line_dist([0, 0, 0])
examples/rover/optimization/search_rover.py:40: in line_dist
    dist = res.endclass['line_dist']
           ^^^^^^^^^^^^
fmdtools/analyze/result.py:370: in __getattr__
    raise AttributeError("Not in dict: "+str(argstr))
E   AttributeError: Not in dict: endclass</error><error message="collection failure">fmdtools/analyze/result.py:365: in __getattr__
    return get_dict_attr(obj.data, self.__class__, *args)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/analyze/result.py:96: in get_dict_attr
    sub_dict = dict_in[attr[0]]
               ^^^^^^^^^^^^^^^^
E   KeyError: 'endclass'

During handling of the above exception, another exception occurred:
fmdtools/analyze/result.py:368: in __getattr__
    return self.all_with(argstr)
           ^^^^^^^^^^^^^^^^^^^^^
fmdtools/analyze/result.py:442: in all_with
    raise Exception(attr+" not in Result keys: "+str(self.keys()))
E   Exception: endclass not in Result keys: dict_keys(['nominal.tend.classify.rate', 'nominal.tend.classify.cost', 'nominal.tend.classify.prob', 'nominal.tend.classify.expected_cost', 'nominal.tend.classify.in_bound', 'nominal.tend.classify.at_finish', 'nominal.tend.classify.line_dist', 'nominal.tend.classify.num_modes', 'nominal.tend.classify.end_dist', 'nominal.tend.classify.tot_deviation', 'nominal.tend.classify.faults', 'nominal.tend.classify.classification', 'nominal.tend.classify.end_x', 'nominal.tend.classify.end_y', 'nominal.tend.classify.endpt', 'sequence.tend.classify.rate', 'sequence.tend.classify.cost', 'sequence.tend.classify.prob', 'sequence.tend.classify.expected_cost', 'sequence.tend.classify.in_bound', 'sequence.tend.classify.at_finish', 'sequence.tend.classify.line_dist', 'sequence.tend.classify.num_modes', 'sequence.tend.classify.end_dist', 'sequence.tend.classify.tot_deviation', 'sequence.tend.classify.faults', 'sequence.tend.classify.classification', 'sequence.tend.classify.end_x', 'sequence.tend.classify.end_y', 'sequence.tend.classify.endpt'])

During handling of the above exception, another exception occurred:
examples/rover/test_rover.py:19: in &lt;module&gt;
    from examples.rover.optimization.search_rover import line_dist, line_dist_faster
examples/rover/optimization/search_rover.py:760: in &lt;module&gt;
    line_dist([0, 0, 0])
examples/rover/optimization/search_rover.py:40: in line_dist
    dist = res.endclass['line_dist']
           ^^^^^^^^^^^^
fmdtools/analyze/result.py:370: in __getattr__
    raise AttributeError("Not in dict: "+str(argstr))
E   AttributeError: Not in dict: endclass</error></testcase><testcase classname="examples.asg_demo.Action_Sequence_Graph.ipynb" name="Action_Sequence_Graph.ipynb" time="9.464"><failure message="#x1B[31mKeyError#x1B[39m: 'flow'">---------------------------------------------------------------------------
ex_fxn = DetectHazard('detect_hazard')
ex_fxn.t.dt=1.0

ex_fxn.aa.flows['hazard']
#x1B[31m---------------------------------------------------------------------------#x1B[39m
#x1B[31mKeyError#x1B[39m                                  Traceback (most recent call last)
#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[15]#x1B[39m#x1B[32m, line 1#x1B[39m
#x1B[32m----&gt; #x1B[39m#x1B[32m1#x1B[39m ex_fxn = #x1B[43mDetectHazard#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mdetect_hazard#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m)#x1B[49m
#x1B[32m      2#x1B[39m ex_fxn.t.dt=#x1B[32m1.0#x1B[39m
#x1B[32m      4#x1B[39m ex_fxn.aa.flows[#x1B[33m'#x1B[39m#x1B[33mhazard#x1B[39m#x1B[33m'#x1B[39m]

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/function.py:90#x1B[39m, in #x1B[36mFunction.__init__#x1B[39m#x1B[34m(self, name, args_f, **kwargs)#x1B[39m
#x1B[32m     81#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34m__init__#x1B[39m(#x1B[38;5;28mself#x1B[39m, name=#x1B[38;5;28;01mNone#x1B[39;00m, args_f=#x1B[38;5;28mdict#x1B[39m(), **kwargs):
#x1B[32m     82#x1B[39m #x1B[38;5;250m    #x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m     83#x1B[39m #x1B[33;03m    Instantiate the function superclass with the relevant parameters.#x1B[39;00m
#x1B[32m     84#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m     88#x1B[39m #x1B[33;03m        arguments to pass to custom __init__ function.#x1B[39;00m
#x1B[32m     89#x1B[39m #x1B[33;03m    """#x1B[39;00m
#x1B[32m---&gt; #x1B[39m#x1B[32m90#x1B[39m     #x1B[38;5;28;43msuper#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__init__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m     91#x1B[39m     #x1B[38;5;28mself#x1B[39m.args_f = args_f
#x1B[32m     92#x1B[39m     #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mbehavior#x1B[39m#x1B[33m'#x1B[39m):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:864#x1B[39m, in #x1B[36mBlock.__init__#x1B[39m#x1B[34m(self, name, flows, h, **kwargs)#x1B[39m
#x1B[32m    862#x1B[39m #x1B[38;5;66;03m# send flows from block level to arch level#x1B[39;00m
#x1B[32m    863#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[33m'#x1B[39m#x1B[33march#x1B[39m#x1B[33m'#x1B[39m #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.roletypes:
#x1B[32m--&gt; #x1B[39m#x1B[32m864#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_roletypes#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43march#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mcreate_arch_kwargs#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    865#x1B[39m #x1B[38;5;28mself#x1B[39m.mut_kwargs = {role: kwargs.get(role)
#x1B[32m    866#x1B[39m                    #x1B[38;5;28;01mfor#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.get_roles(with_flex=#x1B[38;5;28;01mFalse#x1B[39;00m,
#x1B[32m    867#x1B[39m                                               with_immutable=#x1B[38;5;28;01mFalse#x1B[39;00m)
#x1B[32m    868#x1B[39m                    #x1B[38;5;28;01mif#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m kwargs}
#x1B[32m    869#x1B[39m #x1B[38;5;28mself#x1B[39m.check_flows(flows=flows)

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:345#x1B[39m, in #x1B[36mBaseObject.init_roletypes#x1B[39m#x1B[34m(self, initializer, *roletypes, **kwargs)#x1B[39m
#x1B[32m    342#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m roletype #x1B[38;5;129;01mnot#x1B[39;00m #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.roletypes:
#x1B[32m    343#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mRoletype: #x1B[39m#x1B[33m"#x1B[39m + roletype + #x1B[33m"#x1B[39m#x1B[33m not in class variable#x1B[39m#x1B[33m"#x1B[39m +
#x1B[32m    344#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m self.roletypes: #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.roletypes))
#x1B[32m--&gt; #x1B[39m#x1B[32m345#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_roles#x1B[49m#x1B[43m(#x1B[49m#x1B[43mroletype#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43minitializer#x1B[49m#x1B[43m=#x1B[49m#x1B[43minitializer#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:394#x1B[39m, in #x1B[36mBaseObject.init_roles#x1B[39m#x1B[34m(self, roletype, initializer, **kwargs)#x1B[39m
#x1B[32m    392#x1B[39m     obj_args[#x1B[33m'#x1B[39m#x1B[33mtrack#x1B[39m#x1B[33m'#x1B[39m] = get_sub_include(rolename, #x1B[38;5;28mself#x1B[39m.track)
#x1B[32m    393#x1B[39m #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m394#x1B[39m     obj = #x1B[43mobj_initializer#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mobj_args#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    395#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mAttributeError#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m ae:
#x1B[32m    396#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mProblem initializing #x1B[39m#x1B[33m"#x1B[39m + roletype + #x1B[33m"#x1B[39m#x1B[33m_#x1B[39m#x1B[33m"#x1B[39m + rolename
#x1B[32m    397#x1B[39m                     + #x1B[33m"#x1B[39m#x1B[33m: #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(initializer)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01mae#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/action.py:260#x1B[39m, in #x1B[36mActionArchitecture.__init__#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    258#x1B[39m #x1B[38;5;28mself#x1B[39m.flow_graph = nx.DiGraph()
#x1B[32m    259#x1B[39m #x1B[38;5;28mself#x1B[39m.active_actions = #x1B[38;5;28mset#x1B[39m()
#x1B[32m--&gt; #x1B[39m#x1B[32m260#x1B[39m #x1B[43mArchitecture#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__init__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:108#x1B[39m, in #x1B[36mArchitecture.__init__#x1B[39m#x1B[34m(self, as_copy, h, *args, **kwargs)#x1B[39m
#x1B[32m    106#x1B[39m #x1B[38;5;28mself#x1B[39m.init_hist(h=h)
#x1B[32m    107#x1B[39m #x1B[38;5;28mself#x1B[39m._init_flexroles = []
#x1B[32m--&gt; #x1B[39m#x1B[32m108#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_flexible_roles#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    109#x1B[39m #x1B[38;5;28mself#x1B[39m.init_architecture(**kwargs)
#x1B[32m    110#x1B[39m #x1B[38;5;28mself#x1B[39m.build(**kwargs)

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:255#x1B[39m, in #x1B[36mArchitecture.init_flexible_roles#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    253#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mNo role argument #x1B[39m#x1B[33m"#x1B[39m+role+#x1B[33m"#x1B[39m#x1B[33m to copy.#x1B[39m#x1B[33m"#x1B[39m)
#x1B[32m    254#x1B[39m #x1B[38;5;28;01melif#x1B[39;00m rname #x1B[38;5;129;01min#x1B[39;00m kwargs:
#x1B[32m--&gt; #x1B[39m#x1B[32m255#x1B[39m     #x1B[38;5;28msetattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, rname, {**#x1B[43mkwargs#x1B[49m#x1B[43m[#x1B[49m#x1B[43mrole#x1B[49m#x1B[43m]#x1B[49m})
#x1B[32m    256#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m    257#x1B[39m     #x1B[38;5;28msetattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, rname, #x1B[38;5;28mdict#x1B[39m())

#x1B[31mKeyError#x1B[39m: 'flow'</failure></testcase><testcase classname="examples.eps.EPS_Example_Notebook.ipynb" name="EPS_Example_Notebook.ipynb" time="10.562"><failure message="#x1B[31mAttributeError#x1B[39m: Not in dict: graph">---------------------------------------------------------------------------
result.graph.set_edge_labels(title='')
fig, ax = result.graph.draw(figsize=(14,10))
#x1B[31m---------------------------------------------------------------------------#x1B[39m
#x1B[31mKeyError#x1B[39m                                  Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:365#x1B[39m, in #x1B[36mResult.__getattr__#x1B[39m#x1B[34m(self, argstr)#x1B[39m
#x1B[32m    364#x1B[39m         obj = #x1B[38;5;28mself#x1B[39m
#x1B[32m--&gt; #x1B[39m#x1B[32m365#x1B[39m     #x1B[38;5;28;01mreturn#x1B[39;00m #x1B[43mget_dict_attr#x1B[49m#x1B[43m(#x1B[49m#x1B[43mobj#x1B[49m#x1B[43m.#x1B[49m#x1B[43mdata#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[34;43m__class__#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43margs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    366#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mKeyError#x1B[39;00m:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:96#x1B[39m, in #x1B[36mget_dict_attr#x1B[39m#x1B[34m(dict_in, des_class, *attr)#x1B[39m
#x1B[32m     95#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""Get attributes *attr from a given nested dict dict_in of class des_class."""#x1B[39;00m
#x1B[32m---&gt; #x1B[39m#x1B[32m96#x1B[39m sub_dict = #x1B[43mdict_in#x1B[49m#x1B[43m[#x1B[49m#x1B[43mattr#x1B[49m#x1B[43m[#x1B[49m#x1B[32;43m0#x1B[39;49m#x1B[43m]#x1B[49m#x1B[43m]#x1B[49m
#x1B[32m     97#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mlen#x1B[39m(attr) == #x1B[32m1#x1B[39m:

#x1B[31mKeyError#x1B[39m: 'graph'

During handling of the above exception, another exception occurred:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:368#x1B[39m, in #x1B[36mResult.__getattr__#x1B[39m#x1B[34m(self, argstr)#x1B[39m
#x1B[32m    367#x1B[39m #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m368#x1B[39m     #x1B[38;5;28;01mreturn#x1B[39;00m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mall_with#x1B[49m#x1B[43m(#x1B[49m#x1B[43margstr#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    369#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:442#x1B[39m, in #x1B[36mResult.all_with#x1B[39m#x1B[34m(self, attr)#x1B[39m
#x1B[32m    441#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m442#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(attr+#x1B[33m"#x1B[39m#x1B[33m not in Result keys: #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.keys()))

#x1B[31mException#x1B[39m: graph not in Result keys: dict_keys(['nominal.tend.classify.rate', 'nominal.tend.classify.cost', 'nominal.tend.classify.expected_cost', 'ee_to_me_toohigh_torque_t0.tend.classify.rate', 'ee_to_me_toohigh_torque_t0.tend.classify.cost', 'ee_to_me_toohigh_torque_t0.tend.classify.expected_cost'])

During handling of the above exception, another exception occurred:

#x1B[31mAttributeError#x1B[39m                            Traceback (most recent call last)
#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[5]#x1B[39m#x1B[32m, line 1#x1B[39m
#x1B[32m----&gt; #x1B[39m#x1B[32m1#x1B[39m #x1B[43mresult#x1B[49m#x1B[43m.#x1B[49m#x1B[43mgraph#x1B[49m.set_edge_labels(title=#x1B[33m'#x1B[39m#x1B[33m'#x1B[39m)
#x1B[32m      2#x1B[39m fig, ax = result.graph.draw(figsize=(#x1B[32m14#x1B[39m,#x1B[32m10#x1B[39m))

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:370#x1B[39m, in #x1B[36mResult.__getattr__#x1B[39m#x1B[34m(self, argstr)#x1B[39m
#x1B[32m    368#x1B[39m     #x1B[38;5;28;01mreturn#x1B[39;00m #x1B[38;5;28mself#x1B[39m.all_with(argstr)
#x1B[32m    369#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m370#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mAttributeError#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mNot in dict: #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(argstr))

#x1B[31mAttributeError#x1B[39m: Not in dict: graph</failure></testcase><testcase classname="examples.eps.test_eps.epsTests" name="test_all_faults" time="3.279" /><testcase classname="examples.eps.test_eps.epsTests" name="test_backward_fault_prop_1" time="0.198" /><testcase classname="examples.eps.test_eps.epsTests" name="test_backward_fault_prop_2" time="0.199" /><testcase classname="examples.eps.test_eps.epsTests" name="test_fault_app" time="4.162" /><testcase classname="examples.eps.test_eps.epsTests" name="test_multfault_saving" time="0.817" /><testcase classname="examples.eps.test_eps.epsTests" name="test_nominal_saving" time="0.215" /><testcase classname="examples.eps.test_eps.epsTests" name="test_pickleability" time="6.919" /><testcase classname="examples.eps.test_eps.epsTests" name="test_save_load_onefault" time="0.682" /><testcase classname="examples.eps.test_eps.epsTests" name="test_save_load_singlefaults" time="11.373" /><testcase classname="examples.multiflow_demo.Multiflow_and_Commsflow_Demonstration.ipynb" name="Multiflow_and_Commsflow_Demonstration.ipynb" time="7.949" /><testcase classname="examples.multiflow_demo.test_multiflow.define_Tests" name="test_multiflow_combination" time="0.677" /><testcase classname="examples.multiflow_demo.test_multiflow.define_Tests" name="test_multiflow_passing" time="0.577" /><testcase classname="examples.multiflow_demo.test_multiflow.define_Tests" name="test_mutliflow_copying" time="0.537" /><testcase classname="examples.multirotor.Demonstration.ipynb" name="Demonstration.ipynb" time="17.703"><failure message="#x1B[31mAttributeError#x1B[39m: Not in dict: graph">---------------------------------------------------------------------------
static_mdl = Drone_Static()
result, mdlhist = propagate.one_fault(static_mdl,'affect_dof', 'mechbreak', t=0, to_return='graph')

result.graph.set_edge_labels(title='')
fig, ax = result.graph.draw(title = 'AffectDOF: Mechbreak at final sim time')
#fig.savefig('static_propagation.pdf', format="pdf", bbox_inches = 'tight', pad_inches = 0)
#x1B[31m---------------------------------------------------------------------------#x1B[39m
#x1B[31mKeyError#x1B[39m                                  Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:365#x1B[39m, in #x1B[36mResult.__getattr__#x1B[39m#x1B[34m(self, argstr)#x1B[39m
#x1B[32m    364#x1B[39m         obj = #x1B[38;5;28mself#x1B[39m
#x1B[32m--&gt; #x1B[39m#x1B[32m365#x1B[39m     #x1B[38;5;28;01mreturn#x1B[39;00m #x1B[43mget_dict_attr#x1B[49m#x1B[43m(#x1B[49m#x1B[43mobj#x1B[49m#x1B[43m.#x1B[49m#x1B[43mdata#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[34;43m__class__#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43margs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    366#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mKeyError#x1B[39;00m:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:96#x1B[39m, in #x1B[36mget_dict_attr#x1B[39m#x1B[34m(dict_in, des_class, *attr)#x1B[39m
#x1B[32m     95#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""Get attributes *attr from a given nested dict dict_in of class des_class."""#x1B[39;00m
#x1B[32m---&gt; #x1B[39m#x1B[32m96#x1B[39m sub_dict = #x1B[43mdict_in#x1B[49m#x1B[43m[#x1B[49m#x1B[43mattr#x1B[49m#x1B[43m[#x1B[49m#x1B[32;43m0#x1B[39;49m#x1B[43m]#x1B[49m#x1B[43m]#x1B[49m
#x1B[32m     97#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mlen#x1B[39m(attr) == #x1B[32m1#x1B[39m:

#x1B[31mKeyError#x1B[39m: 'graph'

During handling of the above exception, another exception occurred:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:368#x1B[39m, in #x1B[36mResult.__getattr__#x1B[39m#x1B[34m(self, argstr)#x1B[39m
#x1B[32m    367#x1B[39m #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m368#x1B[39m     #x1B[38;5;28;01mreturn#x1B[39;00m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mall_with#x1B[49m#x1B[43m(#x1B[49m#x1B[43margstr#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    369#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:442#x1B[39m, in #x1B[36mResult.all_with#x1B[39m#x1B[34m(self, attr)#x1B[39m
#x1B[32m    441#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m442#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(attr+#x1B[33m"#x1B[39m#x1B[33m not in Result keys: #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.keys()))

#x1B[31mException#x1B[39m: graph not in Result keys: dict_keys(['nominal.tend.classify.rate', 'nominal.tend.classify.cost', 'nominal.tend.classify.expected_cost', 'affect_dof_mechbreak_t0.tend.classify.rate', 'affect_dof_mechbreak_t0.tend.classify.cost', 'affect_dof_mechbreak_t0.tend.classify.expected_cost'])

During handling of the above exception, another exception occurred:

#x1B[31mAttributeError#x1B[39m                            Traceback (most recent call last)
#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[24]#x1B[39m#x1B[32m, line 4#x1B[39m
#x1B[32m      1#x1B[39m static_mdl = Drone_Static()
#x1B[32m      2#x1B[39m result, mdlhist = propagate.one_fault(static_mdl,#x1B[33m'#x1B[39m#x1B[33maffect_dof#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mmechbreak#x1B[39m#x1B[33m'#x1B[39m, t=#x1B[32m0#x1B[39m, to_return=#x1B[33m'#x1B[39m#x1B[33mgraph#x1B[39m#x1B[33m'#x1B[39m)
#x1B[32m----&gt; #x1B[39m#x1B[32m4#x1B[39m #x1B[43mresult#x1B[49m#x1B[43m.#x1B[49m#x1B[43mgraph#x1B[49m.set_edge_labels(title=#x1B[33m'#x1B[39m#x1B[33m'#x1B[39m)
#x1B[32m      5#x1B[39m fig, ax = result.graph.draw(title = #x1B[33m'#x1B[39m#x1B[33mAffectDOF: Mechbreak at final sim time#x1B[39m#x1B[33m'#x1B[39m)
#x1B[32m      6#x1B[39m #x1B[38;5;66;03m#fig.savefig('static_propagation.pdf', format="pdf", bbox_inches = 'tight', pad_inches = 0)#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:370#x1B[39m, in #x1B[36mResult.__getattr__#x1B[39m#x1B[34m(self, argstr)#x1B[39m
#x1B[32m    368#x1B[39m     #x1B[38;5;28;01mreturn#x1B[39;00m #x1B[38;5;28mself#x1B[39m.all_with(argstr)
#x1B[32m    369#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m370#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mAttributeError#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mNot in dict: #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(argstr))

#x1B[31mAttributeError#x1B[39m: Not in dict: graph</failure></testcase><testcase classname="examples.multirotor.Multirotor_Optimization.ipynb" name="Multirotor_Optimization.ipynb" time="8.194"><failure message="#x1B[31mKeyError#x1B[39m: 'flow'">---------------------------------------------------------------------------
from drone_mdl_rural import Drone
import numpy as np

mdl = Drone()
#x1B[31m---------------------------------------------------------------------------#x1B[39m
#x1B[31mKeyError#x1B[39m                                  Traceback (most recent call last)
#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[1]#x1B[39m#x1B[32m, line 4#x1B[39m
#x1B[32m      1#x1B[39m #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01mdrone_mdl_rural#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[38;5;28;01mimport#x1B[39;00m Drone
#x1B[32m      2#x1B[39m #x1B[38;5;28;01mimport#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01mnumpy#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[38;5;28;01mas#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01mnp#x1B[39;00m
#x1B[32m----&gt; #x1B[39m#x1B[32m4#x1B[39m mdl = #x1B[43mDrone#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:109#x1B[39m, in #x1B[36mArchitecture.__init__#x1B[39m#x1B[34m(self, as_copy, h, *args, **kwargs)#x1B[39m
#x1B[32m    107#x1B[39m #x1B[38;5;28mself#x1B[39m._init_flexroles = []
#x1B[32m    108#x1B[39m #x1B[38;5;28mself#x1B[39m.init_flexible_roles(**kwargs)
#x1B[32m--&gt; #x1B[39m#x1B[32m109#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_architecture#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    110#x1B[39m #x1B[38;5;28mself#x1B[39m.build(**kwargs)
#x1B[32m    111#x1B[39m #x1B[38;5;28mself#x1B[39m.mut_kwargs = {role: kwargs.get(role)
#x1B[32m    112#x1B[39m                    #x1B[38;5;28;01mfor#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.get_roles(#x1B[33m'#x1B[39m#x1B[33mcontainer#x1B[39m#x1B[33m'#x1B[39m, with_immutable=#x1B[38;5;28;01mFalse#x1B[39;00m)
#x1B[32m    113#x1B[39m                    #x1B[38;5;28;01mif#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m kwargs}

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py:701#x1B[39m, in #x1B[36mDrone.init_architecture#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    696#x1B[39m #x1B[38;5;28mself#x1B[39m.add_fxn(#x1B[33m'#x1B[39m#x1B[33mmanage_health#x1B[39m#x1B[33m'#x1B[39m, ManageHealth, *flows, p=#x1B[38;5;28mself#x1B[39m.p.respolicy.asdict())
#x1B[32m    698#x1B[39m store_ee_p = {#x1B[33m'#x1B[39m#x1B[33marchtype#x1B[39m#x1B[33m'#x1B[39m: #x1B[38;5;28mself#x1B[39m.p.phys_param.bat,
#x1B[32m    699#x1B[39m               #x1B[33m'#x1B[39m#x1B[33mweight#x1B[39m#x1B[33m'#x1B[39m: #x1B[38;5;28mself#x1B[39m.p.phys_param.batweight+#x1B[38;5;28mself#x1B[39m.p.phys_param.archweight,
#x1B[32m    700#x1B[39m               #x1B[33m'#x1B[39m#x1B[33mdrag#x1B[39m#x1B[33m'#x1B[39m: #x1B[38;5;28mself#x1B[39m.p.phys_param.archdrag}
#x1B[32m--&gt; #x1B[39m#x1B[32m701#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43madd_fxn#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mstore_ee#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mStoreEE#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mee_1#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mforce_st#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mhsig_bat#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m
#x1B[32m    702#x1B[39m #x1B[43m             #x1B[49m#x1B[43mca#x1B[49m#x1B[43m=#x1B[49m#x1B[43m{#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mp#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m:#x1B[49m#x1B[43m #x1B[49m#x1B[43mstore_ee_p#x1B[49m#x1B[43m}#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    703#x1B[39m #x1B[38;5;28mself#x1B[39m.add_fxn(#x1B[33m'#x1B[39m#x1B[33mdist_ee#x1B[39m#x1B[33m'#x1B[39m, DistEE, #x1B[33m'#x1B[39m#x1B[33mee_1#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mee_mot#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mee_ctl#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mforce_st#x1B[39m#x1B[33m'#x1B[39m)
#x1B[32m    704#x1B[39m #x1B[38;5;28mself#x1B[39m.add_fxn(#x1B[33m'#x1B[39m#x1B[33maffect_dof#x1B[39m#x1B[33m'#x1B[39m, AffectDOF, #x1B[33m'#x1B[39m#x1B[33mee_mot#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mctl#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mdofs#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mdes_traj#x1B[39m#x1B[33m'#x1B[39m,
#x1B[32m    705#x1B[39m              #x1B[33m'#x1B[39m#x1B[33mforce_lin#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mhsig_dofs#x1B[39m#x1B[33m'#x1B[39m,
#x1B[32m    706#x1B[39m              ca={#x1B[33m'#x1B[39m#x1B[33mp#x1B[39m#x1B[33m'#x1B[39m: {#x1B[33m'#x1B[39m#x1B[33marchtype#x1B[39m#x1B[33m'#x1B[39m: #x1B[38;5;28mself#x1B[39m.p.phys_param.linearch}})

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/function.py:508#x1B[39m, in #x1B[36mFunctionArchitecture.add_fxn#x1B[39m#x1B[34m(self, name, fclass, *flownames, **fkwargs)#x1B[39m
#x1B[32m    490#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34madd_fxn#x1B[39m(#x1B[38;5;28mself#x1B[39m, name, fclass, *flownames, **fkwargs):
#x1B[32m    491#x1B[39m #x1B[38;5;250m    #x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m    492#x1B[39m #x1B[33;03m    Instantiate a given function in the model.#x1B[39;00m
#x1B[32m    493#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m    506#x1B[39m #x1B[33;03m        Parameters to send to __init__ method of the Function superclass#x1B[39;00m
#x1B[32m    507#x1B[39m #x1B[33;03m    """#x1B[39;00m
#x1B[32m--&gt; #x1B[39m#x1B[32m508#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43madd_sim#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mfxns#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mfclass#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43mflownames#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mfkwargs#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:393#x1B[39m, in #x1B[36mArchitecture.add_sim#x1B[39m#x1B[34m(self, flex_role, name, simclass, *flownames, **kwargs)#x1B[39m
#x1B[32m    376#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m    377#x1B[39m #x1B[33;03mAdd a Simulable to the given flex_role.#x1B[39;00m
#x1B[32m    378#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m    390#x1B[39m #x1B[33;03m    Flows, dicts for non-default values to p, s, etc.#x1B[39;00m
#x1B[32m    391#x1B[39m #x1B[33;03m"""#x1B[39;00m
#x1B[32m    392#x1B[39m flows = #x1B[38;5;28mself#x1B[39m.get_flows(*flownames, all_if_empty=#x1B[38;5;28;01mFalse#x1B[39;00m)
#x1B[32m--&gt; #x1B[39m#x1B[32m393#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43madd_flex_role_obj#x1B[49m#x1B[43m(#x1B[49m#x1B[43mflex_role#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    394#x1B[39m #x1B[43m                       #x1B[49m#x1B[43mobjclass#x1B[49m#x1B[43m=#x1B[49m#x1B[43msimclass#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mflows#x1B[49m#x1B[43m=#x1B[49m#x1B[43mflows#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    395#x1B[39m #x1B[38;5;28;01mfor#x1B[39;00m flowname #x1B[38;5;129;01min#x1B[39;00m flownames:
#x1B[32m    396#x1B[39m     #x1B[38;5;28mself#x1B[39m._simflows.append((name, flowname))

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:319#x1B[39m, in #x1B[36mArchitecture.add_flex_role_obj#x1B[39m#x1B[34m(self, flex_role, name, objclass, use_copy, **kwargs)#x1B[39m
#x1B[32m    317#x1B[39m track = get_sub_include(name, get_sub_include(flex_role, #x1B[38;5;28mself#x1B[39m.track))
#x1B[32m    318#x1B[39m kwargs = #x1B[38;5;28mself#x1B[39m.get_flex_role_kwargs(objclass, **kwargs)
#x1B[32m--&gt; #x1B[39m#x1B[32m319#x1B[39m obj = #x1B[43minit_obj#x1B[49m#x1B[43m(#x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mobjclass#x1B[49m#x1B[43m=#x1B[49m#x1B[43mobjclass#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m=#x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    320#x1B[39m #x1B[43m               #x1B[49m#x1B[43mas_copy#x1B[49m#x1B[43m=#x1B[49m#x1B[43mas_copy#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mroot#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mget_full_name#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m+#x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43m.#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m+#x1B[49m#x1B[43mflex_role#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    321#x1B[39m #x1B[43m               #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    323#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(obj, #x1B[33m'#x1B[39m#x1B[33mh#x1B[39m#x1B[33m'#x1B[39m) #x1B[38;5;129;01mand#x1B[39;00m obj.h:
#x1B[32m    324#x1B[39m     hist = obj.h

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:1183#x1B[39m, in #x1B[36minit_obj#x1B[39m#x1B[34m(name, objclass, track, as_copy, **kwargs)#x1B[39m
#x1B[32m   1181#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m   1182#x1B[39m     #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m-&gt; #x1B[39m#x1B[32m1183#x1B[39m         fl = #x1B[43mobjclass#x1B[49m#x1B[43m(#x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m=#x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m   1184#x1B[39m     #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mTypeError#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m   1185#x1B[39m         #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mTypeError#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mPoorly specified class #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(objclass) +
#x1B[32m   1186#x1B[39m                         #x1B[33m"#x1B[39m#x1B[33m (or poor arguments) #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(kwargs)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/function.py:90#x1B[39m, in #x1B[36mFunction.__init__#x1B[39m#x1B[34m(self, name, args_f, **kwargs)#x1B[39m
#x1B[32m     81#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34m__init__#x1B[39m(#x1B[38;5;28mself#x1B[39m, name=#x1B[38;5;28;01mNone#x1B[39;00m, args_f=#x1B[38;5;28mdict#x1B[39m(), **kwargs):
#x1B[32m     82#x1B[39m #x1B[38;5;250m    #x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m     83#x1B[39m #x1B[33;03m    Instantiate the function superclass with the relevant parameters.#x1B[39;00m
#x1B[32m     84#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m     88#x1B[39m #x1B[33;03m        arguments to pass to custom __init__ function.#x1B[39;00m
#x1B[32m     89#x1B[39m #x1B[33;03m    """#x1B[39;00m
#x1B[32m---&gt; #x1B[39m#x1B[32m90#x1B[39m     #x1B[38;5;28;43msuper#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__init__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m     91#x1B[39m     #x1B[38;5;28mself#x1B[39m.args_f = args_f
#x1B[32m     92#x1B[39m     #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mbehavior#x1B[39m#x1B[33m'#x1B[39m):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:864#x1B[39m, in #x1B[36mBlock.__init__#x1B[39m#x1B[34m(self, name, flows, h, **kwargs)#x1B[39m
#x1B[32m    862#x1B[39m #x1B[38;5;66;03m# send flows from block level to arch level#x1B[39;00m
#x1B[32m    863#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[33m'#x1B[39m#x1B[33march#x1B[39m#x1B[33m'#x1B[39m #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.roletypes:
#x1B[32m--&gt; #x1B[39m#x1B[32m864#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_roletypes#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43march#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mcreate_arch_kwargs#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    865#x1B[39m #x1B[38;5;28mself#x1B[39m.mut_kwargs = {role: kwargs.get(role)
#x1B[32m    866#x1B[39m                    #x1B[38;5;28;01mfor#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.get_roles(with_flex=#x1B[38;5;28;01mFalse#x1B[39;00m,
#x1B[32m    867#x1B[39m                                               with_immutable=#x1B[38;5;28;01mFalse#x1B[39;00m)
#x1B[32m    868#x1B[39m                    #x1B[38;5;28;01mif#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m kwargs}
#x1B[32m    869#x1B[39m #x1B[38;5;28mself#x1B[39m.check_flows(flows=flows)

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:345#x1B[39m, in #x1B[36mBaseObject.init_roletypes#x1B[39m#x1B[34m(self, initializer, *roletypes, **kwargs)#x1B[39m
#x1B[32m    342#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m roletype #x1B[38;5;129;01mnot#x1B[39;00m #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.roletypes:
#x1B[32m    343#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mRoletype: #x1B[39m#x1B[33m"#x1B[39m + roletype + #x1B[33m"#x1B[39m#x1B[33m not in class variable#x1B[39m#x1B[33m"#x1B[39m +
#x1B[32m    344#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m self.roletypes: #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.roletypes))
#x1B[32m--&gt; #x1B[39m#x1B[32m345#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_roles#x1B[49m#x1B[43m(#x1B[49m#x1B[43mroletype#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43minitializer#x1B[49m#x1B[43m=#x1B[49m#x1B[43minitializer#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:394#x1B[39m, in #x1B[36mBaseObject.init_roles#x1B[39m#x1B[34m(self, roletype, initializer, **kwargs)#x1B[39m
#x1B[32m    392#x1B[39m     obj_args[#x1B[33m'#x1B[39m#x1B[33mtrack#x1B[39m#x1B[33m'#x1B[39m] = get_sub_include(rolename, #x1B[38;5;28mself#x1B[39m.track)
#x1B[32m    393#x1B[39m #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m394#x1B[39m     obj = #x1B[43mobj_initializer#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mobj_args#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    395#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mAttributeError#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m ae:
#x1B[32m    396#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mProblem initializing #x1B[39m#x1B[33m"#x1B[39m + roletype + #x1B[33m"#x1B[39m#x1B[33m_#x1B[39m#x1B[33m"#x1B[39m + rolename
#x1B[32m    397#x1B[39m                     + #x1B[33m"#x1B[39m#x1B[33m: #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(initializer)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01mae#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/component.py:73#x1B[39m, in #x1B[36mComponentArchitecture.__init__#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m     72#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34m__init__#x1B[39m(#x1B[38;5;28mself#x1B[39m, **kwargs):
#x1B[32m---&gt; #x1B[39m#x1B[32m73#x1B[39m     #x1B[43mArchitecture#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__init__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:108#x1B[39m, in #x1B[36mArchitecture.__init__#x1B[39m#x1B[34m(self, as_copy, h, *args, **kwargs)#x1B[39m
#x1B[32m    106#x1B[39m #x1B[38;5;28mself#x1B[39m.init_hist(h=h)
#x1B[32m    107#x1B[39m #x1B[38;5;28mself#x1B[39m._init_flexroles = []
#x1B[32m--&gt; #x1B[39m#x1B[32m108#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_flexible_roles#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    109#x1B[39m #x1B[38;5;28mself#x1B[39m.init_architecture(**kwargs)
#x1B[32m    110#x1B[39m #x1B[38;5;28mself#x1B[39m.build(**kwargs)

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:255#x1B[39m, in #x1B[36mArchitecture.init_flexible_roles#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    253#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mNo role argument #x1B[39m#x1B[33m"#x1B[39m+role+#x1B[33m"#x1B[39m#x1B[33m to copy.#x1B[39m#x1B[33m"#x1B[39m)
#x1B[32m    254#x1B[39m #x1B[38;5;28;01melif#x1B[39;00m rname #x1B[38;5;129;01min#x1B[39;00m kwargs:
#x1B[32m--&gt; #x1B[39m#x1B[32m255#x1B[39m     #x1B[38;5;28msetattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, rname, {**#x1B[43mkwargs#x1B[49m#x1B[43m[#x1B[49m#x1B[43mrole#x1B[49m#x1B[43m]#x1B[49m})
#x1B[32m    256#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m    257#x1B[39m     #x1B[38;5;28msetattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, rname, #x1B[38;5;28mdict#x1B[39m())

#x1B[31mKeyError#x1B[39m: 'flow'</failure></testcase><testcase classname="examples.multirotor.drone_mdl_dynamic" name="examples.multirotor.drone_mdl_dynamic.AffectDOF.inc_pos" time="0.012" /><testcase classname="examples.multirotor.drone_mdl_dynamic" name="examples.multirotor.drone_mdl_dynamic.PlanPath.assign_vectdist_to_goal" time="0.009" /><testcase classname="examples.multirotor.drone_mdl_dynamic" name="examples.multirotor.drone_mdl_dynamic.PlanPath.calc_dist_to_goal" time="0.007" /><testcase classname="examples.multirotor.drone_mdl_dynamic" name="examples.multirotor.drone_mdl_dynamic.SightGrid" time="0.676" /><testcase classname="examples.multirotor.drone_mdl_hierarchical" name="examples.multirotor.drone_mdl_hierarchical.AffectDOF.calc_pwr" time="0.010"><failure message="188 &#10;189         Calculates overall power and stability based on individual rotor output.&#10;190 &#10;191         e.g., ::&#10;192         &gt;&gt;&gt; a = AffectDOF()&#10;UNEXPECTED EXCEPTION: KeyError('flow')&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py&quot;, line 1355, in __run&#10;    exec(compile(example.source, filename, &quot;single&quot;,&#10;  File &quot;&lt;doctest examples.multirotor.drone_mdl_hierarchical.AffectDOF.calc_pwr[0]&gt;&quot;, line 1, in &lt;module&gt;&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py&quot;, line 90, in __init__&#10;    super().__init__(name=name, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py&quot;, line 864, in __init__&#10;    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 345, in init_roletypes&#10;    self.init_roles(roletype, initializer=initializer, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 394, in init_roles&#10;    obj = obj_initializer(**obj_args)&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py&quot;, line 73, in __init__&#10;    Architecture.__init__(self, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 108, in __init__&#10;    self.init_flexible_roles(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 255, in init_flexible_roles&#10;    setattr(self, rname, {**kwargs[role]})&#10;                            ~~~~~~^^^^^^&#10;KeyError: 'flow'&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_hierarchical.py:192: UnexpectedException">188 
189         Calculates overall power and stability based on individual rotor output.
190 
191         e.g., ::
192         &gt;&gt;&gt; a = AffectDOF()
UNEXPECTED EXCEPTION: KeyError('flow')
Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py", line 1355, in __run
    exec(compile(example.source, filename, "single",
  File "&lt;doctest examples.multirotor.drone_mdl_hierarchical.AffectDOF.calc_pwr[0]&gt;", line 1, in &lt;module&gt;
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py", line 90, in __init__
    super().__init__(name=name, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 864, in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 345, in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 394, in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py", line 73, in __init__
    Architecture.__init__(self, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 108, in __init__
    self.init_flexible_roles(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 255, in init_flexible_roles
    setattr(self, rname, {**kwargs[role]})
                            ~~~~~~^^^^^^
KeyError: 'flow'
/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_hierarchical.py:192: UnexpectedException</failure></testcase><testcase classname="examples.multirotor.drone_mdl_hierarchical" name="examples.multirotor.drone_mdl_hierarchical.LineArchParam" time="0.004" /><testcase classname="examples.multirotor.drone_mdl_static" name="examples.multirotor.drone_mdl_static.AffectDOF.static_behavior" time="0.006" /><testcase classname="examples.multirotor.drone_mdl_static" name="examples.multirotor.drone_mdl_static.CtlDOF.static_behavior" time="0.006" /><testcase classname="examples.multirotor.drone_mdl_static" name="examples.multirotor.drone_mdl_static.DesTrajState.dist2d" time="0.002" /><testcase classname="examples.multirotor.drone_mdl_static" name="examples.multirotor.drone_mdl_static.DesTrajState.unit_vect2d" time="0.003" /><testcase classname="examples.multirotor.drone_mdl_static" name="examples.multirotor.drone_mdl_static.DistEE.static_behavior" time="0.008" /><testcase classname="examples.multirotor.drone_mdl_static" name="examples.multirotor.drone_mdl_static.HoldPayload.static_behavior" time="0.006" /><testcase classname="examples.multirotor.drone_mdl_static" name="examples.multirotor.drone_mdl_static.PlanPath.static_behavior" time="0.005" /><testcase classname="examples.multirotor.test_multirotor.DroneParameterTests" name="test_objectives" time="0.017"><failure message="KeyError: 'flow'">self = &lt;examples.multirotor.test_multirotor.DroneParameterTests testMethod=test_objectives&gt;

    def test_objectives(self):
        """Test that increasing architecture weight decreases soc objective."""
&gt;       ex_soc_opt = ExSOCProb()
                     ^^^^^^^^^^^

examples/multirotor/test_multirotor.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/search.py:185: in __init__
    self.init_problem(**kwargs)
examples/multirotor/test_multirotor.py:49: in init_problem
    self.add_sim(Drone(track=None), 'nominal')
                 ^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/multirotor/drone_mdl_rural.py:701: in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/component.py:73: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'BatArch' object has no attribute 'flows'") raised in repr()] BatArch object at 0x55d843c35480&gt;
kwargs = {'flows': {'ee_1': ee_1 EE
- s=EEState(rate=1.0, effort=1.0), 'force_st': force_st Force
- s=ForceState(support=1.0), ...nal')}, 'name': 'ca', 'p': {'archtype': 'monolithic', 'drag': 0.95, 'weight': 1.6}, 'root': 'drone.fxns.store_ee', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.multirotor.test_multirotor.DroneParameterTests" name="test_param_domain_1" time="0.002" /><testcase classname="examples.multirotor.test_multirotor.DroneParameterTests" name="test_param_domain_2" time="0.002" /><testcase classname="examples.multirotor.test_multirotor.DroneParameterTests" name="test_set_constraints_1" time="0.001" /><testcase classname="examples.multirotor.test_multirotor.DroneParameterTests" name="test_set_constraints_2" time="0.001" /><testcase classname="examples.multirotor.test_multirotor.DroneParameterTests" name="test_sim_mdl" time="0.025"><failure message="KeyError: 'flow'">self = &lt;examples.multirotor.test_multirotor.DroneParameterTests testMethod=test_sim_mdl&gt;

    def test_sim_mdl(self):
        """Test that Problem tracking options are used (only needed hist/res gotten)."""
&gt;       ex_soc_opt = ExSOCProb()
                     ^^^^^^^^^^^

examples/multirotor/test_multirotor.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/search.py:185: in __init__
    self.init_problem(**kwargs)
examples/multirotor/test_multirotor.py:49: in init_problem
    self.add_sim(Drone(track=None), 'nominal')
                 ^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/multirotor/drone_mdl_rural.py:701: in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/component.py:73: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'BatArch' object has no attribute 'flows'") raised in repr()] BatArch object at 0x55d84361b780&gt;
kwargs = {'flows': {'ee_1': ee_1 EE
- s=EEState(rate=1.0, effort=1.0), 'force_st': force_st Force
- s=ForceState(support=1.0), ...nal')}, 'name': 'ca', 'p': {'archtype': 'monolithic', 'drag': 0.95, 'weight': 1.6}, 'root': 'drone.fxns.store_ee', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.multirotor.test_multirotor.DroneScenarioTest" name="test_scenprob_results" time="0.030"><failure message="KeyError: 'flow'">self = &lt;examples.multirotor.test_multirotor.DroneScenarioTest testMethod=test_scenprob_results&gt;

    def setUp(self):
&gt;       res, self.hist = propagate.nominal(Drone())
                                           ^^^^^^^

examples/multirotor/test_multirotor.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/multirotor/drone_mdl_rural.py:701: in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/component.py:73: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'BatArch' object has no attribute 'flows'") raised in repr()] BatArch object at 0x55d8435f5400&gt;
kwargs = {'flows': {'ee_1': ee_1 EE
- s=EEState(rate=1.0, effort=1.0), 'force_st': force_st Force
- s=ForceState(support=1.0), ...nal')}, 'name': 'ca', 'p': {'archtype': 'monolithic', 'drag': 0.95, 'weight': 1.6}, 'root': 'drone.fxns.store_ee', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.multirotor.test_multirotor.DroneScenarioTest2" name="test_scenprob_results" time="0.030"><failure message="KeyError: 'flow'">self = &lt;examples.multirotor.test_multirotor.DroneScenarioTest2 testMethod=test_scenprob_results&gt;

    def setUp(self):
&gt;       res, self.hist = propagate.nominal(Drone())
                                           ^^^^^^^

examples/multirotor/test_multirotor.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/multirotor/drone_mdl_rural.py:701: in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/component.py:73: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'BatArch' object has no attribute 'flows'") raised in repr()] BatArch object at 0x55d8439a2ad0&gt;
kwargs = {'flows': {'ee_1': ee_1 EE
- s=EEState(rate=1.0, effort=1.0), 'force_st': force_st Force
- s=ForceState(support=1.0), ...nal')}, 'name': 'ca', 'p': {'archtype': 'monolithic', 'drag': 0.95, 'weight': 1.6}, 'root': 'drone.fxns.store_ee', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.multirotor.test_multirotor.DroneScenarioTest3" name="test_scenprob_results" time="0.025"><failure message="KeyError: 'flow'">self = &lt;examples.multirotor.test_multirotor.DroneScenarioTest3 testMethod=test_scenprob_results&gt;

    def setUp(self):
&gt;       res, self.hist = propagate.nominal(Drone())
                                           ^^^^^^^

examples/multirotor/test_multirotor.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/multirotor/drone_mdl_rural.py:701: in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/component.py:73: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'BatArch' object has no attribute 'flows'") raised in repr()] BatArch object at 0x55d843bb40f0&gt;
kwargs = {'flows': {'ee_1': ee_1 EE
- s=EEState(rate=1.0, effort=1.0), 'force_st': force_st Force
- s=ForceState(support=1.0), ...nal')}, 'name': 'ca', 'p': {'archtype': 'monolithic', 'drag': 0.95, 'weight': 1.6}, 'root': 'drone.fxns.store_ee', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.multirotor.test_multirotor.DroneDisturbanceTest" name="test_disturbance_set" time="0.022"><failure message="KeyError: 'flow'">self = &lt;examples.multirotor.test_multirotor.DroneDisturbanceTest testMethod=test_disturbance_set&gt;

    def setUp(self):
&gt;       self.edp = ExDistProblem()
                   ^^^^^^^^^^^^^^^

examples/multirotor/test_multirotor.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/search.py:910: in __init__
    super().__init__(**kwargs)
fmdtools/sim/search.py:185: in __init__
    self.init_problem(**kwargs)
examples/multirotor/test_multirotor.py:136: in init_problem
    self.add_sim(Drone(track=None), 5.0, "store_ee.ca.comps.s1p1.s.soc")
                 ^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/multirotor/drone_mdl_rural.py:701: in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/component.py:73: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'BatArch' object has no attribute 'flows'") raised in repr()] BatArch object at 0x55d843bb89a0&gt;
kwargs = {'flows': {'ee_1': ee_1 EE
- s=EEState(rate=1.0, effort=1.0), 'force_st': force_st Force
- s=ForceState(support=1.0), ...nal')}, 'name': 'ca', 'p': {'archtype': 'monolithic', 'drag': 0.95, 'weight': 1.6}, 'root': 'drone.fxns.store_ee', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.pump.Optimization.ipynb" name="Optimization.ipynb" time="8.441"><failure message="#x1B[31mException#x1B[39m: Error simulating nominal scenario(s)">---------------------------------------------------------------------------
new_problem.f1(1)
new_problem.f1(0.5)
new_problem.f1(1.5)
new_problem.f1(2)
new_problem.f1(0.3)
#x1B[31m---------------------------------------------------------------------------#x1B[39m
#x1B[31mNameError#x1B[39m                                 Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:796#x1B[39m, in #x1B[36mSimulable.__call__#x1B[39m#x1B[34m(self, time, proptype, faults, disturbances, inc_at, end_of_simulation, copy)#x1B[39m
#x1B[32m    795#x1B[39m #x1B[38;5;28mself#x1B[39m.update_dynamic_behaviors(proptype=proptype)
#x1B[32m--&gt; #x1B[39m#x1B[32m796#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mupdate_static_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m=#x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    797#x1B[39m #x1B[38;5;28mself#x1B[39m.set_sub_faults()

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:728#x1B[39m, in #x1B[36mSimulable.update_static_behaviors#x1B[39m#x1B[34m(self, proptype)#x1B[39m
#x1B[32m    727#x1B[39m #x1B[38;5;28;01melif#x1B[39;00m proptype #x1B[38;5;129;01min#x1B[39;00m [#x1B[33m'#x1B[39m#x1B[33mstatic-once#x1B[39m#x1B[33m'#x1B[39m]:
#x1B[32m--&gt; #x1B[39m#x1B[32m728#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mexecute_static_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:734#x1B[39m, in #x1B[36mSimulable.execute_static_behaviors#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    733#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mstatic_behavior#x1B[39m#x1B[33m'#x1B[39m):
#x1B[32m--&gt; #x1B[39m#x1B[32m734#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mstatic_behavior#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    735#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mself#x1B[39m.sp.with_loadings #x1B[38;5;129;01mand#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mstatic_loading#x1B[39m#x1B[33m'#x1B[39m):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/pump_stochastic.py:116#x1B[39m, in #x1B[36mMoveWat.static_behavior#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    115#x1B[39m #x1B[38;5;28mself#x1B[39m.s.eff = #x1B[38;5;28mself#x1B[39m.r.s.eff
#x1B[32m--&gt; #x1B[39m#x1B[32m116#x1B[39m #x1B[38;5;28;43msuper#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m.#x1B[49m#x1B[43mstatic_behavior#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    117#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;129;01mnot#x1B[39;00m #x1B[38;5;28mself#x1B[39m.t.executed_static:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/examples/pump/ex_pump.py:436#x1B[39m, in #x1B[36mMoveWat.static_behavior#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    435#x1B[39m #x1B[38;5;28mself#x1B[39m.wat_in.s.assign(#x1B[38;5;28mself#x1B[39m.wat_out.s, #x1B[33m'#x1B[39m#x1B[33mpressure#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mflowrate#x1B[39m#x1B[33m'#x1B[39m)
#x1B[32m--&gt; #x1B[39m#x1B[32m436#x1B[39m #x1B[38;5;28mprint#x1B[39m(#x1B[43ma#x1B[49m)

#x1B[31mNameError#x1B[39m: name 'a' is not defined

The above exception was the direct cause of the following exception:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:796#x1B[39m, in #x1B[36mSimulable.__call__#x1B[39m#x1B[34m(self, time, proptype, faults, disturbances, inc_at, end_of_simulation, copy)#x1B[39m
#x1B[32m    795#x1B[39m #x1B[38;5;28mself#x1B[39m.update_dynamic_behaviors(proptype=proptype)
#x1B[32m--&gt; #x1B[39m#x1B[32m796#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mupdate_static_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m=#x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    797#x1B[39m #x1B[38;5;28mself#x1B[39m.set_sub_faults()

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:724#x1B[39m, in #x1B[36mSimulable.update_static_behaviors#x1B[39m#x1B[34m(self, proptype)#x1B[39m
#x1B[32m    723#x1B[39m #x1B[38;5;28;01mwhile#x1B[39;00m active:
#x1B[32m--&gt; #x1B[39m#x1B[32m724#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mexecute_static_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    725#x1B[39m     #x1B[38;5;66;03m# determine if propagation should continue due to new states#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:732#x1B[39m, in #x1B[36mSimulable.execute_static_behaviors#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    731#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""Execute static behaviors."""#x1B[39;00m
#x1B[32m--&gt; #x1B[39m#x1B[32m732#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mupdate_arch_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43mstatic#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m)#x1B[49m
#x1B[32m    733#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mstatic_behavior#x1B[39m#x1B[33m'#x1B[39m):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:163#x1B[39m, in #x1B[36mArchitecture.update_arch_behaviors#x1B[39m#x1B[34m(self, proptype)#x1B[39m
#x1B[32m    162#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m proptype #x1B[38;5;129;01min#x1B[39;00m [#x1B[33m"#x1B[39m#x1B[33mstatic#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mstatic-once#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mboth#x1B[39m#x1B[33m"#x1B[39m] #x1B[38;5;129;01mand#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mprop_static#x1B[39m#x1B[33m'#x1B[39m):
#x1B[32m--&gt; #x1B[39m#x1B[32m163#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mprop_static#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:203#x1B[39m, in #x1B[36mArchitecture.prop_static#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    202#x1B[39m sim.set_mutables(exclude=[*#x1B[38;5;28mself#x1B[39m.staticflows])
#x1B[32m--&gt; #x1B[39m#x1B[32m203#x1B[39m #x1B[43msim#x1B[49m#x1B[43m(#x1B[49m#x1B[43mtime#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mt#x1B[49m#x1B[43m.#x1B[49m#x1B[43mtime#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m=#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mstatic-once#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43minc_at#x1B[49m#x1B[43m=#x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m)#x1B[49m
#x1B[32m    204#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m sim.has_changed(update=#x1B[38;5;28;01mTrue#x1B[39;00m, exclude=[*#x1B[38;5;28mself#x1B[39m.staticflows]):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:808#x1B[39m, in #x1B[36mSimulable.__call__#x1B[39m#x1B[34m(self, time, proptype, faults, disturbances, inc_at, end_of_simulation, copy)#x1B[39m
#x1B[32m    807#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m--&gt; #x1B[39m#x1B[32m808#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mError simulating #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mself#x1B[39m.name +
#x1B[32m    809#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m of class #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mself#x1B[39m.#x1B[34m__class__#x1B[39m.#x1B[34m__name__#x1B[39m +
#x1B[32m    810#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m at time=#x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.t.time)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m

#x1B[31mException#x1B[39m: Error simulating move_water of class MoveWat at time=0.0

The above exception was the direct cause of the following exception:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:480#x1B[39m, in #x1B[36mBaseSimulation.__call__#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    479#x1B[39m #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m480#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mrun#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    481#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:632#x1B[39m, in #x1B[36mSimulation.run#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    631#x1B[39m #x1B[38;5;28;01mfor#x1B[39;00m simevent #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.simevents:
#x1B[32m--&gt; #x1B[39m#x1B[32m632#x1B[39m     #x1B[43msimevent#x1B[49m#x1B[43m.#x1B[49m#x1B[43mrun#x1B[49m#x1B[43m(#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mmdl#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mscen#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mscen#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    633#x1B[39m     #x1B[38;5;28;01mif#x1B[39;00m simevent.result:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:395#x1B[39m, in #x1B[36mSimEvent.run#x1B[39m#x1B[34m(self, mdl, scen, nomhist, nomresult, **kwargs)#x1B[39m
#x1B[32m    394#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mself#x1B[39m.copy:
#x1B[32m--&gt; #x1B[39m#x1B[32m395#x1B[39m     #x1B[38;5;28mself#x1B[39m.mdl_copy = #x1B[43mmdl#x1B[49m#x1B[43m(#x1B[49m#x1B[43mtime#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mtime#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwar#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mcopy#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43;01mTrue#x1B[39;49;00m#x1B[43m)#x1B[49m
#x1B[32m    396#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:808#x1B[39m, in #x1B[36mSimulable.__call__#x1B[39m#x1B[34m(self, time, proptype, faults, disturbances, inc_at, end_of_simulation, copy)#x1B[39m
#x1B[32m    807#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m--&gt; #x1B[39m#x1B[32m808#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mError simulating #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mself#x1B[39m.name +
#x1B[32m    809#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m of class #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mself#x1B[39m.#x1B[34m__class__#x1B[39m.#x1B[34m__name__#x1B[39m +
#x1B[32m    810#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m at time=#x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.t.time)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m

#x1B[31mException#x1B[39m: Error simulating pump of class Pump at time=0.0

The above exception was the direct cause of the following exception:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[4]#x1B[39m#x1B[32m, line 1#x1B[39m
#x1B[32m----&gt; #x1B[39m#x1B[32m1#x1B[39m #x1B[43mnew_problem#x1B[49m#x1B[43m.#x1B[49m#x1B[43mf1#x1B[49m#x1B[43m(#x1B[49m#x1B[32;43m1#x1B[39;49m#x1B[43m)#x1B[49m
#x1B[32m      2#x1B[39m new_problem.f1(#x1B[32m0.5#x1B[39m)
#x1B[32m      3#x1B[39m new_problem.f1(#x1B[32m1.5#x1B[39m)

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/search.py:233#x1B[39m, in #x1B[36mBaseProblem.add_objective_callable.&lt;locals&gt;.newobj#x1B[39m#x1B[34m(*x)#x1B[39m
#x1B[32m    232#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34mnewobj#x1B[39m(*x):
#x1B[32m--&gt; #x1B[39m#x1B[32m233#x1B[39m     #x1B[38;5;28;01mreturn#x1B[39;00m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mcall_objective#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43mx#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mobjective#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/search.py:296#x1B[39m, in #x1B[36mBaseProblem.call_objective#x1B[39m#x1B[34m(self, objective, *x)#x1B[39m
#x1B[32m    294#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""Call a given objective at x."""#x1B[39;00m
#x1B[32m    295#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mself#x1B[39m.new_x(*x):
#x1B[32m--&gt; #x1B[39m#x1B[32m296#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mupdate_objectives#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43mx#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    297#x1B[39m #x1B[38;5;28;01mreturn#x1B[39;00m #x1B[38;5;28mself#x1B[39m.objectives[objective].value

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/search.py:760#x1B[39m, in #x1B[36mBaseSimProblem.update_objectives#x1B[39m#x1B[34m(self, *x)#x1B[39m
#x1B[32m    758#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""Update objectives/constraints by simulating the model at x."""#x1B[39;00m
#x1B[32m    759#x1B[39m #x1B[38;5;28mself#x1B[39m.update_variables(*x)
#x1B[32m--&gt; #x1B[39m#x1B[32m760#x1B[39m #x1B[38;5;28mself#x1B[39m.res, #x1B[38;5;28mself#x1B[39m.hist = #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43msim_mdl#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mcurrent_x#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    761#x1B[39m #x1B[38;5;28;01mfor#x1B[39;00m obj #x1B[38;5;129;01min#x1B[39;00m {**#x1B[38;5;28mself#x1B[39m.objectives, **#x1B[38;5;28mself#x1B[39m.constraints}.values():
#x1B[32m    762#x1B[39m     #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28misinstance#x1B[39m(obj, HistoryObjective) #x1B[38;5;129;01mor#x1B[39;00m #x1B[38;5;28misinstance#x1B[39m(obj, HistoryConstraint):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/search.py:943#x1B[39m, in #x1B[36mScenarioProblem.sim_mdl#x1B[39m#x1B[34m(self, *x)#x1B[39m
#x1B[32m    927#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m    928#x1B[39m #x1B[33;03mSimulate the model at the given variable value.#x1B[39;00m
#x1B[32m    929#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m    940#x1B[39m #x1B[33;03m    history for the sim.#x1B[39;00m
#x1B[32m    941#x1B[39m #x1B[33;03m"""#x1B[39;00m
#x1B[32m    942#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;129;01mnot#x1B[39;00m #x1B[38;5;28mself#x1B[39m.base_sim:
#x1B[32m--&gt; #x1B[39m#x1B[32m943#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mprep_sim#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    945#x1B[39m kwargs = {**#x1B[38;5;28mself#x1B[39m.kwargs,
#x1B[32m    946#x1B[39m           #x1B[33m'#x1B[39m#x1B[33mscen#x1B[39m#x1B[33m'#x1B[39m: #x1B[38;5;28mself#x1B[39m.gen_scenario(*x),
#x1B[32m    947#x1B[39m           #x1B[33m'#x1B[39m#x1B[33mmdl#x1B[39m#x1B[33m'#x1B[39m: [*#x1B[38;5;28mself#x1B[39m.base_sim.get_models().values()][#x1B[32m0#x1B[39m],
#x1B[32m    948#x1B[39m           #x1B[33m'#x1B[39m#x1B[33mto_return#x1B[39m#x1B[33m'#x1B[39m: #x1B[38;5;28mself#x1B[39m.obj_con_des_res(),
#x1B[32m    949#x1B[39m           #x1B[33m'#x1B[39m#x1B[33mprotect#x1B[39m#x1B[33m'#x1B[39m: #x1B[38;5;28;01mFalse#x1B[39;00m,
#x1B[32m    950#x1B[39m           #x1B[33m'#x1B[39m#x1B[33mcopy#x1B[39m#x1B[33m'#x1B[39m: #x1B[38;5;28;01mTrue#x1B[39;00m}
#x1B[32m    951#x1B[39m sim_kwar = {#x1B[33m'#x1B[39m#x1B[33mnomhist#x1B[39m#x1B[33m'#x1B[39m: #x1B[38;5;28mself#x1B[39m.base_sim.history.copy(),
#x1B[32m    952#x1B[39m             #x1B[33m'#x1B[39m#x1B[33mnomresult#x1B[39m#x1B[33m'#x1B[39m: #x1B[38;5;28mself#x1B[39m.base_sim.result.copy()}

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/search.py:924#x1B[39m, in #x1B[36mScenarioProblem.prep_sim#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    918#x1B[39m sim_kwar = {**filter_kwargs(Simulation, **#x1B[38;5;28mself#x1B[39m.kwargs),
#x1B[32m    919#x1B[39m             #x1B[33m'#x1B[39m#x1B[33mscen#x1B[39m#x1B[33m'#x1B[39m: ParameterScenario(sp={#x1B[33m'#x1B[39m#x1B[33mend_time#x1B[39m#x1B[33m'#x1B[39m: #x1B[38;5;28mself#x1B[39m.get_end_time()}),
#x1B[32m    920#x1B[39m             #x1B[33m'#x1B[39m#x1B[33mto_return#x1B[39m#x1B[33m'#x1B[39m: #x1B[38;5;28mself#x1B[39m.obj_con_des_res(),
#x1B[32m    921#x1B[39m             #x1B[33m'#x1B[39m#x1B[33mmdl#x1B[39m#x1B[33m'#x1B[39m: #x1B[38;5;28mself#x1B[39m.mdl,
#x1B[32m    922#x1B[39m             #x1B[33m'#x1B[39m#x1B[33mctimes#x1B[39m#x1B[33m'#x1B[39m: [#x1B[38;5;28mself#x1B[39m.get_start_time()]}
#x1B[32m    923#x1B[39m #x1B[38;5;28mself#x1B[39m.base_sim = Simulation(**sim_kwar)
#x1B[32m--&gt; #x1B[39m#x1B[32m924#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mbase_sim#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mget_sim_call_kwargs#x1B[49m#x1B[43m(#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mbase_sim#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:620#x1B[39m, in #x1B[36mSimulation.__call__#x1B[39m#x1B[34m(self, with_mdls, gen_samp, **kwargs)#x1B[39m
#x1B[32m    618#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34m__call__#x1B[39m(#x1B[38;5;28mself#x1B[39m, with_mdls=#x1B[38;5;28;01mFalse#x1B[39;00m, gen_samp=#x1B[38;5;28;01mFalse#x1B[39;00m, **kwargs):
#x1B[32m    619#x1B[39m #x1B[38;5;250m    #x1B[39m#x1B[33;03m"""Call the sim. Options return copied models and generated sampleapproches."""#x1B[39;00m
#x1B[32m--&gt; #x1B[39m#x1B[32m620#x1B[39m     res, hist = #x1B[38;5;28;43msuper#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__call__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    621#x1B[39m     #x1B[38;5;28mself#x1B[39m.check_faults()
#x1B[32m    622#x1B[39m     rets = [res, hist]

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:482#x1B[39m, in #x1B[36mBaseSimulation.__call__#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    480#x1B[39m     #x1B[38;5;28mself#x1B[39m.run(**kwargs)
#x1B[32m    481#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m--&gt; #x1B[39m#x1B[32m482#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mError simulating #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mself#x1B[39m.name+#x1B[33m"#x1B[39m#x1B[33m scenario(s)#x1B[39m#x1B[33m"#x1B[39m) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m
#x1B[32m    483#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mself#x1B[39m.tosave:
#x1B[32m    484#x1B[39m     #x1B[38;5;28mself#x1B[39m.save(**filter_kwargs(#x1B[38;5;28mself#x1B[39m.save, **kwargs))

#x1B[31mException#x1B[39m: Error simulating nominal scenario(s)</failure></testcase><testcase classname="examples.pump.Parallelism_Tutorial.ipynb" name="Parallelism_Tutorial.ipynb" time="7.375"><failure message="#x1B[31mException#x1B[39m: Error simulating nominal scenario(s)">---------------------------------------------------------------------------
result, mdlhist = propagate.nominal(mdl, to_return='graph')
#x1B[31m---------------------------------------------------------------------------#x1B[39m
#x1B[31mNameError#x1B[39m                                 Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:796#x1B[39m, in #x1B[36mSimulable.__call__#x1B[39m#x1B[34m(self, time, proptype, faults, disturbances, inc_at, end_of_simulation, copy)#x1B[39m
#x1B[32m    795#x1B[39m #x1B[38;5;28mself#x1B[39m.update_dynamic_behaviors(proptype=proptype)
#x1B[32m--&gt; #x1B[39m#x1B[32m796#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mupdate_static_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m=#x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    797#x1B[39m #x1B[38;5;28mself#x1B[39m.set_sub_faults()

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:728#x1B[39m, in #x1B[36mSimulable.update_static_behaviors#x1B[39m#x1B[34m(self, proptype)#x1B[39m
#x1B[32m    727#x1B[39m #x1B[38;5;28;01melif#x1B[39;00m proptype #x1B[38;5;129;01min#x1B[39;00m [#x1B[33m'#x1B[39m#x1B[33mstatic-once#x1B[39m#x1B[33m'#x1B[39m]:
#x1B[32m--&gt; #x1B[39m#x1B[32m728#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mexecute_static_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:734#x1B[39m, in #x1B[36mSimulable.execute_static_behaviors#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    733#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mstatic_behavior#x1B[39m#x1B[33m'#x1B[39m):
#x1B[32m--&gt; #x1B[39m#x1B[32m734#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mstatic_behavior#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    735#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mself#x1B[39m.sp.with_loadings #x1B[38;5;129;01mand#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mstatic_loading#x1B[39m#x1B[33m'#x1B[39m):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/ex_pump.py:436#x1B[39m, in #x1B[36mMoveWat.static_behavior#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    435#x1B[39m #x1B[38;5;28mself#x1B[39m.wat_in.s.assign(#x1B[38;5;28mself#x1B[39m.wat_out.s, #x1B[33m'#x1B[39m#x1B[33mpressure#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mflowrate#x1B[39m#x1B[33m'#x1B[39m)
#x1B[32m--&gt; #x1B[39m#x1B[32m436#x1B[39m #x1B[38;5;28mprint#x1B[39m(#x1B[43ma#x1B[49m)

#x1B[31mNameError#x1B[39m: name 'a' is not defined

The above exception was the direct cause of the following exception:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:796#x1B[39m, in #x1B[36mSimulable.__call__#x1B[39m#x1B[34m(self, time, proptype, faults, disturbances, inc_at, end_of_simulation, copy)#x1B[39m
#x1B[32m    795#x1B[39m #x1B[38;5;28mself#x1B[39m.update_dynamic_behaviors(proptype=proptype)
#x1B[32m--&gt; #x1B[39m#x1B[32m796#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mupdate_static_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m=#x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    797#x1B[39m #x1B[38;5;28mself#x1B[39m.set_sub_faults()

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:724#x1B[39m, in #x1B[36mSimulable.update_static_behaviors#x1B[39m#x1B[34m(self, proptype)#x1B[39m
#x1B[32m    723#x1B[39m #x1B[38;5;28;01mwhile#x1B[39;00m active:
#x1B[32m--&gt; #x1B[39m#x1B[32m724#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mexecute_static_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    725#x1B[39m     #x1B[38;5;66;03m# determine if propagation should continue due to new states#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:732#x1B[39m, in #x1B[36mSimulable.execute_static_behaviors#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    731#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""Execute static behaviors."""#x1B[39;00m
#x1B[32m--&gt; #x1B[39m#x1B[32m732#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mupdate_arch_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43mstatic#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m)#x1B[49m
#x1B[32m    733#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mstatic_behavior#x1B[39m#x1B[33m'#x1B[39m):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:163#x1B[39m, in #x1B[36mArchitecture.update_arch_behaviors#x1B[39m#x1B[34m(self, proptype)#x1B[39m
#x1B[32m    162#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m proptype #x1B[38;5;129;01min#x1B[39;00m [#x1B[33m"#x1B[39m#x1B[33mstatic#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mstatic-once#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mboth#x1B[39m#x1B[33m"#x1B[39m] #x1B[38;5;129;01mand#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mprop_static#x1B[39m#x1B[33m'#x1B[39m):
#x1B[32m--&gt; #x1B[39m#x1B[32m163#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mprop_static#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:203#x1B[39m, in #x1B[36mArchitecture.prop_static#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    202#x1B[39m sim.set_mutables(exclude=[*#x1B[38;5;28mself#x1B[39m.staticflows])
#x1B[32m--&gt; #x1B[39m#x1B[32m203#x1B[39m #x1B[43msim#x1B[49m#x1B[43m(#x1B[49m#x1B[43mtime#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mt#x1B[49m#x1B[43m.#x1B[49m#x1B[43mtime#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m=#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mstatic-once#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43minc_at#x1B[49m#x1B[43m=#x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m)#x1B[49m
#x1B[32m    204#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m sim.has_changed(update=#x1B[38;5;28;01mTrue#x1B[39;00m, exclude=[*#x1B[38;5;28mself#x1B[39m.staticflows]):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:808#x1B[39m, in #x1B[36mSimulable.__call__#x1B[39m#x1B[34m(self, time, proptype, faults, disturbances, inc_at, end_of_simulation, copy)#x1B[39m
#x1B[32m    807#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m--&gt; #x1B[39m#x1B[32m808#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mError simulating #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mself#x1B[39m.name +
#x1B[32m    809#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m of class #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mself#x1B[39m.#x1B[34m__class__#x1B[39m.#x1B[34m__name__#x1B[39m +
#x1B[32m    810#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m at time=#x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.t.time)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m

#x1B[31mException#x1B[39m: Error simulating move_water of class MoveWat at time=0.0

The above exception was the direct cause of the following exception:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:480#x1B[39m, in #x1B[36mBaseSimulation.__call__#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    479#x1B[39m #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m480#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mrun#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    481#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:632#x1B[39m, in #x1B[36mSimulation.run#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    631#x1B[39m #x1B[38;5;28;01mfor#x1B[39;00m simevent #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.simevents:
#x1B[32m--&gt; #x1B[39m#x1B[32m632#x1B[39m     #x1B[43msimevent#x1B[49m#x1B[43m.#x1B[49m#x1B[43mrun#x1B[49m#x1B[43m(#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mmdl#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mscen#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mscen#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    633#x1B[39m     #x1B[38;5;28;01mif#x1B[39;00m simevent.result:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:397#x1B[39m, in #x1B[36mSimEvent.run#x1B[39m#x1B[34m(self, mdl, scen, nomhist, nomresult, **kwargs)#x1B[39m
#x1B[32m    396#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m397#x1B[39m     #x1B[43mmdl#x1B[49m#x1B[43m(#x1B[49m#x1B[43mtime#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mtime#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwar#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    398#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mself#x1B[39m.to_return:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:808#x1B[39m, in #x1B[36mSimulable.__call__#x1B[39m#x1B[34m(self, time, proptype, faults, disturbances, inc_at, end_of_simulation, copy)#x1B[39m
#x1B[32m    807#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m--&gt; #x1B[39m#x1B[32m808#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mError simulating #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mself#x1B[39m.name +
#x1B[32m    809#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m of class #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mself#x1B[39m.#x1B[34m__class__#x1B[39m.#x1B[34m__name__#x1B[39m +
#x1B[32m    810#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m at time=#x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.t.time)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m

#x1B[31mException#x1B[39m: Error simulating pump of class Pump at time=0.0

The above exception was the direct cause of the following exception:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[3]#x1B[39m#x1B[32m, line 1#x1B[39m
#x1B[32m----&gt; #x1B[39m#x1B[32m1#x1B[39m result, mdlhist = #x1B[43mpropagate#x1B[49m#x1B[43m.#x1B[49m#x1B[43mnominal#x1B[49m#x1B[43m(#x1B[49m#x1B[43mmdl#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mto_return#x1B[49m#x1B[43m=#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mgraph#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:92#x1B[39m, in #x1B[36mnominal#x1B[39m#x1B[34m(mdl, **kwargs)#x1B[39m
#x1B[32m     74#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m     75#x1B[39m #x1B[33;03mRun the model over time in the nominal scenario.#x1B[39;00m
#x1B[32m     76#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m     89#x1B[39m #x1B[33;03m    A History dict with a history of tracked model properties over time.#x1B[39;00m
#x1B[32m     90#x1B[39m #x1B[33;03m"""#x1B[39;00m
#x1B[32m     91#x1B[39m sim = Simulation(mdl=mdl, **filter_kwargs(Simulation, **kwargs))
#x1B[32m---&gt; #x1B[39m#x1B[32m92#x1B[39m #x1B[38;5;28;01mreturn#x1B[39;00m #x1B[43msim#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mget_sim_call_kwargs#x1B[49m#x1B[43m(#x1B[49m#x1B[43msim#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:620#x1B[39m, in #x1B[36mSimulation.__call__#x1B[39m#x1B[34m(self, with_mdls, gen_samp, **kwargs)#x1B[39m
#x1B[32m    618#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34m__call__#x1B[39m(#x1B[38;5;28mself#x1B[39m, with_mdls=#x1B[38;5;28;01mFalse#x1B[39;00m, gen_samp=#x1B[38;5;28;01mFalse#x1B[39;00m, **kwargs):
#x1B[32m    619#x1B[39m #x1B[38;5;250m    #x1B[39m#x1B[33;03m"""Call the sim. Options return copied models and generated sampleapproches."""#x1B[39;00m
#x1B[32m--&gt; #x1B[39m#x1B[32m620#x1B[39m     res, hist = #x1B[38;5;28;43msuper#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__call__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    621#x1B[39m     #x1B[38;5;28mself#x1B[39m.check_faults()
#x1B[32m    622#x1B[39m     rets = [res, hist]

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:482#x1B[39m, in #x1B[36mBaseSimulation.__call__#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    480#x1B[39m     #x1B[38;5;28mself#x1B[39m.run(**kwargs)
#x1B[32m    481#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m--&gt; #x1B[39m#x1B[32m482#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mError simulating #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mself#x1B[39m.name+#x1B[33m"#x1B[39m#x1B[33m scenario(s)#x1B[39m#x1B[33m"#x1B[39m) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m
#x1B[32m    483#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mself#x1B[39m.tosave:
#x1B[32m    484#x1B[39m     #x1B[38;5;28mself#x1B[39m.save(**filter_kwargs(#x1B[38;5;28mself#x1B[39m.save, **kwargs))

#x1B[31mException#x1B[39m: Error simulating nominal scenario(s)</failure></testcase><testcase classname="examples.pump.Pump_Example_Notebook.ipynb" name="Pump_Example_Notebook.ipynb" time="9.074"><failure message="#x1B[31mException#x1B[39m: Error simulating nominal scenario(s)">---------------------------------------------------------------------------
result, mdlhist=propagate.nominal(mdl, to_return={'graph': FunctionArchitectureGraph})
#x1B[31m---------------------------------------------------------------------------#x1B[39m
#x1B[31mNameError#x1B[39m                                 Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:796#x1B[39m, in #x1B[36mSimulable.__call__#x1B[39m#x1B[34m(self, time, proptype, faults, disturbances, inc_at, end_of_simulation, copy)#x1B[39m
#x1B[32m    795#x1B[39m #x1B[38;5;28mself#x1B[39m.update_dynamic_behaviors(proptype=proptype)
#x1B[32m--&gt; #x1B[39m#x1B[32m796#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mupdate_static_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m=#x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    797#x1B[39m #x1B[38;5;28mself#x1B[39m.set_sub_faults()

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:728#x1B[39m, in #x1B[36mSimulable.update_static_behaviors#x1B[39m#x1B[34m(self, proptype)#x1B[39m
#x1B[32m    727#x1B[39m #x1B[38;5;28;01melif#x1B[39;00m proptype #x1B[38;5;129;01min#x1B[39;00m [#x1B[33m'#x1B[39m#x1B[33mstatic-once#x1B[39m#x1B[33m'#x1B[39m]:
#x1B[32m--&gt; #x1B[39m#x1B[32m728#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mexecute_static_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:734#x1B[39m, in #x1B[36mSimulable.execute_static_behaviors#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    733#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mstatic_behavior#x1B[39m#x1B[33m'#x1B[39m):
#x1B[32m--&gt; #x1B[39m#x1B[32m734#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mstatic_behavior#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    735#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mself#x1B[39m.sp.with_loadings #x1B[38;5;129;01mand#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mstatic_loading#x1B[39m#x1B[33m'#x1B[39m):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/ex_pump.py:436#x1B[39m, in #x1B[36mMoveWat.static_behavior#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    435#x1B[39m #x1B[38;5;28mself#x1B[39m.wat_in.s.assign(#x1B[38;5;28mself#x1B[39m.wat_out.s, #x1B[33m'#x1B[39m#x1B[33mpressure#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mflowrate#x1B[39m#x1B[33m'#x1B[39m)
#x1B[32m--&gt; #x1B[39m#x1B[32m436#x1B[39m #x1B[38;5;28mprint#x1B[39m(#x1B[43ma#x1B[49m)

#x1B[31mNameError#x1B[39m: name 'a' is not defined

The above exception was the direct cause of the following exception:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:796#x1B[39m, in #x1B[36mSimulable.__call__#x1B[39m#x1B[34m(self, time, proptype, faults, disturbances, inc_at, end_of_simulation, copy)#x1B[39m
#x1B[32m    795#x1B[39m #x1B[38;5;28mself#x1B[39m.update_dynamic_behaviors(proptype=proptype)
#x1B[32m--&gt; #x1B[39m#x1B[32m796#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mupdate_static_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m=#x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    797#x1B[39m #x1B[38;5;28mself#x1B[39m.set_sub_faults()

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:724#x1B[39m, in #x1B[36mSimulable.update_static_behaviors#x1B[39m#x1B[34m(self, proptype)#x1B[39m
#x1B[32m    723#x1B[39m #x1B[38;5;28;01mwhile#x1B[39;00m active:
#x1B[32m--&gt; #x1B[39m#x1B[32m724#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mexecute_static_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    725#x1B[39m     #x1B[38;5;66;03m# determine if propagation should continue due to new states#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:732#x1B[39m, in #x1B[36mSimulable.execute_static_behaviors#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    731#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""Execute static behaviors."""#x1B[39;00m
#x1B[32m--&gt; #x1B[39m#x1B[32m732#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mupdate_arch_behaviors#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43mstatic#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m)#x1B[49m
#x1B[32m    733#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mstatic_behavior#x1B[39m#x1B[33m'#x1B[39m):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:163#x1B[39m, in #x1B[36mArchitecture.update_arch_behaviors#x1B[39m#x1B[34m(self, proptype)#x1B[39m
#x1B[32m    162#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m proptype #x1B[38;5;129;01min#x1B[39;00m [#x1B[33m"#x1B[39m#x1B[33mstatic#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mstatic-once#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mboth#x1B[39m#x1B[33m"#x1B[39m] #x1B[38;5;129;01mand#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mprop_static#x1B[39m#x1B[33m'#x1B[39m):
#x1B[32m--&gt; #x1B[39m#x1B[32m163#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mprop_static#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:203#x1B[39m, in #x1B[36mArchitecture.prop_static#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m    202#x1B[39m sim.set_mutables(exclude=[*#x1B[38;5;28mself#x1B[39m.staticflows])
#x1B[32m--&gt; #x1B[39m#x1B[32m203#x1B[39m #x1B[43msim#x1B[49m#x1B[43m(#x1B[49m#x1B[43mtime#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mt#x1B[49m#x1B[43m.#x1B[49m#x1B[43mtime#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mproptype#x1B[49m#x1B[43m=#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mstatic-once#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43minc_at#x1B[49m#x1B[43m=#x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m)#x1B[49m
#x1B[32m    204#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m sim.has_changed(update=#x1B[38;5;28;01mTrue#x1B[39;00m, exclude=[*#x1B[38;5;28mself#x1B[39m.staticflows]):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:808#x1B[39m, in #x1B[36mSimulable.__call__#x1B[39m#x1B[34m(self, time, proptype, faults, disturbances, inc_at, end_of_simulation, copy)#x1B[39m
#x1B[32m    807#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m--&gt; #x1B[39m#x1B[32m808#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mError simulating #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mself#x1B[39m.name +
#x1B[32m    809#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m of class #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mself#x1B[39m.#x1B[34m__class__#x1B[39m.#x1B[34m__name__#x1B[39m +
#x1B[32m    810#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m at time=#x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.t.time)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m

#x1B[31mException#x1B[39m: Error simulating move_water of class MoveWat at time=0.0

The above exception was the direct cause of the following exception:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:480#x1B[39m, in #x1B[36mBaseSimulation.__call__#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    479#x1B[39m #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m480#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mrun#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    481#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:632#x1B[39m, in #x1B[36mSimulation.run#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    631#x1B[39m #x1B[38;5;28;01mfor#x1B[39;00m simevent #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.simevents:
#x1B[32m--&gt; #x1B[39m#x1B[32m632#x1B[39m     #x1B[43msimevent#x1B[49m#x1B[43m.#x1B[49m#x1B[43mrun#x1B[49m#x1B[43m(#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mmdl#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mscen#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mscen#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    633#x1B[39m     #x1B[38;5;28;01mif#x1B[39;00m simevent.result:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:397#x1B[39m, in #x1B[36mSimEvent.run#x1B[39m#x1B[34m(self, mdl, scen, nomhist, nomresult, **kwargs)#x1B[39m
#x1B[32m    396#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m397#x1B[39m     #x1B[43mmdl#x1B[49m#x1B[43m(#x1B[49m#x1B[43mtime#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mtime#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwar#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    398#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mself#x1B[39m.to_return:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:808#x1B[39m, in #x1B[36mSimulable.__call__#x1B[39m#x1B[34m(self, time, proptype, faults, disturbances, inc_at, end_of_simulation, copy)#x1B[39m
#x1B[32m    807#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m--&gt; #x1B[39m#x1B[32m808#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mError simulating #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mself#x1B[39m.name +
#x1B[32m    809#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m of class #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mself#x1B[39m.#x1B[34m__class__#x1B[39m.#x1B[34m__name__#x1B[39m +
#x1B[32m    810#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m at time=#x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.t.time)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m

#x1B[31mException#x1B[39m: Error simulating pump of class Pump at time=0.0

The above exception was the direct cause of the following exception:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[7]#x1B[39m#x1B[32m, line 1#x1B[39m
#x1B[32m----&gt; #x1B[39m#x1B[32m1#x1B[39m result, mdlhist=#x1B[43mpropagate#x1B[49m#x1B[43m.#x1B[49m#x1B[43mnominal#x1B[49m#x1B[43m(#x1B[49m#x1B[43mmdl#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mto_return#x1B[49m#x1B[43m=#x1B[49m#x1B[43m{#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mgraph#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m:#x1B[49m#x1B[43m #x1B[49m#x1B[43mFunctionArchitectureGraph#x1B[49m#x1B[43m}#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:92#x1B[39m, in #x1B[36mnominal#x1B[39m#x1B[34m(mdl, **kwargs)#x1B[39m
#x1B[32m     74#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m     75#x1B[39m #x1B[33;03mRun the model over time in the nominal scenario.#x1B[39;00m
#x1B[32m     76#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m     89#x1B[39m #x1B[33;03m    A History dict with a history of tracked model properties over time.#x1B[39;00m
#x1B[32m     90#x1B[39m #x1B[33;03m"""#x1B[39;00m
#x1B[32m     91#x1B[39m sim = Simulation(mdl=mdl, **filter_kwargs(Simulation, **kwargs))
#x1B[32m---&gt; #x1B[39m#x1B[32m92#x1B[39m #x1B[38;5;28;01mreturn#x1B[39;00m #x1B[43msim#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mget_sim_call_kwargs#x1B[49m#x1B[43m(#x1B[49m#x1B[43msim#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:620#x1B[39m, in #x1B[36mSimulation.__call__#x1B[39m#x1B[34m(self, with_mdls, gen_samp, **kwargs)#x1B[39m
#x1B[32m    618#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34m__call__#x1B[39m(#x1B[38;5;28mself#x1B[39m, with_mdls=#x1B[38;5;28;01mFalse#x1B[39;00m, gen_samp=#x1B[38;5;28;01mFalse#x1B[39;00m, **kwargs):
#x1B[32m    619#x1B[39m #x1B[38;5;250m    #x1B[39m#x1B[33;03m"""Call the sim. Options return copied models and generated sampleapproches."""#x1B[39;00m
#x1B[32m--&gt; #x1B[39m#x1B[32m620#x1B[39m     res, hist = #x1B[38;5;28;43msuper#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__call__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    621#x1B[39m     #x1B[38;5;28mself#x1B[39m.check_faults()
#x1B[32m    622#x1B[39m     rets = [res, hist]

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:482#x1B[39m, in #x1B[36mBaseSimulation.__call__#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    480#x1B[39m     #x1B[38;5;28mself#x1B[39m.run(**kwargs)
#x1B[32m    481#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m--&gt; #x1B[39m#x1B[32m482#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mError simulating #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mself#x1B[39m.name+#x1B[33m"#x1B[39m#x1B[33m scenario(s)#x1B[39m#x1B[33m"#x1B[39m) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m
#x1B[32m    483#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mself#x1B[39m.tosave:
#x1B[32m    484#x1B[39m     #x1B[38;5;28mself#x1B[39m.save(**filter_kwargs(#x1B[38;5;28mself#x1B[39m.save, **kwargs))

#x1B[31mException#x1B[39m: Error simulating nominal scenario(s)</failure></testcase><testcase classname="examples.pump.Tutorial_complete.ipynb" name="Tutorial_complete.ipynb" time="7.889"><failure message="#x1B[31mAttributeError#x1B[39m: 'Pump' object has no attribute 'staticfxns'">---------------------------------------------------------------------------
mdl.staticfxns
#x1B[31m---------------------------------------------------------------------------#x1B[39m
#x1B[31mAttributeError#x1B[39m                            Traceback (most recent call last)
#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[9]#x1B[39m#x1B[32m, line 1#x1B[39m
#x1B[32m----&gt; #x1B[39m#x1B[32m1#x1B[39m #x1B[43mmdl#x1B[49m#x1B[43m.#x1B[49m#x1B[43mstaticfxns#x1B[49m

#x1B[31mAttributeError#x1B[39m: 'Pump' object has no attribute 'staticfxns'</failure></testcase><testcase classname="examples.pump.ex_pump" name="examples.pump.ex_pump.accumulate" time="0.003" /><testcase classname="examples.pump.ex_pump" name="examples.pump.ex_pump.reseting_accumulate" time="0.002" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_app_prop_values" time="0.059"><failure message="Exception: Error simulating fault sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 12.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 12.0=SimEvent(copy=True)
- 20.0=SimEvent(copy=True)
- 27.0=SimEvent(copy=True)
- 34.0=SimEvent(copy=True)
- 42.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:395: in run
    self.mdl_copy = mdl(time=self.time, **kwar, copy=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 12.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
FaultSample of scenarios: 
 - move_water_mech_break_t12p0
 - move_water_mech_break_t20p0
 - move_water_mech_break_t27p0
 - move_water_mech_break_t34p0
 - move_water_mech_break_t42p0
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 12.0=SimEvent(copy=True)
- 20.0=SimEvent(copy=True)
- 27.0=SimEvent(copy=True)
- 34.0=SimEvent(copy=True)
- 42.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_app_prop_values&gt;

    def test_app_prop_values(self):
        """Test that delayed fault behavior occurs at the time specified by sample."""
        fd = FaultDomain(self.mdl)
        fd.add_fault('move_water', 'mech_break')
        fs = FaultSample(fd)
        fs.add_fault_phases("on", args=(5,))
    
&gt;       res, hist = prop.fault_sample(self.water_mdl, fs, showprogress=False)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

examples/pump/test_pump.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:249: in fault_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
FaultSample of scenarios: 
 - move_water_mech_break_t12p0
 - move_water_mech_break_t20p0
 - move_water_mech_break_t27p0
 - move_water_mech_break_t34p0
 - move_water_mech_break_t42p0
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating fault sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_approach_cost_calc" time="0.171"><failure message="Exception: Error simulating fault sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 1.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 0.0=SimEvent(copy=True, simulated=True)
- 1.0=SimEvent(copy=True)
- 2.0=SimEvent(copy=Tru...0=SimEvent(copy=True)
- 12.0=SimEvent(copy=True)
- 13.0=SimEvent(copy=True)
- 14.0=SimEvent(copy=True)
- ...(57 total)

kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:395: in run
    self.mdl_copy = mdl(time=self.time, **kwar, copy=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 1.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
FaultSample of scenarios: 
 - pump_fxns_import_ee_inf_v_t0p0
 - pump_fxns_import_ee_inf_v_t1p0...0
 - pump_fxns_import_ee_no_v_t2p0
 - pump_fxns_import_ee_no_v_t3p0
 - pump_fxns_import_ee_no_v_t4p0
 - ... (448 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 0.0=SimEvent(copy=True, simulated=True)
- 1.0=SimEvent(copy=True)
- 2.0=SimEvent(copy=Tru...0=SimEvent(copy=True)
- 12.0=SimEvent(copy=True)
- 13.0=SimEvent(copy=True)
- 14.0=SimEvent(copy=True)
- ...(57 total)

kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_approach_cost_calc&gt;

    def test_approach_cost_calc(self):
        """Test that the (linear) resilience loss function is perfectly approximated
        using the given sampling methods"""
        mdl = Pump(p={'cost': ('ee', 'repair', 'water'), 'delay': 0})
        fs_full = FaultSample(self.fd)
        fs_full.add_fault_phases(method='all')
&gt;       full_util = exp_cost_quant(fs_full, mdl)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

examples/pump/test_pump.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
examples/pump/test_pump.py:305: in exp_cost_quant
    result, mdlhists = prop.fault_sample(mdl, fs, showprogress=False)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:249: in fault_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
FaultSample of scenarios: 
 - pump_fxns_import_ee_inf_v_t0p0
 - pump_fxns_import_ee_inf_v_t1p0...0
 - pump_fxns_import_ee_no_v_t2p0
 - pump_fxns_import_ee_no_v_t3p0
 - pump_fxns_import_ee_no_v_t4p0
 - ... (448 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating fault sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_approach_parallelism" time="0.048"><failure message="Exception: Error simulating fault sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 2.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 2.0=SimEvent(copy=True)
- 27.0=SimEvent(copy=True)
- 52.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:395: in run
    self.mdl_copy = mdl(time=self.time, **kwar, copy=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 2.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
FaultSample of scenarios: 
 - pump_fxns_import_ee_inf_v_t2p0
 - pump_fxns_import_ee_no_v_t2p0
...ump_fxns_export_water_block_t2p0
 - pump_fxns_import_ee_inf_v_t27p0
 - pump_fxns_import_ee_no_v_t27p0
 - ... (24 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 2.0=SimEvent(copy=True)
- 27.0=SimEvent(copy=True)
- 52.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_approach_parallelism&gt;

    def test_approach_parallelism(self):
        """Test whether the pump simulates the same when simulated using parallel or
        staged options"""
&gt;       self.check_fs_parallel(self.default_mdl, self.fs)

examples/pump/test_pump.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:83: in check_fs_parallel
    res, hist = prop.fault_sample(mdl, fs, showprogress=False, pool=False,
fmdtools/sim/propagate.py:249: in fault_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
FaultSample of scenarios: 
 - pump_fxns_import_ee_inf_v_t2p0
 - pump_fxns_import_ee_no_v_t2p0
...ump_fxns_export_water_block_t2p0
 - pump_fxns_import_ee_inf_v_t27p0
 - pump_fxns_import_ee_no_v_t27p0
 - ... (24 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating fault sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_dynamic_prop_values" time="0.049"><failure message="Exception: Error simulating ('move_water', 'mech_break') scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 10.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 10.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:395: in run
    self.mdl_copy = mdl(time=self.time, **kwar, copy=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 10.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
SingleFaultScenario(sequence={10.0: Injection(faults={'move_water': ['mech_break']}, disturban...imes=(10,), function='move_water', fault='mech_break', rate=6e-06, name='move_water_mech_break_t10', time=10, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 10.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_dynamic_prop_values&gt;

    def test_dynamic_prop_values(self):
        """Test that given fault times result in the expected water/value loss"""
        faulttimes = [10, 20, 30]
        for faulttime in faulttimes:
&gt;           res, hist = prop.one_fault(self.water_mdl, "move_water", "mech_break",
                                       time=faulttime)

examples/pump/test_pump.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:162: in one_fault
    return sequence(mdl, scen=scen, name=str((fxnname, fault)), **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:222: in sequence
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
SingleFaultScenario(sequence={10.0: Injection(faults={'move_water': ['mech_break']}, disturban...imes=(10,), function='move_water', fault='mech_break', rate=6e-06, name='move_water_mech_break_t10', time=10, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating ('move_water', 'mech_break') scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_dynamic_prop_values_2" time="0.065"><failure message="Exception: Error simulating ('export_water', 'block') scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 25.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 25.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:395: in run
    self.mdl_copy = mdl(time=self.time, **kwar, copy=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 25.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
SingleFaultScenario(sequence={25.0: Injection(faults={'export_water': ['block']}, disturbances={})}, times=(25,), function='export_water', fault='block', rate=1e-05, name='export_water_block_t25', time=25, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 25.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_dynamic_prop_values_2&gt;

    def test_dynamic_prop_values_2(self):
        """Test that the delayed fault behavior occurs at the time specified"""
        delays = [0, 1, 5, 10]
        for delay in delays:
            mdl = Pump(p={'cost': ('water',), 'delay': delay}, track='all')
&gt;           res, hist = prop.one_fault(mdl, 'export_water', 'block', time=25)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

examples/pump/test_pump.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:162: in one_fault
    return sequence(mdl, scen=scen, name=str((fxnname, fault)), **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:222: in sequence
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
SingleFaultScenario(sequence={25.0: Injection(faults={'export_water': ['block']}, disturbances={})}, times=(25,), function='export_water', fault='block', rate=1e-05, name='export_water_block_t25', time=25, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating ('export_water', 'block') scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_fault_sample_isave" time="0.052"><failure message="Exception: Error simulating fault sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 2.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 2.0=SimEvent(copy=True)
- 27.0=SimEvent(copy=True)
- 52.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:395: in run
    self.mdl_copy = mdl(time=self.time, **kwar, copy=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 2.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
FaultSample of scenarios: 
 - pump_fxns_import_ee_inf_v_t2p0
 - pump_fxns_import_ee_no_v_t2p0
...ump_fxns_export_water_block_t2p0
 - pump_fxns_import_ee_inf_v_t27p0
 - pump_fxns_import_ee_no_v_t27p0
 - ... (24 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 2.0=SimEvent(copy=True)
- 27.0=SimEvent(copy=True)
- 52.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_fault_sample_isave&gt;

    def test_fault_sample_isave(self):
&gt;       self.check_fs_isave(self.mdl, self.fs, *self.filenames, "npz")

examples/pump/test_pump.py:285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:457: in check_fs_isave
    res, hist = prop.fault_sample(mdl, fs, **loc_kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:249: in fault_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
FaultSample of scenarios: 
 - pump_fxns_import_ee_inf_v_t2p0
 - pump_fxns_import_ee_no_v_t2p0
...ump_fxns_export_water_block_t2p0
 - pump_fxns_import_ee_inf_v_t27p0
 - pump_fxns_import_ee_no_v_t27p0
 - ... (24 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating fault sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_fault_sample_save" time="0.056"><failure message="Exception: Error simulating fault sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 2.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 2.0=SimEvent(copy=True)
- 27.0=SimEvent(copy=True)
- 52.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:395: in run
    self.mdl_copy = mdl(time=self.time, **kwar, copy=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 2.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
FaultSample of scenarios: 
 - pump_fxns_import_ee_inf_v_t2p0
 - pump_fxns_import_ee_no_v_t2p0
...ump_fxns_export_water_block_t2p0
 - pump_fxns_import_ee_inf_v_t27p0
 - pump_fxns_import_ee_no_v_t27p0
 - ... (24 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 2.0=SimEvent(copy=True)
- 27.0=SimEvent(copy=True)
- 52.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_fault_sample_save&gt;

    def test_fault_sample_save(self):
&gt;       self.check_fs_save(self.mdl, self.fs, "pump_res.npz", "pump_hist.npz")

examples/pump/test_pump.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:379: in check_fs_save
    res, hist = prop.fault_sample(mdl, fs, **loc_kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:249: in fault_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
FaultSample of scenarios: 
 - pump_fxns_import_ee_inf_v_t2p0
 - pump_fxns_import_ee_no_v_t2p0
...ump_fxns_export_water_block_t2p0
 - pump_fxns_import_ee_inf_v_t27p0
 - pump_fxns_import_ee_no_v_t27p0
 - ... (24 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating fault sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_fmea_options" time="0.082"><failure message="Exception: Error simulating fault sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 12.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 12.0=SimEvent(copy=True)
- 20.0=SimEvent(copy=True)
- 27.0=SimEvent(copy=True)
- 34.0=SimEvent(copy=True)
- 42.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:395: in run
    self.mdl_copy = mdl(time=self.time, **kwar, copy=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 12.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
FaultSample of scenarios: 
 - move_water_mech_break_t12p0
 - move_water_mech_break_t20p0
 - move_water_mech_break_t27p0
 - move_water_mech_break_t34p0
 - move_water_mech_break_t42p0
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 12.0=SimEvent(copy=True)
- 20.0=SimEvent(copy=True)
- 27.0=SimEvent(copy=True)
- 34.0=SimEvent(copy=True)
- 42.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_fmea_options&gt;

    def test_fmea_options(self):
        fd = FaultDomain(self.mdl)
        fd.add_fault('move_water', 'mech_break')
        fs = FaultSample(fd)
        fs.add_fault_phases("on", args=(5,))
    
&gt;       ec, mdlhists = prop.fault_sample(self.water_mdl, fs, showprogress=False)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

examples/pump/test_pump.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:249: in fault_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
FaultSample of scenarios: 
 - move_water_mech_break_t12p0
 - move_water_mech_break_t20p0
 - move_water_mech_break_t27p0
 - move_water_mech_break_t34p0
 - move_water_mech_break_t42p0
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating fault sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_hist_tracking_setup" time="0.085" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_model_copy_different" time="0.057"><failure message="Exception: Error simulating pump of class Pump at time=0.0">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_model_copy_different&gt;

    def test_model_copy_different(self):
        inj_times = [10, 20, 30, 40]
&gt;       self.check_model_copy_different(self.mdl, inj_times, max_time=55)

examples/pump/test_pump.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:186: in check_model_copy_different
    mdlc(time=t)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_model_copy_same" time="0.077"><failure message="Exception: Error simulating pump of class Pump at time=0.0">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 0, proptype = 'both', faults = {}, disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_model_copy_same&gt;

    def test_model_copy_same(self):
        inj_times = [10, 20, 30, 40]
&gt;       self.check_model_copy_same(self.mdl, Pump(), inj_times, 30, max_time=55)

examples/pump/test_pump.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:63: in check_model_copy_same
    mdla(time=t, faults=scen)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 0, proptype = 'both', faults = {}, disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_model_reset" time="0.001"><skipped type="pytest.skip" message="Reset not fully implemented yet and unused throughout.">/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/test_pump.py:138: Reset not fully implemented yet and unused throughout.</skipped></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_nested_sample_isave" time="0.060"><failure message="Exception: Error simulating nested sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {'faultdomains': {'fd': (('all',), {})}, 'faultsamples': {'fs': (('fault_phases', 'fd'), {})}, 'get_phasemap': False}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
Scenario(sequence={}, times=(), rate=1.0, name='nominal', time=0.0)
kwargs = {'faultdomains': {'fd': (('all',), {})}, 'faultsamples': {'fs': (('fault_phases', 'fd'), {})}, 'get_phasemap': False}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1019: in run
    self.run_nom(gen_samp=True, **kwargs)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {'faultdomains': {'fd': (('all',), {})}, 'faultsamples': {'fs': (('fault_phases', 'fd'), {})}, 'get_phasemap': False}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = NestedSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_...7_var_7
 - rep8_var_8
 - rep9_var_9
 over 
SampleApproach({'fd': (('all',), {})},
{'fs': (('fault_phases', 'fd'), {})})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:831: in run
    res_list = list(tqdm.tqdm(runner(inputs),
../fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1169: in __iter__
    for obj in iterable:
fmdtools/sim/propagate.py:1052: in exec_fault_sim
    return sim(**args[1])
           ^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
Scenario(sequence={}, times=(), rate=1.0, name='nominal', time=0.0)
kwargs = {'faultdomains': {'fd': (('all',), {})}, 'faultsamples': {'fs': (('fault_phases', 'fd'), {})}, 'get_phasemap': False}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating rep0_var_0 scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_nested_sample_isave&gt;

    def test_nested_sample_isave(self):
&gt;       self.check_ns_isave(self.mdl, self.ps, self.faultdomains, self.faultsamples,
                            *self.filenames, "npz")

examples/pump/test_pump.py:272: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:475: in check_ns_isave
    res, hist, apps = prop.nested_sample(mdl, ps, **loc_kwargs)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:312: in nested_sample
    res, hist = sim(**get_sim_call_kwargs(sim, **kwargs))
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = NestedSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_...7_var_7
 - rep8_var_8
 - rep9_var_9
 over 
SampleApproach({'fd': (('all',), {})},
{'fs': (('fault_phases', 'fd'), {})})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nested sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_nested_sample_save" time="0.057"><failure message="Exception: Error simulating nested sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {'faultdomains': {'fd': (('all',), {})}, 'faultsamples': {'fs': (('fault_phases', 'fd'), {})}, 'get_phasemap': False}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
Scenario(sequence={}, times=(), rate=1.0, name='nominal', time=0.0)
kwargs = {'faultdomains': {'fd': (('all',), {})}, 'faultsamples': {'fs': (('fault_phases', 'fd'), {})}, 'get_phasemap': False}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1019: in run
    self.run_nom(gen_samp=True, **kwargs)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {'faultdomains': {'fd': (('all',), {})}, 'faultsamples': {'fs': (('fault_phases', 'fd'), {})}, 'get_phasemap': False}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = NestedSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_...7_var_7
 - rep8_var_8
 - rep9_var_9
 over 
SampleApproach({'fd': (('all',), {})},
{'fs': (('fault_phases', 'fd'), {})})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:831: in run
    res_list = list(tqdm.tqdm(runner(inputs),
../fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1169: in __iter__
    for obj in iterable:
fmdtools/sim/propagate.py:1052: in exec_fault_sim
    return sim(**args[1])
           ^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
Scenario(sequence={}, times=(), rate=1.0, name='nominal', time=0.0)
kwargs = {'faultdomains': {'fd': (('all',), {})}, 'faultsamples': {'fs': (('fault_phases', 'fd'), {})}, 'get_phasemap': False}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating rep0_var_0 scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_nested_sample_save&gt;

    def test_nested_sample_save(self):
&gt;       self.check_ns_save(self.mdl, self.ps, self.faultdomains, self.faultsamples,
                           "pump_res.npz", "pump_hist.npz")

examples/pump/test_pump.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:415: in check_ns_save
    res, hist, apps = prop.nested_sample(mdl, ps, **loc_kwargs)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:312: in nested_sample
    res, hist = sim(**get_sim_call_kwargs(sim, **kwargs))
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = NestedSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_...7_var_7
 - rep8_var_8
 - rep9_var_9
 over 
SampleApproach({'fd': (('all',), {})},
{'fs': (('fault_phases', 'fd'), {})})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nested sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_nominal_save" time="0.084"><failure message="Exception: Error simulating nominal scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_nominal_save&gt;

    def test_nominal_save(self):
        for ext in [".npz", ".csv", ".json"]:
            fnames = "pump_res" + ext, "pump_hist" + ext
&gt;           self.check_onerun_save(self.mdl, "nominal", *fnames)

examples/pump/test_pump.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:251: in check_onerun_save
    res, hist = prop.nominal(mdl, **kw)
                ^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:92: in nominal
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_one_run_csv" time="0.055"><failure message="Exception: Error simulating ('export_water', 'block') scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
SingleFaultScenario(sequence={20.0: Injection(faults={'export_water': ['block']}, disturbances={})}, times=(20,), function='export_water', fault='block', rate=1e-05, name='export_water_block_t20', time=20, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1025: in run
    self.run_nom()
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_one_run_csv&gt;

    def test_one_run_csv(self):
        if os.path.exists("single_fault.csv"):
            os.remove("single_fault.csv")
&gt;       res, hist = prop.one_fault(self.mdl, 'export_water', 'block', time=20,
                                   staged=False, run_stochastic=True, sp={'seed': 10})

examples/pump/test_pump.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:162: in one_fault
    return sequence(mdl, scen=scen, name=str((fxnname, fault)), **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:222: in sequence
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
SingleFaultScenario(sequence={20.0: Injection(faults={'export_water': ['block']}, disturbances={})}, times=(20,), function='export_water', fault='block', rate=1e-05, name='export_water_block_t20', time=20, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating ('export_water', 'block') scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_one_run_json" time="0.049"><failure message="Exception: Error simulating ('export_water', 'block') scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
SingleFaultScenario(sequence={20.0: Injection(faults={'export_water': ['block']}, disturbances={})}, times=(20,), function='export_water', fault='block', rate=1e-05, name='export_water_block_t20', time=20, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1025: in run
    self.run_nom()
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_one_run_json&gt;

    def test_one_run_json(self):
        if os.path.exists("single_fault.json"):
            os.remove("single_fault.json")
    
&gt;       res, hist = prop.one_fault(self.mdl, 'export_water', 'block', time=20,
                                   staged=False, run_stochastic=True, sp={'seed': 10})

examples/pump/test_pump.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:162: in one_fault
    return sequence(mdl, scen=scen, name=str((fxnname, fault)), **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:222: in sequence
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
SingleFaultScenario(sequence={20.0: Injection(faults={'export_water': ['block']}, disturbances={})}, times=(20,), function='export_water', fault='block', rate=1e-05, name='export_water_block_t20', time=20, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating ('export_water', 'block') scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_one_run_pickle" time="0.049"><failure message="Exception: Error simulating ('export_water', 'block') scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
SingleFaultScenario(sequence={20.0: Injection(faults={'export_water': ['block']}, disturbances={})}, times=(20,), function='export_water', fault='block', rate=1e-05, name='export_water_block_t20', time=20, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1025: in run
    self.run_nom()
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_one_run_pickle&gt;

    def test_one_run_pickle(self):
        if os.path.exists("single_fault.npz"):
            os.remove("single_fault.npz")
    
&gt;       res, hist = prop.one_fault(self.mdl, 'export_water', 'block', time=20,
                                   staged=False, run_stochastic=True, sp={'seed': 10})

examples/pump/test_pump.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:162: in one_fault
    return sequence(mdl, scen=scen, name=str((fxnname, fault)), **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:222: in sequence
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
SingleFaultScenario(sequence={20.0: Injection(faults={'export_water': ['block']}, disturbances={})}, times=(20,), function='export_water', fault='block', rate=1e-05, name='export_water_block_t20', time=20, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating ('export_water', 'block') scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_onefault_save" time="0.050"><failure message="Exception: Error simulating ('export_water', 'block') scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 25.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 25.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:395: in run
    self.mdl_copy = mdl(time=self.time, **kwar, copy=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 25.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
SingleFaultScenario(sequence={25.0: Injection(faults={'export_water': ['block']}, disturbances={})}, times=(25,), function='export_water', fault='block', rate=1e-05, name='export_water_block_t25', time=25, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 25.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_onefault_save&gt;

    def test_onefault_save(self):
        faultscen = ('export_water', 'block', 25)
        for ext in [".npz", ".csv", ".json"]:
            fnames = "pump_res" + ext, "pump_hist" + ext
&gt;           self.check_onerun_save(self.mdl, 'one_fault', *fnames, faultscen=faultscen)

examples/pump/test_pump.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:255: in check_onerun_save
    res, hist = prop.one_fault(mdl, fxn, mode, time, **kw)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:162: in one_fault
    return sequence(mdl, scen=scen, name=str((fxnname, fault)), **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:222: in sequence
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
SingleFaultScenario(sequence={25.0: Injection(faults={'export_water': ['block']}, disturbances={})}, times=(25,), function='export_water', fault='block', rate=1e-05, name='export_water_block_t25', time=25, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating ('export_water', 'block') scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_param_sample" time="0.037" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_param_sample_isave" time="0.048"><failure message="Exception: Error simulating parameter sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:831: in run
    res_list = list(tqdm.tqdm(runner(inputs),
../fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1169: in __iter__
    for obj in iterable:
fmdtools/sim/propagate.py:682: in exec_sim
    return sim()
           ^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating rep0_var_0 scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_param_sample_isave&gt;

    def test_param_sample_isave(self):
&gt;       self.check_ps_isave(self.mdl, self.ps, *self.filenames, "npz")

examples/pump/test_pump.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:464: in check_ps_isave
    res, hist = prop.parameter_sample(mdl, ps, **loc_kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:120: in parameter_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating parameter sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_param_sample_save" time="0.049"><failure message="Exception: Error simulating parameter sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:831: in run
    res_list = list(tqdm.tqdm(runner(inputs),
../fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1169: in __iter__
    for obj in iterable:
fmdtools/sim/propagate.py:682: in exec_sim
    return sim()
           ^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating rep0_var_0 scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_param_sample_save&gt;

    def test_param_sample_save(self):
&gt;       self.check_ps_save(self.mdl, self.ps, "pump_res.npz", "pump_hist.npz")

examples/pump/test_pump.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:401: in check_ps_save
    res, hist = prop.parameter_sample(mdl, ps, **loc_kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:120: in parameter_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating parameter sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_pickleability" time="7.307" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_save_load_multfault" time="0.057"><failure message="Exception: Error simulating sequence scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 10.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 10.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:395: in run
    self.mdl_copy = mdl(time=self.time, **kwar, copy=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 10.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
Scenario(sequence={10: Injection(faults={'export_water': ['block']}, disturbances={}), 20: Injection(faults={'move_water': ['short']}, disturbances={})}, times=(10, 20), rate=nan, name='sequence', time=10)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 10.0=SimEvent(copy=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_save_load_multfault&gt;

    def test_save_load_multfault(self):
        faultscen = {10: {"export_water": ['block']}, 20: {"move_water": ["short"]}}
        for ext in [".npz", ".csv", ".json"]:
            fnames = "pump_res" + ext, "pump_hist" + ext
&gt;           self.check_onerun_save(self.mdl, 'sequence', *fnames, faultscen=faultscen)

examples/pump/test_pump.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:257: in check_onerun_save
    res, hist = prop.sequence(mdl, faultseq=faultscen, **kw)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:222: in sequence
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
Scenario(sequence={10: Injection(faults={'export_water': ['block']}, disturbances={}), 20: Injection(faults={'move_water': ['short']}, disturbances={})}, times=(10, 20), rate=nan, name='sequence', time=10)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating sequence scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_single_faults_isave" time="0.075"><failure message="Exception: Error simulating single faults scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 0.0=SimEvent(copy=True, simulated=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
FaultSample of scenarios: 
 - pump_fxns_import_ee_inf_v_t0p0
 - pump_fxns_import_ee_no_v_t0p0
...ig_t0p0
 - pump_fxns_move_water_mech_break_t0p0
 - pump_fxns_move_water_short_t0p0
 - pump_fxns_export_water_block_t0p0
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 0.0=SimEvent(copy=True, simulated=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_single_faults_isave&gt;

    def test_single_faults_isave(self):
&gt;       self.check_sf_isave(self.mdl, *self.filenames, "npz")

examples/pump/test_pump.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:450: in check_sf_isave
    res, hist = prop.single_faults(mdl, **loc_kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:280: in single_faults
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
FaultSample of scenarios: 
 - pump_fxns_import_ee_inf_v_t0p0
 - pump_fxns_import_ee_no_v_t0p0
...ig_t0p0
 - pump_fxns_move_water_mech_break_t0p0
 - pump_fxns_move_water_short_t0p0
 - pump_fxns_export_water_block_t0p0
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating single faults scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_single_faults_save" time="0.072"><failure message="Exception: Error simulating single faults scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 0.0=SimEvent(copy=True, simulated=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
FaultSample of scenarios: 
 - pump_fxns_import_ee_inf_v_t0p0
 - pump_fxns_import_ee_no_v_t0p0
...ig_t0p0
 - pump_fxns_move_water_mech_break_t0p0
 - pump_fxns_move_water_short_t0p0
 - pump_fxns_export_water_block_t0p0
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 0.0=SimEvent(copy=True, simulated=True)
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.PumpTests testMethod=test_single_faults_save&gt;

    def test_single_faults_save(self):
&gt;       self.check_sf_save(self.mdl, "pump_res.npz", "pump_hist.npz")

examples/pump/test_pump.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:390: in check_sf_save
    res, hist = prop.single_faults(mdl, **loc_kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:280: in single_faults
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
FaultSample of scenarios: 
 - pump_fxns_import_ee_inf_v_t0p0
 - pump_fxns_import_ee_no_v_t0p0
...ig_t0p0
 - pump_fxns_move_water_mech_break_t0p0
 - pump_fxns_move_water_short_t0p0
 - pump_fxns_export_water_block_t0p0
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating single faults scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump.PumpTests" name="test_value_setting" time="0.037" /><testcase classname="examples.pump.test_pump.PumpTests" name="test_value_setting_dict" time="0.042" /><testcase classname="examples.pump.test_pump.IndivPumpTests" name="test_mutable_setup" time="0.011"><failure message="Exception: Error simulating nominal scenario(s)">self = movewatdynamic MoveWatDynamic
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby,...e=0.0012, pressure=0.04, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0012, pressure=0.04, area=1.0, level=1.0))
time = 50.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = movewatdynamic MoveWatDynamic
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby,...e=0.0012, pressure=0.04, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0012, pressure=0.04, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = movewatdynamic MoveWatDynamic
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby,...e=0.0012, pressure=0.04, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0012, pressure=0.04, area=1.0, level=1.0))
time = 50.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating movewatdynamic of class MoveWatDynamic at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump.IndivPumpTests testMethod=test_mutable_setup&gt;

    def test_mutable_setup(self):
        """Check that non-default state carries through to simulation."""
        mdl_diff = MoveWatDynamic(s={'eff': 2.0})
        self.assertEqual(mdl_diff.s.eff, 2.0)
&gt;       res, hist = prop.nominal(mdl_diff, showprogress=False, warn_faults=False)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

examples/pump/test_pump.py:321: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:92: in nominal
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump_example.ImportEE_Tests" name="test_behave_inf_v" time="0.005" /><testcase classname="examples.pump.test_pump_example.ImportEE_Tests" name="test_behave_no_v" time="0.004" /><testcase classname="examples.pump.test_pump_example.ImportEE_Tests" name="test_behave_nom" time="0.013" /><testcase classname="examples.pump.test_pump_example.ImportEE_Tests" name="test_condfaults_hi" time="0.005" /><testcase classname="examples.pump.test_pump_example.ImportEE_Tests" name="test_condfaults_nom" time="0.006" /><testcase classname="examples.pump.test_pump_example.ImportEE_Tests" name="test_initialization" time="0.006" /><testcase classname="examples.pump.test_pump_example.MoveWat_Tests" name="test_condfaults_dynamic" time="0.008"><failure message="NameError: name 'a' is not defined">self = &lt;examples.pump.test_pump_example.MoveWat_Tests testMethod=test_condfaults_dynamic&gt;

    def test_condfaults_dynamic(self):
        """Test that blockage dynamic behavior results in a mech failure after 10 dt."""
        self.move_wat.wat_out.s.area = 0.0001
        for t in range(0, 20):
            self.move_wat.t.time = t
&gt;           self.move_wat.static_behavior()

examples/pump/test_pump_example.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ImportWat MoveWat
- t=MoveWatTime(time=0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0})
-...e-08, pressure=200.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=6e-08, pressure=200.0, area=0.0001, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError</failure></testcase><testcase classname="examples.pump.test_pump_example.MoveWat_Tests" name="test_initialization" time="0.006" /><testcase classname="examples.pump.test_pump_example.MoveWat_Tests" name="test_nom" time="0.006"><failure message="NameError: name 'a' is not defined">self = &lt;examples.pump.test_pump_example.MoveWat_Tests testMethod=test_nom&gt;

    def test_nom(self):
&gt;       self.move_wat.static_behavior()

examples/pump/test_pump_example.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ImportWat MoveWat
- t=MoveWatTime(time=-0.1, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...e=0.0006, pressure=0.02, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0006, pressure=0.02, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError</failure></testcase><testcase classname="examples.pump.test_pump_example.Integration_Tests" name="test_blockage_results" time="0.052"><failure message="Exception: Error simulating ('export_water', 'block') scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 10.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 10.0=SimEvent(copy=True)
- end=SimEvent(to_return={'faults': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:395: in run
    self.mdl_copy = mdl(time=self.time, **kwar, copy=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 10.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
SingleFaultScenario(sequence={10.0: Injection(faults={'export_water': ['block']}, disturbances={})}, times=(10,), function='export_water', fault='block', rate=1e-05, name='export_water_block_t10', time=10, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 10.0=SimEvent(copy=True)
- end=SimEvent(to_return={'faults': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_example.Integration_Tests testMethod=test_blockage_results&gt;

    def test_blockage_results(self):
        """Tests the output of the model when integrated in a faulty scenario."""
&gt;       res, mdlhist = propagate.one_fault(self.mdl, 'export_water', 'block',
                                           time=10, to_return='faults')

examples/pump/test_pump_example.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:162: in one_fault
    return sequence(mdl, scen=scen, name=str((fxnname, fault)), **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:222: in sequence
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
SingleFaultScenario(sequence={10.0: Injection(faults={'export_water': ['block']}, disturbances={})}, times=(10,), function='export_water', fault='block', rate=1e-05, name='export_water_block_t10', time=10, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating ('export_water', 'block') scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump_example.Integration_Tests" name="test_blockage_static" time="0.034"><failure message="Exception: Error simulating pump of class Pump at time=0.0">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_example.Integration_Tests testMethod=test_blockage_static&gt;

    def test_blockage_static(self):
        """
        Check state of the model itself at a particular time-step.
    
        Useful when the model has states which are not recorded.
        """
        for t in range(0, 10):
&gt;           self.mdl(time=t)  # simulate time up until t=10
            ^^^^^^^^^^^^^^^^

examples/pump/test_pump_example.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception</failure></testcase><testcase classname="examples.pump.test_pump_example.Integration_Tests" name="test_nominal_results" time="0.022"><failure message="Exception: Error simulating nominal scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_example.Integration_Tests testMethod=test_nominal_results&gt;

    def test_nominal_results(self):
        """Tests the output of the model when integrated in the nominal scenario"""
&gt;       endresult, mdlhist = propagate.nominal(self.mdl, protect=False)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

examples/pump/test_pump_example.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:92: in nominal
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_mdl_pickle" time="74.860" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_model_copy_different" time="0.042"><failure message="Exception: Error simulating pump of class Pump at time=0.0">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
examples/pump/pump_stochastic.py:116: in static_behavior
    super().static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=42)
FLO...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_model_copy_different&gt;

    def test_model_copy_different(self):
&gt;       self.check_model_copy_different(self.mdl, [10, 20, 30], max_time=55)

examples/pump/test_pump_stochastic.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:186: in check_model_copy_different
    mdlc(time=t)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=42)
FLO...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception</failure></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_model_copy_same" time="0.085"><failure message="Exception: Error simulating pump of class Pump at time=0.0">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
examples/pump/pump_stochastic.py:116: in static_behavior
    super().static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=42)
FLO...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 0, proptype = 'both', faults = {}, disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_model_copy_same&gt;

    def test_model_copy_same(self):
&gt;       self.check_model_copy_same(self.mdl, Pump(sp=dict(run_stochastic=True)),
                                   [10, 20, 30], 25, max_time=55)

examples/pump/test_pump_stochastic.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:63: in check_model_copy_same
    mdla(time=t, faults=scen)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=42)
FLO...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 0, proptype = 'both', faults = {}, disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception</failure></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_model_reset" time="0.001"><skipped type="pytest.skip" message="Reset not fully implemented yet and unused throughout.">/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/test_pump_stochastic.py:112: Reset not fully implemented yet and unused throughout.</skipped></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_model_set_vars" time="0.032" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_nested_sample_isave" time="0.146"><failure message="Exception: Error simulating nested sample scenario(s)">multiprocessing.pool.RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 796, in __call__
    self.update_static_behaviors(proptype=proptype)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 728, in update_static_behaviors
    self.execute_static_behaviors()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 734, in execute_static_behaviors
    self.static_behavior()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/pump_stochastic.py", line 116, in static_behavior
    super().static_behavior()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/ex_pump.py", line 436, in static_behavior
    print(a)
          ^
NameError: name 'a' is not defined

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 796, in __call__
    self.update_static_behaviors(proptype=proptype)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 724, in update_static_behaviors
    self.execute_static_behaviors()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 732, in execute_static_behaviors
    self.update_arch_behaviors("static")
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 163, in update_arch_behaviors
    self.prop_static()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 203, in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 808, in __call__
    raise Exception("Error simulating " + self.name +
Exception: Error simulating move_water of class MoveWat at time=0.0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 480, in __call__
    self.run(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 632, in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 397, in run
    mdl(time=self.time, **kwar)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 808, in __call__
    raise Exception("Error simulating " + self.name +
Exception: Error simulating pump of class Pump at time=0.0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 480, in __call__
    self.run(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 1019, in run
    self.run_nom(gen_samp=True, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 1008, in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 620, in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 482, in __call__
    raise Exception("Error simulating "+self.name+" scenario(s)") from e
Exception: Error simulating nominal scenario(s)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/multiprocessing/pool.py", line 125, in worker
    result = (True, func(*args, **kwds))
                    ^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 1052, in exec_fault_sim
    return sim(**args[1])
           ^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 975, in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 482, in __call__
    raise Exception("Error simulating "+self.name+" scenario(s)") from e
Exception: Error simulating rep0_var_0 scenario(s)
"""

The above exception was the direct cause of the following exception:

self = NestedSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_...7_var_7
 - rep8_var_8
 - rep9_var_9
 over 
SampleApproach({'fd': (('all',), {})},
{'fs': (('fault_phases', 'fd'), {})})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:831: in run
    res_list = list(tqdm.tqdm(runner(inputs),
../fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1169: in __iter__
    for obj in iterable:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;multiprocessing.pool.IMapIterator object at 0x7faae5710d10&gt;
timeout = None

    def next(self, timeout=None):
        with self._cond:
            try:
                item = self._items.popleft()
            except IndexError:
                if self._index == self._length:
                    self._pool = None
                    raise StopIteration from None
                self._cond.wait(timeout)
                try:
                    item = self._items.popleft()
                except IndexError:
                    if self._index == self._length:
                        self._pool = None
                        raise StopIteration from None
                    raise TimeoutError from None
    
        success, value = item
        if success:
            return value
&gt;       raise value
E       Exception: Error simulating rep0_var_0 scenario(s)

/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/multiprocessing/pool.py:873: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_nested_sample_isave&gt;

    def test_nested_sample_isave(self):
        ps = ParameterSample()
        ps.add_variable_replicates([], replicates=10)
        faultdomains = {'fd': (('all', ), {})}
        faultsamples = {'fs': (('fault_phases', 'fd'), {})}
        fnames = ("spump_res", "spump_hist")
&gt;       self.check_ns_isave(self.mdl, ps, faultdomains, faultsamples, *fnames, "npz", pool=mp.Pool(4))

examples/pump/test_pump_stochastic.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:475: in check_ns_isave
    res, hist, apps = prop.nested_sample(mdl, ps, **loc_kwargs)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:312: in nested_sample
    res, hist = sim(**get_sim_call_kwargs(sim, **kwargs))
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = NestedSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_...7_var_7
 - rep8_var_8
 - rep9_var_9
 over 
SampleApproach({'fd': (('all',), {})},
{'fs': (('fault_phases', 'fd'), {})})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nested sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_nested_sample_save" time="0.129"><failure message="Exception: Error simulating nested sample scenario(s)">multiprocessing.pool.RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 796, in __call__
    self.update_static_behaviors(proptype=proptype)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 728, in update_static_behaviors
    self.execute_static_behaviors()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 734, in execute_static_behaviors
    self.static_behavior()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/pump_stochastic.py", line 116, in static_behavior
    super().static_behavior()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/ex_pump.py", line 436, in static_behavior
    print(a)
          ^
NameError: name 'a' is not defined

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 796, in __call__
    self.update_static_behaviors(proptype=proptype)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 724, in update_static_behaviors
    self.execute_static_behaviors()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 732, in execute_static_behaviors
    self.update_arch_behaviors("static")
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 163, in update_arch_behaviors
    self.prop_static()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 203, in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 808, in __call__
    raise Exception("Error simulating " + self.name +
Exception: Error simulating move_water of class MoveWat at time=0.0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 480, in __call__
    self.run(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 632, in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 397, in run
    mdl(time=self.time, **kwar)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 808, in __call__
    raise Exception("Error simulating " + self.name +
Exception: Error simulating pump of class Pump at time=0.0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 480, in __call__
    self.run(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 1019, in run
    self.run_nom(gen_samp=True, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 1008, in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 620, in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 482, in __call__
    raise Exception("Error simulating "+self.name+" scenario(s)") from e
Exception: Error simulating nominal scenario(s)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/multiprocessing/pool.py", line 125, in worker
    result = (True, func(*args, **kwds))
                    ^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 1052, in exec_fault_sim
    return sim(**args[1])
           ^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 975, in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 482, in __call__
    raise Exception("Error simulating "+self.name+" scenario(s)") from e
Exception: Error simulating rep0_var_0 scenario(s)
"""

The above exception was the direct cause of the following exception:

self = NestedSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_...7_var_7
 - rep8_var_8
 - rep9_var_9
 over 
SampleApproach({'fd': (('all',), {})},
{'fs': (('fault_phases', 'fd'), {})})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:831: in run
    res_list = list(tqdm.tqdm(runner(inputs),
../fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1169: in __iter__
    for obj in iterable:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;multiprocessing.pool.IMapIterator object at 0x7faae5a10250&gt;
timeout = None

    def next(self, timeout=None):
        with self._cond:
            try:
                item = self._items.popleft()
            except IndexError:
                if self._index == self._length:
                    self._pool = None
                    raise StopIteration from None
                self._cond.wait(timeout)
                try:
                    item = self._items.popleft()
                except IndexError:
                    if self._index == self._length:
                        self._pool = None
                        raise StopIteration from None
                    raise TimeoutError from None
    
        success, value = item
        if success:
            return value
&gt;       raise value
E       Exception: Error simulating rep0_var_0 scenario(s)

/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/multiprocessing/pool.py:873: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_nested_sample_save&gt;

    def test_nested_sample_save(self):
        ps = ParameterSample()
        ps.add_variable_replicates([], replicates=10)
        faultdomains = {'fd': (('all', ), {})}
        faultsamples = {'fs': (('fault_phases', 'fd'), {})}
&gt;       self.check_ns_save(self.mdl, ps, faultdomains, faultsamples, "spump_res.npz", "spump_hist.npz", pool=mp.Pool(4))

examples/pump/test_pump_stochastic.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:415: in check_ns_save
    res, hist, apps = prop.nested_sample(mdl, ps, **loc_kwargs)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:312: in nested_sample
    res, hist = sim(**get_sim_call_kwargs(sim, **kwargs))
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = NestedSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_...7_var_7
 - rep8_var_8
 - rep9_var_9
 over 
SampleApproach({'fd': (('all',), {})},
{'fs': (('fault_phases', 'fd'), {})})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nested sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_param_sample_isave" time="0.094"><failure message="Exception: Error simulating parameter sample scenario(s)">multiprocessing.pool.RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 796, in __call__
    self.update_static_behaviors(proptype=proptype)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 728, in update_static_behaviors
    self.execute_static_behaviors()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 734, in execute_static_behaviors
    self.static_behavior()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/pump_stochastic.py", line 116, in static_behavior
    super().static_behavior()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/ex_pump.py", line 436, in static_behavior
    print(a)
          ^
NameError: name 'a' is not defined

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 796, in __call__
    self.update_static_behaviors(proptype=proptype)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 724, in update_static_behaviors
    self.execute_static_behaviors()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 732, in execute_static_behaviors
    self.update_arch_behaviors("static")
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 163, in update_arch_behaviors
    self.prop_static()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 203, in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 808, in __call__
    raise Exception("Error simulating " + self.name +
Exception: Error simulating move_water of class MoveWat at time=0.0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 480, in __call__
    self.run(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 632, in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 397, in run
    mdl(time=self.time, **kwar)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 808, in __call__
    raise Exception("Error simulating " + self.name +
Exception: Error simulating pump of class Pump at time=0.0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/multiprocessing/pool.py", line 125, in worker
    result = (True, func(*args, **kwds))
                    ^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 682, in exec_sim
    return sim()
           ^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 620, in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 482, in __call__
    raise Exception("Error simulating "+self.name+" scenario(s)") from e
Exception: Error simulating rep0_var_0 scenario(s)
"""

The above exception was the direct cause of the following exception:

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:831: in run
    res_list = list(tqdm.tqdm(runner(inputs),
../fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1169: in __iter__
    for obj in iterable:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;multiprocessing.pool.IMapIterator object at 0x7faae5c844d0&gt;
timeout = None

    def next(self, timeout=None):
        with self._cond:
            try:
                item = self._items.popleft()
            except IndexError:
                if self._index == self._length:
                    self._pool = None
                    raise StopIteration from None
                self._cond.wait(timeout)
                try:
                    item = self._items.popleft()
                except IndexError:
                    if self._index == self._length:
                        self._pool = None
                        raise StopIteration from None
                    raise TimeoutError from None
    
        success, value = item
        if success:
            return value
&gt;       raise value
E       Exception: Error simulating rep0_var_0 scenario(s)

/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/multiprocessing/pool.py:873: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_param_sample_isave&gt;

    def test_param_sample_isave(self):
        ps = ParameterSample()
        ps.add_variable_replicates([], replicates=10)
        fnames = ("spump_res", "spump_hist")
&gt;       self.check_ps_isave(self.mdl, ps, *fnames, "npz", pool=mp.Pool(4))

examples/pump/test_pump_stochastic.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:464: in check_ps_isave
    res, hist = prop.parameter_sample(mdl, ps, **loc_kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:120: in parameter_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating parameter sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_param_sample_save" time="0.102"><failure message="Exception: Error simulating parameter sample scenario(s)">multiprocessing.pool.RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 796, in __call__
    self.update_static_behaviors(proptype=proptype)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 728, in update_static_behaviors
    self.execute_static_behaviors()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 734, in execute_static_behaviors
    self.static_behavior()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/pump_stochastic.py", line 116, in static_behavior
    super().static_behavior()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/ex_pump.py", line 436, in static_behavior
    print(a)
          ^
NameError: name 'a' is not defined

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 796, in __call__
    self.update_static_behaviors(proptype=proptype)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 724, in update_static_behaviors
    self.execute_static_behaviors()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 732, in execute_static_behaviors
    self.update_arch_behaviors("static")
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 163, in update_arch_behaviors
    self.prop_static()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 203, in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 808, in __call__
    raise Exception("Error simulating " + self.name +
Exception: Error simulating move_water of class MoveWat at time=0.0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 480, in __call__
    self.run(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 632, in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 397, in run
    mdl(time=self.time, **kwar)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 808, in __call__
    raise Exception("Error simulating " + self.name +
Exception: Error simulating pump of class Pump at time=0.0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/multiprocessing/pool.py", line 125, in worker
    result = (True, func(*args, **kwds))
                    ^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 682, in exec_sim
    return sim()
           ^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 620, in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 482, in __call__
    raise Exception("Error simulating "+self.name+" scenario(s)") from e
Exception: Error simulating rep0_var_0 scenario(s)
"""

The above exception was the direct cause of the following exception:

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:831: in run
    res_list = list(tqdm.tqdm(runner(inputs),
../fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1169: in __iter__
    for obj in iterable:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;multiprocessing.pool.IMapIterator object at 0x7faae5a91ad0&gt;
timeout = None

    def next(self, timeout=None):
        with self._cond:
            try:
                item = self._items.popleft()
            except IndexError:
                if self._index == self._length:
                    self._pool = None
                    raise StopIteration from None
                self._cond.wait(timeout)
                try:
                    item = self._items.popleft()
                except IndexError:
                    if self._index == self._length:
                        self._pool = None
                        raise StopIteration from None
                    raise TimeoutError from None
    
        success, value = item
        if success:
            return value
&gt;       raise value
E       Exception: Error simulating rep0_var_0 scenario(s)

/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/multiprocessing/pool.py:873: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_param_sample_save&gt;

    def test_param_sample_save(self):
        ps = ParameterSample()
        ps.add_variable_replicates([], replicates=10)
&gt;       self.check_ps_save(self.mdl, ps, "stochpump_res.npz", "spump_hist.npz",
                           pool=mp.Pool(4))

examples/pump/test_pump_stochastic.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/common.py:401: in check_ps_save
    res, hist = prop.parameter_sample(mdl, ps, **loc_kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:120: in parameter_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating parameter sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_plot_nested_hists" time="0.168"><failure message="Exception: Error simulating nested sample scenario(s)">multiprocessing.pool.RemoteTraceback: 
"""
Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 796, in __call__
    self.update_static_behaviors(proptype=proptype)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 728, in update_static_behaviors
    self.execute_static_behaviors()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 734, in execute_static_behaviors
    self.static_behavior()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/pump_stochastic.py", line 116, in static_behavior
    super().static_behavior()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/pump/ex_pump.py", line 436, in static_behavior
    print(a)
          ^
NameError: name 'a' is not defined

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 796, in __call__
    self.update_static_behaviors(proptype=proptype)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 724, in update_static_behaviors
    self.execute_static_behaviors()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 732, in execute_static_behaviors
    self.update_arch_behaviors("static")
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 163, in update_arch_behaviors
    self.prop_static()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 203, in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 808, in __call__
    raise Exception("Error simulating " + self.name +
Exception: Error simulating move_water of class MoveWat at time=0.0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 480, in __call__
    self.run(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 632, in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 397, in run
    mdl(time=self.time, **kwar)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 808, in __call__
    raise Exception("Error simulating " + self.name +
Exception: Error simulating pump of class Pump at time=0.0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 480, in __call__
    self.run(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 1019, in run
    self.run_nom(gen_samp=True, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 1008, in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 620, in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 482, in __call__
    raise Exception("Error simulating "+self.name+" scenario(s)") from e
Exception: Error simulating nominal scenario(s)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/multiprocessing/pool.py", line 125, in worker
    result = (True, func(*args, **kwds))
                    ^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 1052, in exec_fault_sim
    return sim(**args[1])
           ^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 975, in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py", line 482, in __call__
    raise Exception("Error simulating "+self.name+" scenario(s)") from e
Exception: Error simulating rep0_delay5_0 scenario(s)
"""

The above exception was the direct cause of the following exception:

self = NestedSimulation of
ParameterSample of scenarios:
 - rep0_delay5_0
 - rep1_delay5_1
 - rep2_delay5_2
 - rep3_delay5_3
...20 total)
 over 
SampleApproach({'fd': (('fault', 'export_water', 'block'), {})},
{'fs': (('fault_phases', 'fd'), {})})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:831: in run
    res_list = list(tqdm.tqdm(runner(inputs),
../fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1169: in __iter__
    for obj in iterable:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;multiprocessing.pool.IMapIterator object at 0x7faae569ffd0&gt;
timeout = None

    def next(self, timeout=None):
        with self._cond:
            try:
                item = self._items.popleft()
            except IndexError:
                if self._index == self._length:
                    self._pool = None
                    raise StopIteration from None
                self._cond.wait(timeout)
                try:
                    item = self._items.popleft()
                except IndexError:
                    if self._index == self._length:
                        self._pool = None
                        raise StopIteration from None
                    raise TimeoutError from None
    
        success, value = item
        if success:
            return value
&gt;       raise value
E       Exception: Error simulating rep0_delay5_0 scenario(s)

/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/multiprocessing/pool.py:873: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_plot_nested_hists&gt;

    def test_plot_nested_hists(self):
        """Qualitative test to show that distributions carry over to fault scenarios
        in a nested approach."""
        mdl = Pump(sp=dict(run_stochastic=True))
        pd = ParameterDomain(PumpParam)
        pd.add_variable("delay")
    
        ps = ParameterSample(pd)
        ps.add_variable_replicates([[5]], replicates=10, name="delay5")
        ps.add_variable_replicates([[15]], replicates=10, name="delay15")
    
        faultdomains = {'fd': (('fault', 'export_water', 'block'), {})}
        faultsamples = {'fs': (('fault_phases', 'fd'), {})}
    
&gt;       ecs, hists, apps = prop.nested_sample(mdl, ps,
                                              showprogress=False,
                                              faultdomains=faultdomains,
                                              faultsamples=faultsamples,
                                              pool=mp.Pool(4))

examples/pump/test_pump_stochastic.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:312: in nested_sample
    res, hist = sim(**get_sim_call_kwargs(sim, **kwargs))
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = NestedSimulation of
ParameterSample of scenarios:
 - rep0_delay5_0
 - rep1_delay5_1
 - rep2_delay5_2
 - rep3_delay5_3
...20 total)
 over 
SampleApproach({'fd': (('fault', 'export_water', 'block'), {})},
{'fs': (('fault_phases', 'fd'), {})})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nested sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_plot_nominal_vals" time="0.074"><failure message="Exception: Error simulating parameter sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
examples/pump/pump_stochastic.py:116: in static_behavior
    super().static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=1869420...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=1869420...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:831: in run
    res_list = list(tqdm.tqdm(runner(inputs),
../fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1169: in __iter__
    for obj in iterable:
fmdtools/sim/propagate.py:682: in exec_sim
    return sim()
           ^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating rep0_var_0 scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_plot_nominal_vals&gt;

    def test_plot_nominal_vals(self):
        """tests nominal_vals_1d"""
        mdl = Pump(sp=dict(run_stochastic=True))
        ps = ParameterSample()
        ps.add_variable_replicates([], replicates=10)
&gt;       res, hist = prop.parameter_sample(mdl, ps,
                                          showprogress=False, warn_faults=False)

examples/pump/test_pump_stochastic.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:120: in parameter_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating parameter sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_plot_nominal_vals_xd" time="0.069"><failure message="Exception: Error simulating parameter sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
examples/pump/pump_stochastic.py:116: in static_behavior
    super().static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=1258442...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=1258442...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_nodelay_0
 - rep1_nodelay_1
 - rep2_nodelay_2
 - rep3_nodelay..._nodelay_4
 - rep5_nodelay_5
 - rep6_nodelay_6
 - rep7_nodelay_7
 - rep8_nodelay_8
 - rep9_nodelay_9
 - ... (300 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:831: in run
    res_list = list(tqdm.tqdm(runner(inputs),
../fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1169: in __iter__
    for obj in iterable:
fmdtools/sim/propagate.py:682: in exec_sim
    return sim()
           ^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating rep0_nodelay_0 scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_plot_nominal_vals_xd&gt;

    def test_plot_nominal_vals_xd(self):
        """tests nominal_vals_2d and nominal_vals_3d"""
        mdl = Pump(sp=dict(run_stochastic=True))
    
        pd = ParameterDomain(PumpParam)
        pd.add_variable("delay")
    
        ps2 = ParameterSample(pd)
        ps2.add_variable_replicates([[0]], replicates=100, name="nodelay")
        ps2.add_variable_replicates([[10]], replicates=100, name="delay10")
        ps2.add_variable_replicates([[15]], replicates=100, name="delay15")
&gt;       nomres, nomhist = prop.parameter_sample(mdl, ps2, warn_faults=False,
                                                showprogress=False)

examples/pump/test_pump_stochastic.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:120: in parameter_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_nodelay_0
 - rep1_nodelay_1
 - rep2_nodelay_2
 - rep3_nodelay..._nodelay_4
 - rep5_nodelay_5
 - rep6_nodelay_6
 - rep7_nodelay_7
 - rep8_nodelay_8
 - rep9_nodelay_9
 - ... (300 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating parameter sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_rand_paramsample_plot" time="0.055"><failure message="Exception: Error simulating parameter sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
examples/pump/pump_stochastic.py:116: in static_behavior
    super().static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=3118855...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=3118855...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
 - ... (20 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:831: in run
    res_list = list(tqdm.tqdm(runner(inputs),
../fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1169: in __iter__
    for obj in iterable:
fmdtools/sim/propagate.py:682: in exec_sim
    return sim()
           ^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating rep0_var_0 scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_rand_paramsample_plot&gt;

    def test_rand_paramsample_plot(self):
        ps = ParameterSample()
        ps.add_variable_replicates([], 20)
        mdl = Pump(sp=dict(run_stochastic=True))
&gt;       res, hist = prop.parameter_sample(mdl, ps, warn_faults=False, showprogress=False)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

examples/pump/test_pump_stochastic.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:120: in parameter_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
 - ... (20 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating parameter sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_run_approach" time="0.066"><failure message="Exception: Error simulating parameter sample scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
examples/pump/pump_stochastic.py:116: in static_behavior
    super().static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=7287214...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(), kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=7287214...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
 - ... (1000 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:831: in run
    res_list = list(tqdm.tqdm(runner(inputs),
../fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1169: in __iter__
    for obj in iterable:
fmdtools/sim/propagate.py:682: in exec_sim
    return sim()
           ^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(), kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating rep0_var_0 scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_run_approach&gt;

    def test_run_approach(self):
        """Test that random behaviors average out."""
        mdl = Pump(track={'fxns': {'move_water': "r"}}, sp=dict(run_stochastic=True))
        ps = ParameterSample()
        ps.add_variable_replicates([], replicates=1000)
&gt;       res, hist = prop.parameter_sample(mdl, ps, showprogress=False,
                                          warn_faults=False,
                                          to_return={})

examples/pump/test_pump_stochastic.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:120: in parameter_sample
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiSimulation of
ParameterSample of scenarios:
 - rep0_var_0
 - rep1_var_1
 - rep2_var_2
 - rep3_var_3
 - rep4_var_4
 - rep5_var_5
 - rep6_var_6
 - rep7_var_7
 - rep8_var_8
 - rep9_var_9
 - ... (1000 total)
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating parameter sample scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_run_safety" time="0.050"><failure message="Exception: Error simulating nominal scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
examples/pump/pump_stochastic.py:116: in static_behavior
    super().static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=1)
FLOW...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:397: in run
    mdl(time=self.time, **kwar)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=1)
FLOW...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 55.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = True, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_run_safety&gt;

    def test_run_safety(self):
        """Test so models with the same seed will run the same/produce same results."""
        for seed in [1, 10, 209840]:
            mdl = Pump(r={'seed': seed}, sp=dict(run_stochastic=True))
&gt;           res_1, hist_1 = prop.nominal(mdl, showprogress=False, warn_faults=False)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

examples/pump/test_pump_stochastic.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:92: in nominal
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- end=SimEvent(to_return={'classify': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_set_seeds" time="0.114" /><testcase classname="examples.pump.test_pump_stochastic.StochasticPumpTests" name="test_stochastic_pdf" time="0.037"><failure message="Exception: Error simulating pump of class Pump at time=0.0">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
examples/pump/pump_stochastic.py:116: in static_behavior
    super().static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=1)
FLOW...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 1, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = &lt;examples.pump.test_pump_stochastic.StochasticPumpTests testMethod=test_stochastic_pdf&gt;

    def test_stochastic_pdf(self):
        """Tests that (1) track_pdf option runs and (2) gives repeated
        probability density results under the same seed(s)"""
        testvals = [8.695319186944289,
                    49.32124529702974,
                    0.31327201999190035,
                    21.386958080811567,
                    3.3311929677576186,
                    9.066120598345039,
                    131.79987407014573,
                    5.81402243889764,
                    19.01081621541118]
        mdl = Pump(sp={'run_stochastic': True, 'track_pdf': True})
        for i in range(1, 10):
            mdl.update_seed(i)
&gt;           mdl(time=i)

examples/pump/test_pump_stochastic.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
- r=Rand(seed=1)
FLOW...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 1, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception</failure></testcase><testcase classname="examples.rover.FaultSample_Use-Cases.ipynb" name="FaultSample_Use-Cases.ipynb" time="24.594" /><testcase classname="examples.rover.HFAC_Analyses.IDETC_Human_Paper_Analysis.ipynb" name="IDETC_Human_Paper_Analysis.ipynb" time="8.572"><failure message="#x1B[31mKeyError#x1B[39m: 'flow'">---------------------------------------------------------------------------
mdl = RoverHuman()
mdl.fxns
#x1B[31m---------------------------------------------------------------------------#x1B[39m
#x1B[31mKeyError#x1B[39m                                  Traceback (most recent call last)
#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[2]#x1B[39m#x1B[32m, line 1#x1B[39m
#x1B[32m----&gt; #x1B[39m#x1B[32m1#x1B[39m mdl = #x1B[43mRoverHuman#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m      2#x1B[39m mdl.fxns

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:109#x1B[39m, in #x1B[36mArchitecture.__init__#x1B[39m#x1B[34m(self, as_copy, h, *args, **kwargs)#x1B[39m
#x1B[32m    107#x1B[39m #x1B[38;5;28mself#x1B[39m._init_flexroles = []
#x1B[32m    108#x1B[39m #x1B[38;5;28mself#x1B[39m.init_flexible_roles(**kwargs)
#x1B[32m--&gt; #x1B[39m#x1B[32m109#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_architecture#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    110#x1B[39m #x1B[38;5;28mself#x1B[39m.build(**kwargs)
#x1B[32m    111#x1B[39m #x1B[38;5;28mself#x1B[39m.mut_kwargs = {role: kwargs.get(role)
#x1B[32m    112#x1B[39m                    #x1B[38;5;28;01mfor#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.get_roles(#x1B[33m'#x1B[39m#x1B[33mcontainer#x1B[39m#x1B[33m'#x1B[39m, with_immutable=#x1B[38;5;28;01mFalse#x1B[39;00m)
#x1B[32m    113#x1B[39m                    #x1B[38;5;28;01mif#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m kwargs}

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/examples/rover/rover_model_human.py:492#x1B[39m, in #x1B[36mRoverHuman.init_architecture#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    487#x1B[39m #x1B[38;5;28mself#x1B[39m.add_fxn(#x1B[33m"#x1B[39m#x1B[33mperception#x1B[39m#x1B[33m"#x1B[39m, Perception, #x1B[33m"#x1B[39m#x1B[33mground#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mpos#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mpos_signal#x1B[39m#x1B[33m'#x1B[39m,
#x1B[32m    488#x1B[39m              #x1B[33m"#x1B[39m#x1B[33mee_12#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mvideo#x1B[39m#x1B[33m"#x1B[39m)
#x1B[32m    489#x1B[39m #x1B[38;5;28mself#x1B[39m.add_fxn(#x1B[33m"#x1B[39m#x1B[33mcommunications#x1B[39m#x1B[33m"#x1B[39m, Communications, #x1B[33m"#x1B[39m#x1B[33mcomms#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mee_12#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mpos_signal#x1B[39m#x1B[33m"#x1B[39m,
#x1B[32m    490#x1B[39m              #x1B[33m"#x1B[39m#x1B[33mvideo#x1B[39m#x1B[33m"#x1B[39m)
#x1B[32m--&gt; #x1B[39m#x1B[32m492#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43madd_fxn#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43moperator#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mOperator#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43mswitch#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43mcomms#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43mground#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43mpsfs#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mp#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mp#x1B[49m#x1B[43m.#x1B[49m#x1B[43mpsfs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    493#x1B[39m #x1B[38;5;28mself#x1B[39m.add_fxn(#x1B[33m"#x1B[39m#x1B[33mplan_path#x1B[39m#x1B[33m"#x1B[39m, PlanPath, #x1B[33m"#x1B[39m#x1B[33mvideo#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mpos_signal#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mground#x1B[39m#x1B[33m"#x1B[39m,
#x1B[32m    494#x1B[39m              #x1B[33m"#x1B[39m#x1B[33mauto_control#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mfault_sig#x1B[39m#x1B[33m"#x1B[39m, p=#x1B[38;5;28mself#x1B[39m.p.correction)
#x1B[32m    495#x1B[39m #x1B[38;5;28mself#x1B[39m.add_fxn(#x1B[33m"#x1B[39m#x1B[33moverride#x1B[39m#x1B[33m"#x1B[39m, Override, #x1B[33m"#x1B[39m#x1B[33mcomms#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mee_5#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mmotor_control#x1B[39m#x1B[33m"#x1B[39m,
#x1B[32m    496#x1B[39m              #x1B[33m"#x1B[39m#x1B[33mauto_control#x1B[39m#x1B[33m"#x1B[39m)

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/function.py:508#x1B[39m, in #x1B[36mFunctionArchitecture.add_fxn#x1B[39m#x1B[34m(self, name, fclass, *flownames, **fkwargs)#x1B[39m
#x1B[32m    490#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34madd_fxn#x1B[39m(#x1B[38;5;28mself#x1B[39m, name, fclass, *flownames, **fkwargs):
#x1B[32m    491#x1B[39m #x1B[38;5;250m    #x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m    492#x1B[39m #x1B[33;03m    Instantiate a given function in the model.#x1B[39;00m
#x1B[32m    493#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m    506#x1B[39m #x1B[33;03m        Parameters to send to __init__ method of the Function superclass#x1B[39;00m
#x1B[32m    507#x1B[39m #x1B[33;03m    """#x1B[39;00m
#x1B[32m--&gt; #x1B[39m#x1B[32m508#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43madd_sim#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mfxns#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mfclass#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43mflownames#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mfkwargs#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:393#x1B[39m, in #x1B[36mArchitecture.add_sim#x1B[39m#x1B[34m(self, flex_role, name, simclass, *flownames, **kwargs)#x1B[39m
#x1B[32m    376#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m    377#x1B[39m #x1B[33;03mAdd a Simulable to the given flex_role.#x1B[39;00m
#x1B[32m    378#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m    390#x1B[39m #x1B[33;03m    Flows, dicts for non-default values to p, s, etc.#x1B[39;00m
#x1B[32m    391#x1B[39m #x1B[33;03m"""#x1B[39;00m
#x1B[32m    392#x1B[39m flows = #x1B[38;5;28mself#x1B[39m.get_flows(*flownames, all_if_empty=#x1B[38;5;28;01mFalse#x1B[39;00m)
#x1B[32m--&gt; #x1B[39m#x1B[32m393#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43madd_flex_role_obj#x1B[49m#x1B[43m(#x1B[49m#x1B[43mflex_role#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    394#x1B[39m #x1B[43m                       #x1B[49m#x1B[43mobjclass#x1B[49m#x1B[43m=#x1B[49m#x1B[43msimclass#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mflows#x1B[49m#x1B[43m=#x1B[49m#x1B[43mflows#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    395#x1B[39m #x1B[38;5;28;01mfor#x1B[39;00m flowname #x1B[38;5;129;01min#x1B[39;00m flownames:
#x1B[32m    396#x1B[39m     #x1B[38;5;28mself#x1B[39m._simflows.append((name, flowname))

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:319#x1B[39m, in #x1B[36mArchitecture.add_flex_role_obj#x1B[39m#x1B[34m(self, flex_role, name, objclass, use_copy, **kwargs)#x1B[39m
#x1B[32m    317#x1B[39m track = get_sub_include(name, get_sub_include(flex_role, #x1B[38;5;28mself#x1B[39m.track))
#x1B[32m    318#x1B[39m kwargs = #x1B[38;5;28mself#x1B[39m.get_flex_role_kwargs(objclass, **kwargs)
#x1B[32m--&gt; #x1B[39m#x1B[32m319#x1B[39m obj = #x1B[43minit_obj#x1B[49m#x1B[43m(#x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mobjclass#x1B[49m#x1B[43m=#x1B[49m#x1B[43mobjclass#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m=#x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    320#x1B[39m #x1B[43m               #x1B[49m#x1B[43mas_copy#x1B[49m#x1B[43m=#x1B[49m#x1B[43mas_copy#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mroot#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mget_full_name#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m+#x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43m.#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m+#x1B[49m#x1B[43mflex_role#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    321#x1B[39m #x1B[43m               #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    323#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(obj, #x1B[33m'#x1B[39m#x1B[33mh#x1B[39m#x1B[33m'#x1B[39m) #x1B[38;5;129;01mand#x1B[39;00m obj.h:
#x1B[32m    324#x1B[39m     hist = obj.h

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:1183#x1B[39m, in #x1B[36minit_obj#x1B[39m#x1B[34m(name, objclass, track, as_copy, **kwargs)#x1B[39m
#x1B[32m   1181#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m   1182#x1B[39m     #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m-&gt; #x1B[39m#x1B[32m1183#x1B[39m         fl = #x1B[43mobjclass#x1B[49m#x1B[43m(#x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m=#x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m   1184#x1B[39m     #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mTypeError#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m   1185#x1B[39m         #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mTypeError#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mPoorly specified class #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(objclass) +
#x1B[32m   1186#x1B[39m                         #x1B[33m"#x1B[39m#x1B[33m (or poor arguments) #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(kwargs)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/function.py:90#x1B[39m, in #x1B[36mFunction.__init__#x1B[39m#x1B[34m(self, name, args_f, **kwargs)#x1B[39m
#x1B[32m     81#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34m__init__#x1B[39m(#x1B[38;5;28mself#x1B[39m, name=#x1B[38;5;28;01mNone#x1B[39;00m, args_f=#x1B[38;5;28mdict#x1B[39m(), **kwargs):
#x1B[32m     82#x1B[39m #x1B[38;5;250m    #x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m     83#x1B[39m #x1B[33;03m    Instantiate the function superclass with the relevant parameters.#x1B[39;00m
#x1B[32m     84#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m     88#x1B[39m #x1B[33;03m        arguments to pass to custom __init__ function.#x1B[39;00m
#x1B[32m     89#x1B[39m #x1B[33;03m    """#x1B[39;00m
#x1B[32m---&gt; #x1B[39m#x1B[32m90#x1B[39m     #x1B[38;5;28;43msuper#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__init__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m     91#x1B[39m     #x1B[38;5;28mself#x1B[39m.args_f = args_f
#x1B[32m     92#x1B[39m     #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mbehavior#x1B[39m#x1B[33m'#x1B[39m):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:864#x1B[39m, in #x1B[36mBlock.__init__#x1B[39m#x1B[34m(self, name, flows, h, **kwargs)#x1B[39m
#x1B[32m    862#x1B[39m #x1B[38;5;66;03m# send flows from block level to arch level#x1B[39;00m
#x1B[32m    863#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[33m'#x1B[39m#x1B[33march#x1B[39m#x1B[33m'#x1B[39m #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.roletypes:
#x1B[32m--&gt; #x1B[39m#x1B[32m864#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_roletypes#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43march#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mcreate_arch_kwargs#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    865#x1B[39m #x1B[38;5;28mself#x1B[39m.mut_kwargs = {role: kwargs.get(role)
#x1B[32m    866#x1B[39m                    #x1B[38;5;28;01mfor#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.get_roles(with_flex=#x1B[38;5;28;01mFalse#x1B[39;00m,
#x1B[32m    867#x1B[39m                                               with_immutable=#x1B[38;5;28;01mFalse#x1B[39;00m)
#x1B[32m    868#x1B[39m                    #x1B[38;5;28;01mif#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m kwargs}
#x1B[32m    869#x1B[39m #x1B[38;5;28mself#x1B[39m.check_flows(flows=flows)

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:345#x1B[39m, in #x1B[36mBaseObject.init_roletypes#x1B[39m#x1B[34m(self, initializer, *roletypes, **kwargs)#x1B[39m
#x1B[32m    342#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m roletype #x1B[38;5;129;01mnot#x1B[39;00m #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.roletypes:
#x1B[32m    343#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mRoletype: #x1B[39m#x1B[33m"#x1B[39m + roletype + #x1B[33m"#x1B[39m#x1B[33m not in class variable#x1B[39m#x1B[33m"#x1B[39m +
#x1B[32m    344#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m self.roletypes: #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.roletypes))
#x1B[32m--&gt; #x1B[39m#x1B[32m345#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_roles#x1B[49m#x1B[43m(#x1B[49m#x1B[43mroletype#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43minitializer#x1B[49m#x1B[43m=#x1B[49m#x1B[43minitializer#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:394#x1B[39m, in #x1B[36mBaseObject.init_roles#x1B[39m#x1B[34m(self, roletype, initializer, **kwargs)#x1B[39m
#x1B[32m    392#x1B[39m     obj_args[#x1B[33m'#x1B[39m#x1B[33mtrack#x1B[39m#x1B[33m'#x1B[39m] = get_sub_include(rolename, #x1B[38;5;28mself#x1B[39m.track)
#x1B[32m    393#x1B[39m #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m394#x1B[39m     obj = #x1B[43mobj_initializer#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mobj_args#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    395#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mAttributeError#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m ae:
#x1B[32m    396#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mProblem initializing #x1B[39m#x1B[33m"#x1B[39m + roletype + #x1B[33m"#x1B[39m#x1B[33m_#x1B[39m#x1B[33m"#x1B[39m + rolename
#x1B[32m    397#x1B[39m                     + #x1B[33m"#x1B[39m#x1B[33m: #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(initializer)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01mae#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/action.py:260#x1B[39m, in #x1B[36mActionArchitecture.__init__#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    258#x1B[39m #x1B[38;5;28mself#x1B[39m.flow_graph = nx.DiGraph()
#x1B[32m    259#x1B[39m #x1B[38;5;28mself#x1B[39m.active_actions = #x1B[38;5;28mset#x1B[39m()
#x1B[32m--&gt; #x1B[39m#x1B[32m260#x1B[39m #x1B[43mArchitecture#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__init__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:108#x1B[39m, in #x1B[36mArchitecture.__init__#x1B[39m#x1B[34m(self, as_copy, h, *args, **kwargs)#x1B[39m
#x1B[32m    106#x1B[39m #x1B[38;5;28mself#x1B[39m.init_hist(h=h)
#x1B[32m    107#x1B[39m #x1B[38;5;28mself#x1B[39m._init_flexroles = []
#x1B[32m--&gt; #x1B[39m#x1B[32m108#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_flexible_roles#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    109#x1B[39m #x1B[38;5;28mself#x1B[39m.init_architecture(**kwargs)
#x1B[32m    110#x1B[39m #x1B[38;5;28mself#x1B[39m.build(**kwargs)

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:255#x1B[39m, in #x1B[36mArchitecture.init_flexible_roles#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    253#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mNo role argument #x1B[39m#x1B[33m"#x1B[39m+role+#x1B[33m"#x1B[39m#x1B[33m to copy.#x1B[39m#x1B[33m"#x1B[39m)
#x1B[32m    254#x1B[39m #x1B[38;5;28;01melif#x1B[39;00m rname #x1B[38;5;129;01min#x1B[39;00m kwargs:
#x1B[32m--&gt; #x1B[39m#x1B[32m255#x1B[39m     #x1B[38;5;28msetattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, rname, {**#x1B[43mkwargs#x1B[49m#x1B[43m[#x1B[49m#x1B[43mrole#x1B[49m#x1B[43m]#x1B[49m})
#x1B[32m    256#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m    257#x1B[39m     #x1B[38;5;28msetattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, rname, #x1B[38;5;28mdict#x1B[39m())

#x1B[31mKeyError#x1B[39m: 'flow'</failure></testcase><testcase classname="examples.rover.Model_Structure_Visualization_Tutorial.ipynb" name="Model_Structure_Visualization_Tutorial.ipynb" time="8.238"><failure message="#x1B[31mException#x1B[39m: Local timestep: 0.5 doesn't line up with global timestep: 1.0">---------------------------------------------------------------------------
mdl = Rover()
mtg = FunctionArchitectureTypeGraph(mdl)
fig, ax = mtg.draw()
#x1B[31m---------------------------------------------------------------------------#x1B[39m
#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[10]#x1B[39m#x1B[32m, line 1#x1B[39m
#x1B[32m----&gt; #x1B[39m#x1B[32m1#x1B[39m mdl = #x1B[43mRover#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m      2#x1B[39m mtg = FunctionArchitectureTypeGraph(mdl)
#x1B[32m      3#x1B[39m fig, ax = mtg.draw()

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:109#x1B[39m, in #x1B[36mArchitecture.__init__#x1B[39m#x1B[34m(self, as_copy, h, *args, **kwargs)#x1B[39m
#x1B[32m    107#x1B[39m #x1B[38;5;28mself#x1B[39m._init_flexroles = []
#x1B[32m    108#x1B[39m #x1B[38;5;28mself#x1B[39m.init_flexible_roles(**kwargs)
#x1B[32m--&gt; #x1B[39m#x1B[32m109#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_architecture#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    110#x1B[39m #x1B[38;5;28mself#x1B[39m.build(**kwargs)
#x1B[32m    111#x1B[39m #x1B[38;5;28mself#x1B[39m.mut_kwargs = {role: kwargs.get(role)
#x1B[32m    112#x1B[39m                    #x1B[38;5;28;01mfor#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.get_roles(#x1B[33m'#x1B[39m#x1B[33mcontainer#x1B[39m#x1B[33m'#x1B[39m, with_immutable=#x1B[38;5;28;01mFalse#x1B[39;00m)
#x1B[32m    113#x1B[39m                    #x1B[38;5;28;01mif#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m kwargs}

#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[8]#x1B[39m#x1B[32m, line 31#x1B[39m, in #x1B[36mRover.init_architecture#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m     28#x1B[39m #x1B[38;5;28mself#x1B[39m.add_flow(#x1B[33m'#x1B[39m#x1B[33mcomms#x1B[39m#x1B[33m'#x1B[39m, Flow) #x1B[38;5;66;03m#{'x':0,'y':0}#x1B[39;00m
#x1B[32m     30#x1B[39m #x1B[38;5;28mself#x1B[39m.add_fxn(#x1B[33m"#x1B[39m#x1B[33mcontrol_rover#x1B[39m#x1B[33m"#x1B[39m, ControlRover, #x1B[33m"#x1B[39m#x1B[33mcontrol#x1B[39m#x1B[33m"#x1B[39m)
#x1B[32m---&gt; #x1B[39m#x1B[32m31#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43madd_fxn#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43mstore_energy#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mStoreEnergy#x1B[49m#x1B[43m,#x1B[49m#x1B[43m  #x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43mee#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43mcontrol#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m)#x1B[49m
#x1B[32m     32#x1B[39m #x1B[38;5;28mself#x1B[39m.add_fxn(#x1B[33m"#x1B[39m#x1B[33mmove_rover#x1B[39m#x1B[33m"#x1B[39m, MoveRover, #x1B[33m"#x1B[39m#x1B[33mground#x1B[39m#x1B[33m"#x1B[39m,#x1B[33m"#x1B[39m#x1B[33mee#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mcontrol#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mforce#x1B[39m#x1B[33m"#x1B[39m)
#x1B[32m     33#x1B[39m #x1B[38;5;28mself#x1B[39m.add_fxn(#x1B[33m"#x1B[39m#x1B[33mview_ground#x1B[39m#x1B[33m"#x1B[39m, ViewGround, #x1B[33m"#x1B[39m#x1B[33mground#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mee#x1B[39m#x1B[33m"#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mvideo#x1B[39m#x1B[33m"#x1B[39m,#x1B[33m"#x1B[39m#x1B[33mforce#x1B[39m#x1B[33m"#x1B[39m)

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/function.py:508#x1B[39m, in #x1B[36mFunctionArchitecture.add_fxn#x1B[39m#x1B[34m(self, name, fclass, *flownames, **fkwargs)#x1B[39m
#x1B[32m    490#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34madd_fxn#x1B[39m(#x1B[38;5;28mself#x1B[39m, name, fclass, *flownames, **fkwargs):
#x1B[32m    491#x1B[39m #x1B[38;5;250m    #x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m    492#x1B[39m #x1B[33;03m    Instantiate a given function in the model.#x1B[39;00m
#x1B[32m    493#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m    506#x1B[39m #x1B[33;03m        Parameters to send to __init__ method of the Function superclass#x1B[39;00m
#x1B[32m    507#x1B[39m #x1B[33;03m    """#x1B[39;00m
#x1B[32m--&gt; #x1B[39m#x1B[32m508#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43madd_sim#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mfxns#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mfclass#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43mflownames#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mfkwargs#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:393#x1B[39m, in #x1B[36mArchitecture.add_sim#x1B[39m#x1B[34m(self, flex_role, name, simclass, *flownames, **kwargs)#x1B[39m
#x1B[32m    376#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m    377#x1B[39m #x1B[33;03mAdd a Simulable to the given flex_role.#x1B[39;00m
#x1B[32m    378#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m    390#x1B[39m #x1B[33;03m    Flows, dicts for non-default values to p, s, etc.#x1B[39;00m
#x1B[32m    391#x1B[39m #x1B[33;03m"""#x1B[39;00m
#x1B[32m    392#x1B[39m flows = #x1B[38;5;28mself#x1B[39m.get_flows(*flownames, all_if_empty=#x1B[38;5;28;01mFalse#x1B[39;00m)
#x1B[32m--&gt; #x1B[39m#x1B[32m393#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43madd_flex_role_obj#x1B[49m#x1B[43m(#x1B[49m#x1B[43mflex_role#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    394#x1B[39m #x1B[43m                       #x1B[49m#x1B[43mobjclass#x1B[49m#x1B[43m=#x1B[49m#x1B[43msimclass#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mflows#x1B[49m#x1B[43m=#x1B[49m#x1B[43mflows#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    395#x1B[39m #x1B[38;5;28;01mfor#x1B[39;00m flowname #x1B[38;5;129;01min#x1B[39;00m flownames:
#x1B[32m    396#x1B[39m     #x1B[38;5;28mself#x1B[39m._simflows.append((name, flowname))

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:319#x1B[39m, in #x1B[36mArchitecture.add_flex_role_obj#x1B[39m#x1B[34m(self, flex_role, name, objclass, use_copy, **kwargs)#x1B[39m
#x1B[32m    317#x1B[39m track = get_sub_include(name, get_sub_include(flex_role, #x1B[38;5;28mself#x1B[39m.track))
#x1B[32m    318#x1B[39m kwargs = #x1B[38;5;28mself#x1B[39m.get_flex_role_kwargs(objclass, **kwargs)
#x1B[32m--&gt; #x1B[39m#x1B[32m319#x1B[39m obj = #x1B[43minit_obj#x1B[49m#x1B[43m(#x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mobjclass#x1B[49m#x1B[43m=#x1B[49m#x1B[43mobjclass#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m=#x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    320#x1B[39m #x1B[43m               #x1B[49m#x1B[43mas_copy#x1B[49m#x1B[43m=#x1B[49m#x1B[43mas_copy#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mroot#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mget_full_name#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m+#x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43m.#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m+#x1B[49m#x1B[43mflex_role#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    321#x1B[39m #x1B[43m               #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    323#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(obj, #x1B[33m'#x1B[39m#x1B[33mh#x1B[39m#x1B[33m'#x1B[39m) #x1B[38;5;129;01mand#x1B[39;00m obj.h:
#x1B[32m    324#x1B[39m     hist = obj.h

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:1183#x1B[39m, in #x1B[36minit_obj#x1B[39m#x1B[34m(name, objclass, track, as_copy, **kwargs)#x1B[39m
#x1B[32m   1181#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m   1182#x1B[39m     #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m-&gt; #x1B[39m#x1B[32m1183#x1B[39m         fl = #x1B[43mobjclass#x1B[49m#x1B[43m(#x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m=#x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m   1184#x1B[39m     #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mTypeError#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m   1185#x1B[39m         #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mTypeError#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mPoorly specified class #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(objclass) +
#x1B[32m   1186#x1B[39m                         #x1B[33m"#x1B[39m#x1B[33m (or poor arguments) #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(kwargs)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/function.py:90#x1B[39m, in #x1B[36mFunction.__init__#x1B[39m#x1B[34m(self, name, args_f, **kwargs)#x1B[39m
#x1B[32m     81#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34m__init__#x1B[39m(#x1B[38;5;28mself#x1B[39m, name=#x1B[38;5;28;01mNone#x1B[39;00m, args_f=#x1B[38;5;28mdict#x1B[39m(), **kwargs):
#x1B[32m     82#x1B[39m #x1B[38;5;250m    #x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m     83#x1B[39m #x1B[33;03m    Instantiate the function superclass with the relevant parameters.#x1B[39;00m
#x1B[32m     84#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m     88#x1B[39m #x1B[33;03m        arguments to pass to custom __init__ function.#x1B[39;00m
#x1B[32m     89#x1B[39m #x1B[33;03m    """#x1B[39;00m
#x1B[32m---&gt; #x1B[39m#x1B[32m90#x1B[39m     #x1B[38;5;28;43msuper#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__init__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m     91#x1B[39m     #x1B[38;5;28mself#x1B[39m.args_f = args_f
#x1B[32m     92#x1B[39m     #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mbehavior#x1B[39m#x1B[33m'#x1B[39m):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:860#x1B[39m, in #x1B[36mBlock.__init__#x1B[39m#x1B[34m(self, name, flows, h, **kwargs)#x1B[39m
#x1B[32m    857#x1B[39m     flows = {#x1B[38;5;28mself#x1B[39m.flownames.get(fn, fn): flow #x1B[38;5;28;01mfor#x1B[39;00m fn, flow #x1B[38;5;129;01min#x1B[39;00m flows.items()}
#x1B[32m    858#x1B[39m flows = {**flows}
#x1B[32m--&gt; #x1B[39m#x1B[32m860#x1B[39m #x1B[43mSimulable#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__init__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mroletypes#x1B[49m#x1B[43m=#x1B[49m#x1B[43m[#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mcontainer#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mflow#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m]#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    861#x1B[39m #x1B[43m                   #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mflows#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    862#x1B[39m #x1B[38;5;66;03m# send flows from block level to arch level#x1B[39;00m
#x1B[32m    863#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[33m'#x1B[39m#x1B[33march#x1B[39m#x1B[33m'#x1B[39m #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.roletypes:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:226#x1B[39m, in #x1B[36mSimulable.__init__#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    215#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34m__init__#x1B[39m(#x1B[38;5;28mself#x1B[39m, **kwargs):
#x1B[32m    216#x1B[39m #x1B[38;5;250m    #x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m    217#x1B[39m #x1B[33;03m    Instantiate internal Simulable attributes.#x1B[39;00m
#x1B[32m    218#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m    224#x1B[39m #x1B[33;03m        Keyword arguments to BaseObject#x1B[39;00m
#x1B[32m    225#x1B[39m #x1B[33;03m    """#x1B[39;00m
#x1B[32m--&gt; #x1B[39m#x1B[32m226#x1B[39m     #x1B[43mBaseObject#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__init__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    227#x1B[39m     #x1B[38;5;28mself#x1B[39m.set_time()

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:246#x1B[39m, in #x1B[36mBaseObject.__init__#x1B[39m#x1B[34m(self, name, roletypes, track, root, **kwargs)#x1B[39m
#x1B[32m    244#x1B[39m #x1B[38;5;28mself#x1B[39m.init_indicators()
#x1B[32m    245#x1B[39m #x1B[38;5;28mself#x1B[39m.init_track(track)
#x1B[32m--&gt; #x1B[39m#x1B[32m246#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_roletypes#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43mroletypes#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    247#x1B[39m #x1B[38;5;28mself#x1B[39m.check_slots()
#x1B[32m    248#x1B[39m #x1B[38;5;28mself#x1B[39m.mutables = ()

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:345#x1B[39m, in #x1B[36mBaseObject.init_roletypes#x1B[39m#x1B[34m(self, initializer, *roletypes, **kwargs)#x1B[39m
#x1B[32m    342#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m roletype #x1B[38;5;129;01mnot#x1B[39;00m #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.roletypes:
#x1B[32m    343#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mRoletype: #x1B[39m#x1B[33m"#x1B[39m + roletype + #x1B[33m"#x1B[39m#x1B[33m not in class variable#x1B[39m#x1B[33m"#x1B[39m +
#x1B[32m    344#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m self.roletypes: #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.roletypes))
#x1B[32m--&gt; #x1B[39m#x1B[32m345#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_roles#x1B[49m#x1B[43m(#x1B[49m#x1B[43mroletype#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43minitializer#x1B[49m#x1B[43m=#x1B[49m#x1B[43minitializer#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:394#x1B[39m, in #x1B[36mBaseObject.init_roles#x1B[39m#x1B[34m(self, roletype, initializer, **kwargs)#x1B[39m
#x1B[32m    392#x1B[39m     obj_args[#x1B[33m'#x1B[39m#x1B[33mtrack#x1B[39m#x1B[33m'#x1B[39m] = get_sub_include(rolename, #x1B[38;5;28mself#x1B[39m.track)
#x1B[32m    393#x1B[39m #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m394#x1B[39m     obj = #x1B[43mobj_initializer#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mobj_args#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    395#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mAttributeError#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m ae:
#x1B[32m    396#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mProblem initializing #x1B[39m#x1B[33m"#x1B[39m + roletype + #x1B[33m"#x1B[39m#x1B[33m_#x1B[39m#x1B[33m"#x1B[39m + rolename
#x1B[32m    397#x1B[39m                     + #x1B[33m"#x1B[39m#x1B[33m: #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(initializer)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01mae#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/container/time.py:101#x1B[39m, in #x1B[36mTime.__init__#x1B[39m#x1B[34m(self, *args, **kwargs)#x1B[39m
#x1B[32m     99#x1B[39m #x1B[38;5;28;01mfor#x1B[39;00m timername #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.timernames:
#x1B[32m    100#x1B[39m     #x1B[38;5;28mself#x1B[39m.timers[timername] = Timer(timername)
#x1B[32m--&gt; #x1B[39m#x1B[32m101#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mset_timestep#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/container/time.py:150#x1B[39m, in #x1B[36mTime.set_timestep#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    148#x1B[39m     dt = local_tstep
#x1B[32m    149#x1B[39m     #x1B[38;5;28;01mif#x1B[39;00m (dt &lt; global_tstep #x1B[38;5;129;01mand#x1B[39;00m global_tstep % dt) #x1B[38;5;129;01mor#x1B[39;00m dt % global_tstep:
#x1B[32m--&gt; #x1B[39m#x1B[32m150#x1B[39m         #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mLocal timestep: #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(dt) +
#x1B[32m    151#x1B[39m                         #x1B[33m"#x1B[39m#x1B[33m doesn#x1B[39m#x1B[33m'#x1B[39m#x1B[33mt line up with global timestep: #x1B[39m#x1B[33m"#x1B[39m +
#x1B[32m    152#x1B[39m                         #x1B[38;5;28mstr#x1B[39m(global_tstep))
#x1B[32m    153#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m    154#x1B[39m     dt = global_tstep

#x1B[31mException#x1B[39m: Local timestep: 0.5 doesn't line up with global timestep: 1.0</failure></testcase><testcase classname="examples.rover.Rover_Setup_Notebook.ipynb" name="Rover_Setup_Notebook.ipynb" time="107.533" /><testcase classname="examples.rover.degradation_modelling.Degradation_Modelling_Notebook.ipynb" name="Degradation_Modelling_Notebook.ipynb" time="169.606"><failure message="#x1B[31mException#x1B[39m: Error simulating nested sample scenario(s)">---------------------------------------------------------------------------
fd = {'drive_faults':  (('faults', ('drive', 'elec_open'), ('drive', 'stuck'), ('drive', 'stuck_left'), ('drive', 'stuck_right')), {})}
fs = {'drive_faults': (('fault_phases', 'drive_faults', "start"), {})}
ec_nest, hist_nest, app_nest = prop.nested_sample(mdl, phs, faultdomains=fd, faultsamples=fs, pool=mp.Pool(5))

#x1B[31m---------------------------------------------------------------------------#x1B[39m
#x1B[31mRemoteTraceback#x1B[39m                           Traceback (most recent call last)
#x1B[31mRemoteTraceback#x1B[39m: 
"""
Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py", line 828, in run
    inputs = self.gen_inputs(scenlist)
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py", line 1039, in gen_inputs
    return [({**sim_kwar, 'scen': scen, 'mdl': self.mdls[scen.time].copy()},
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py", line 1039, in &lt;listcomp&gt;
    return [({**sim_kwar, 'scen': scen, 'mdl': self.mdls[scen.time].copy()},
                                               ~~~~~~~~~^^^^^^^^^^^
KeyError: 15.0

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py", line 480, in __call__
    self.run(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py", line 1027, in run
    super().run(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py", line 830, in run
    raise Exception("Not enough models: "+str(self.mdls)) from e
Exception: Not enough models: {}

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/multiprocessing/pool.py", line 125, in worker
    result = (True, func(*args, **kwds))
                    ^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py", line 1052, in exec_fault_sim
    return sim(**args[1])
           ^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py", line 975, in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py", line 482, in __call__
    raise Exception("Error simulating "+self.name+" scenario(s)") from e
Exception: Error simulating hist_2 scenario(s)
"""

The above exception was the direct cause of the following exception:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:480#x1B[39m, in #x1B[36mBaseSimulation.__call__#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    479#x1B[39m #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m480#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mrun#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    481#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:831#x1B[39m, in #x1B[36mMultiSimulation.run#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    830#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mNot enough models: #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.mdls)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m
#x1B[32m--&gt; #x1B[39m#x1B[32m831#x1B[39m res_list = #x1B[38;5;28;43mlist#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43mtqdm#x1B[49m#x1B[43m.#x1B[49m#x1B[43mtqdm#x1B[49m#x1B[43m(#x1B[49m#x1B[43mrunner#x1B[49m#x1B[43m(#x1B[49m#x1B[43minputs#x1B[49m#x1B[43m)#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    832#x1B[39m #x1B[43m                          #x1B[49m#x1B[43mtotal#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mlen#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43minputs#x1B[49m#x1B[43m)#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    833#x1B[39m #x1B[43m                          #x1B[49m#x1B[43mdisable#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;129;43;01mnot#x1B[39;49;00m#x1B[43m #x1B[49m#x1B[43m(#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mshowprogress#x1B[49m#x1B[43m)#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    834#x1B[39m #x1B[43m                          #x1B[49m#x1B[43mdesc#x1B[49m#x1B[43m=#x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43mSCENARIOS COMPLETE#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m)#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    835#x1B[39m #x1B[38;5;28;01mfor#x1B[39;00m i, scen #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28menumerate#x1B[39m(scenlist):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/tqdm/std.py:1181#x1B[39m, in #x1B[36mtqdm.__iter__#x1B[39m#x1B[34m(self)#x1B[39m
#x1B[32m   1180#x1B[39m #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m-&gt; #x1B[39m#x1B[32m1181#x1B[39m #x1B[43m    #x1B[49m#x1B[38;5;28;43;01mfor#x1B[39;49;00m#x1B[43m #x1B[49m#x1B[43mobj#x1B[49m#x1B[43m #x1B[49m#x1B[38;5;129;43;01min#x1B[39;49;00m#x1B[43m #x1B[49m#x1B[43miterable#x1B[49m#x1B[43m:#x1B[49m
#x1B[32m   1182#x1B[39m #x1B[43m        #x1B[49m#x1B[38;5;28;43;01myield#x1B[39;49;00m#x1B[43m #x1B[49m#x1B[43mobj#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/multiprocessing/pool.py:873#x1B[39m, in #x1B[36mIMapIterator.next#x1B[39m#x1B[34m(self, timeout)#x1B[39m
#x1B[32m    872#x1B[39m     #x1B[38;5;28;01mreturn#x1B[39;00m value
#x1B[32m--&gt; #x1B[39m#x1B[32m873#x1B[39m #x1B[38;5;28;01mraise#x1B[39;00m value

#x1B[31mException#x1B[39m: Error simulating hist_2 scenario(s)

The above exception was the direct cause of the following exception:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[32]#x1B[39m#x1B[32m, line 3#x1B[39m
#x1B[32m      1#x1B[39m fd = {#x1B[33m'#x1B[39m#x1B[33mdrive_faults#x1B[39m#x1B[33m'#x1B[39m:  ((#x1B[33m'#x1B[39m#x1B[33mfaults#x1B[39m#x1B[33m'#x1B[39m, (#x1B[33m'#x1B[39m#x1B[33mdrive#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33melec_open#x1B[39m#x1B[33m'#x1B[39m), (#x1B[33m'#x1B[39m#x1B[33mdrive#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mstuck#x1B[39m#x1B[33m'#x1B[39m), (#x1B[33m'#x1B[39m#x1B[33mdrive#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mstuck_left#x1B[39m#x1B[33m'#x1B[39m), (#x1B[33m'#x1B[39m#x1B[33mdrive#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mstuck_right#x1B[39m#x1B[33m'#x1B[39m)), {})}
#x1B[32m      2#x1B[39m fs = {#x1B[33m'#x1B[39m#x1B[33mdrive_faults#x1B[39m#x1B[33m'#x1B[39m: ((#x1B[33m'#x1B[39m#x1B[33mfault_phases#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mdrive_faults#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m"#x1B[39m#x1B[33mstart#x1B[39m#x1B[33m"#x1B[39m), {})}
#x1B[32m----&gt; #x1B[39m#x1B[32m3#x1B[39m ec_nest, hist_nest, app_nest = #x1B[43mprop#x1B[49m#x1B[43m.#x1B[49m#x1B[43mnested_sample#x1B[49m#x1B[43m(#x1B[49m#x1B[43mmdl#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mphs#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mfaultdomains#x1B[49m#x1B[43m=#x1B[49m#x1B[43mfd#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mfaultsamples#x1B[49m#x1B[43m=#x1B[49m#x1B[43mfs#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mpool#x1B[49m#x1B[43m=#x1B[49m#x1B[43mmp#x1B[49m#x1B[43m.#x1B[49m#x1B[43mPool#x1B[49m#x1B[43m(#x1B[49m#x1B[32;43m5#x1B[39;49m#x1B[43m)#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:312#x1B[39m, in #x1B[36mnested_sample#x1B[39m#x1B[34m(mdl, ps, **kwargs)#x1B[39m
#x1B[32m    284#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m    285#x1B[39m #x1B[33;03mSimulate a set of fault scenarios within a ParameterSample.#x1B[39;00m
#x1B[32m    286#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m    308#x1B[39m #x1B[33;03m    scenario with structure {'nomscen1': app1}#x1B[39;00m
#x1B[32m    309#x1B[39m #x1B[33;03m"""#x1B[39;00m
#x1B[32m    310#x1B[39m sim = NestedSimulation(mdl=mdl, samp=ps, name=#x1B[33m"#x1B[39m#x1B[33mnested sample#x1B[39m#x1B[33m"#x1B[39m,
#x1B[32m    311#x1B[39m                        **filter_kwargs(NestedSimulation, **kwargs))
#x1B[32m--&gt; #x1B[39m#x1B[32m312#x1B[39m res, hist = #x1B[43msim#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mget_sim_call_kwargs#x1B[49m#x1B[43m(#x1B[49m#x1B[43msim#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    313#x1B[39m #x1B[38;5;28;01mreturn#x1B[39;00m res, hist, sim.apps

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/sim/propagate.py:482#x1B[39m, in #x1B[36mBaseSimulation.__call__#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    480#x1B[39m     #x1B[38;5;28mself#x1B[39m.run(**kwargs)
#x1B[32m    481#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m--&gt; #x1B[39m#x1B[32m482#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mError simulating #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mself#x1B[39m.name+#x1B[33m"#x1B[39m#x1B[33m scenario(s)#x1B[39m#x1B[33m"#x1B[39m) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m
#x1B[32m    483#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mself#x1B[39m.tosave:
#x1B[32m    484#x1B[39m     #x1B[38;5;28mself#x1B[39m.save(**filter_kwargs(#x1B[38;5;28mself#x1B[39m.save, **kwargs))

#x1B[31mException#x1B[39m: Error simulating nested sample scenario(s)</failure></testcase><testcase classname="examples.rover.rover_model" name="examples.rover.rover_model.Drive.drive_nominal" time="0.078" /><testcase classname="examples.rover.rover_model_human" name="examples.rover.rover_model_human.Comprehend" time="0.006" /><testcase classname="examples.rover.rover_model_human" name="examples.rover.rover_model_human.Decide" time="0.005" /><testcase classname="examples.rover.rover_model_human" name="examples.rover.rover_model_human.HumanActions" time="0.026"><failure message="392 &#10;393     Overall ASG for human operator driving the rover.&#10;394 &#10;395     Examples&#10;396     --------&#10;397     &gt;&gt;&gt; ha = HumanActions()&#10;398     &gt;&gt;&gt; ha.flows['comms'].s.on = True&#10;399     &gt;&gt;&gt; ha.active_actions&#10;400     {'look'}&#10;401     &gt;&gt;&gt; ha(proptype='dynamic', time=1.0)&#10;UNEXPECTED EXCEPTION: Exception('Error simulating humanactions of class HumanActions at time=1.0')&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py&quot;, line 795, in __call__&#10;    self.update_dynamic_behaviors(proptype=proptype)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py&quot;, line 695, in update_dynamic_behaviors&#10;    self.update_arch_behaviors(&quot;dynamic&quot;)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 161, in update_arch_behaviors&#10;    self.prop_dynamic()&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/action.py&quot;, line 386, in prop_dynamic&#10;    self.prop_graph('dynamic')&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/action.py&quot;, line 426, in prop_graph&#10;    cond = self.conds[atts['name']]()&#10;           ^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/rover/rover_model_human.py&quot;, line 112, in complete&#10;    return not self.m.in_mode('no_action', 'failed_no_action')&#10;               ^^^^^^&#10;AttributeError: 'Look' object has no attribute 'm'&#10;The above exception was the direct cause of the following exception:&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py&quot;, line 1355, in __run&#10;    exec(compile(example.source, filename, &quot;single&quot;,&#10;  File &quot;&lt;doctest examples.rover.rover_model_human.HumanActions[3]&gt;&quot;, line 1, in &lt;module&gt;&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py&quot;, line 808, in __call__&#10;    raise Exception(&quot;Error simulating &quot; + self.name +&#10;Exception: Error simulating humanactions of class HumanActions at time=1.0&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/rover/rover_model_human.py:401: UnexpectedException">392 
393     Overall ASG for human operator driving the rover.
394 
395     Examples
396     --------
397     &gt;&gt;&gt; ha = HumanActions()
398     &gt;&gt;&gt; ha.flows['comms'].s.on = True
399     &gt;&gt;&gt; ha.active_actions
400     {'look'}
401     &gt;&gt;&gt; ha(proptype='dynamic', time=1.0)
UNEXPECTED EXCEPTION: Exception('Error simulating humanactions of class HumanActions at time=1.0')
Traceback (most recent call last):
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 795, in __call__
    self.update_dynamic_behaviors(proptype=proptype)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 695, in update_dynamic_behaviors
    self.update_arch_behaviors("dynamic")
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 161, in update_arch_behaviors
    self.prop_dynamic()
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/action.py", line 386, in prop_dynamic
    self.prop_graph('dynamic')
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/action.py", line 426, in prop_graph
    cond = self.conds[atts['name']]()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/rover/rover_model_human.py", line 112, in complete
    return not self.m.in_mode('no_action', 'failed_no_action')
               ^^^^^^
AttributeError: 'Look' object has no attribute 'm'
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py", line 1355, in __run
    exec(compile(example.source, filename, "single",
  File "&lt;doctest examples.rover.rover_model_human.HumanActions[3]&gt;", line 1, in &lt;module&gt;
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 808, in __call__
    raise Exception("Error simulating " + self.name +
Exception: Error simulating humanactions of class HumanActions at time=1.0
/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/rover/rover_model_human.py:401: UnexpectedException</failure></testcase><testcase classname="examples.rover.rover_model_human" name="examples.rover.rover_model_human.Look" time="0.004"><failure message="116 &#10;117     Operator looking at the state of comms signals, switches, etc.&#10;118 &#10;119     Works as a simple pass-through. If the user doesn't look, they can't percieve,&#10;120     project, etc.&#10;121 &#10;122     Example&#10;123     -------&#10;124     &gt;&gt;&gt; l = Look()&#10;125     &gt;&gt;&gt; l.complete()&#10;UNEXPECTED EXCEPTION: AttributeError(&quot;'Look' object has no attribute 'm'&quot;)&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py&quot;, line 1355, in __run&#10;    exec(compile(example.source, filename, &quot;single&quot;,&#10;  File &quot;&lt;doctest examples.rover.rover_model_human.Look[1]&gt;&quot;, line 1, in &lt;module&gt;&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/rover/rover_model_human.py&quot;, line 112, in complete&#10;    return not self.m.in_mode('no_action', 'failed_no_action')&#10;               ^^^^^^&#10;AttributeError: 'Look' object has no attribute 'm'&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/rover/rover_model_human.py:125: UnexpectedException">116 
117     Operator looking at the state of comms signals, switches, etc.
118 
119     Works as a simple pass-through. If the user doesn't look, they can't percieve,
120     project, etc.
121 
122     Example
123     -------
124     &gt;&gt;&gt; l = Look()
125     &gt;&gt;&gt; l.complete()
UNEXPECTED EXCEPTION: AttributeError("'Look' object has no attribute 'm'")
Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py", line 1355, in __run
    exec(compile(example.source, filename, "single",
  File "&lt;doctest examples.rover.rover_model_human.Look[1]&gt;", line 1, in &lt;module&gt;
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/rover/rover_model_human.py", line 112, in complete
    return not self.m.in_mode('no_action', 'failed_no_action')
               ^^^^^^
AttributeError: 'Look' object has no attribute 'm'
/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/rover/rover_model_human.py:125: UnexpectedException</failure></testcase><testcase classname="examples.rover.rover_model_human" name="examples.rover.rover_model_human.Percieve" time="0.005" /><testcase classname="examples.rover.rover_model_human" name="examples.rover.rover_model_human.Press" time="0.005" /><testcase classname="examples.rover.rover_model_human" name="examples.rover.rover_model_human.Project" time="0.005" /><testcase classname="examples.tank.Tank_Analysis.ipynb" name="Tank_Analysis.ipynb" time="7.826"><failure message="#x1B[31mKeyError#x1B[39m: 'flow'">---------------------------------------------------------------------------
mdl = Tank()
gr = mdl.as_modelgraph()
gr.draw(figsize=(5.5,5.5))
#x1B[31m---------------------------------------------------------------------------#x1B[39m
#x1B[31mKeyError#x1B[39m                                  Traceback (most recent call last)
#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[2]#x1B[39m#x1B[32m, line 1#x1B[39m
#x1B[32m----&gt; #x1B[39m#x1B[32m1#x1B[39m mdl = #x1B[43mTank#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m      2#x1B[39m gr = mdl.as_modelgraph()
#x1B[32m      3#x1B[39m gr.draw(figsize=(#x1B[32m5.5#x1B[39m,#x1B[32m5.5#x1B[39m))

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:109#x1B[39m, in #x1B[36mArchitecture.__init__#x1B[39m#x1B[34m(self, as_copy, h, *args, **kwargs)#x1B[39m
#x1B[32m    107#x1B[39m #x1B[38;5;28mself#x1B[39m._init_flexroles = []
#x1B[32m    108#x1B[39m #x1B[38;5;28mself#x1B[39m.init_flexible_roles(**kwargs)
#x1B[32m--&gt; #x1B[39m#x1B[32m109#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_architecture#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    110#x1B[39m #x1B[38;5;28mself#x1B[39m.build(**kwargs)
#x1B[32m    111#x1B[39m #x1B[38;5;28mself#x1B[39m.mut_kwargs = {role: kwargs.get(role)
#x1B[32m    112#x1B[39m                    #x1B[38;5;28;01mfor#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.get_roles(#x1B[33m'#x1B[39m#x1B[33mcontainer#x1B[39m#x1B[33m'#x1B[39m, with_immutable=#x1B[38;5;28;01mFalse#x1B[39;00m)
#x1B[32m    113#x1B[39m                    #x1B[38;5;28;01mif#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m kwargs}

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/tank/tank_model.py:415#x1B[39m, in #x1B[36mTank.init_architecture#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    413#x1B[39m #x1B[38;5;28mself#x1B[39m.add_fxn(#x1B[33m'#x1B[39m#x1B[33mguide_water_out#x1B[39m#x1B[33m'#x1B[39m, GuideLiquidOut, #x1B[33m'#x1B[39m#x1B[33mwat_out_1#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mwat_out_2#x1B[39m#x1B[33m'#x1B[39m)
#x1B[32m    414#x1B[39m #x1B[38;5;28mself#x1B[39m.add_fxn(#x1B[33m'#x1B[39m#x1B[33mexport_water#x1B[39m#x1B[33m'#x1B[39m, ExportLiquid, #x1B[33m'#x1B[39m#x1B[33mwat_out_2#x1B[39m#x1B[33m'#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mvalve2_sig#x1B[39m#x1B[33m'#x1B[39m)
#x1B[32m--&gt; #x1B[39m#x1B[32m415#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43madd_fxn#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mhuman#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mHumanActions#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mvalve1_sig#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mtank_sig#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m
#x1B[32m    416#x1B[39m #x1B[43m             #x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mvalve2_sig#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43maa#x1B[49m#x1B[43m=#x1B[49m#x1B[43m{#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mreacttime#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m:#x1B[49m#x1B[43m #x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mp#x1B[49m#x1B[43m.#x1B[49m#x1B[43mreacttime#x1B[49m#x1B[43m}#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/function.py:508#x1B[39m, in #x1B[36mFunctionArchitecture.add_fxn#x1B[39m#x1B[34m(self, name, fclass, *flownames, **fkwargs)#x1B[39m
#x1B[32m    490#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34madd_fxn#x1B[39m(#x1B[38;5;28mself#x1B[39m, name, fclass, *flownames, **fkwargs):
#x1B[32m    491#x1B[39m #x1B[38;5;250m    #x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m    492#x1B[39m #x1B[33;03m    Instantiate a given function in the model.#x1B[39;00m
#x1B[32m    493#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m    506#x1B[39m #x1B[33;03m        Parameters to send to __init__ method of the Function superclass#x1B[39;00m
#x1B[32m    507#x1B[39m #x1B[33;03m    """#x1B[39;00m
#x1B[32m--&gt; #x1B[39m#x1B[32m508#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43madd_sim#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43mfxns#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mfclass#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43mflownames#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mfkwargs#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:393#x1B[39m, in #x1B[36mArchitecture.add_sim#x1B[39m#x1B[34m(self, flex_role, name, simclass, *flownames, **kwargs)#x1B[39m
#x1B[32m    376#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m    377#x1B[39m #x1B[33;03mAdd a Simulable to the given flex_role.#x1B[39;00m
#x1B[32m    378#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m    390#x1B[39m #x1B[33;03m    Flows, dicts for non-default values to p, s, etc.#x1B[39;00m
#x1B[32m    391#x1B[39m #x1B[33;03m"""#x1B[39;00m
#x1B[32m    392#x1B[39m flows = #x1B[38;5;28mself#x1B[39m.get_flows(*flownames, all_if_empty=#x1B[38;5;28;01mFalse#x1B[39;00m)
#x1B[32m--&gt; #x1B[39m#x1B[32m393#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43madd_flex_role_obj#x1B[49m#x1B[43m(#x1B[49m#x1B[43mflex_role#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    394#x1B[39m #x1B[43m                       #x1B[49m#x1B[43mobjclass#x1B[49m#x1B[43m=#x1B[49m#x1B[43msimclass#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mflows#x1B[49m#x1B[43m=#x1B[49m#x1B[43mflows#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    395#x1B[39m #x1B[38;5;28;01mfor#x1B[39;00m flowname #x1B[38;5;129;01min#x1B[39;00m flownames:
#x1B[32m    396#x1B[39m     #x1B[38;5;28mself#x1B[39m._simflows.append((name, flowname))

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:319#x1B[39m, in #x1B[36mArchitecture.add_flex_role_obj#x1B[39m#x1B[34m(self, flex_role, name, objclass, use_copy, **kwargs)#x1B[39m
#x1B[32m    317#x1B[39m track = get_sub_include(name, get_sub_include(flex_role, #x1B[38;5;28mself#x1B[39m.track))
#x1B[32m    318#x1B[39m kwargs = #x1B[38;5;28mself#x1B[39m.get_flex_role_kwargs(objclass, **kwargs)
#x1B[32m--&gt; #x1B[39m#x1B[32m319#x1B[39m obj = #x1B[43minit_obj#x1B[49m#x1B[43m(#x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mobjclass#x1B[49m#x1B[43m=#x1B[49m#x1B[43mobjclass#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m=#x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    320#x1B[39m #x1B[43m               #x1B[49m#x1B[43mas_copy#x1B[49m#x1B[43m=#x1B[49m#x1B[43mas_copy#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mroot#x1B[49m#x1B[43m=#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mget_full_name#x1B[49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m+#x1B[49m#x1B[33;43m"#x1B[39;49m#x1B[33;43m.#x1B[39;49m#x1B[33;43m"#x1B[39;49m#x1B[43m+#x1B[49m#x1B[43mflex_role#x1B[49m#x1B[43m,#x1B[49m
#x1B[32m    321#x1B[39m #x1B[43m               #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    323#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(obj, #x1B[33m'#x1B[39m#x1B[33mh#x1B[39m#x1B[33m'#x1B[39m) #x1B[38;5;129;01mand#x1B[39;00m obj.h:
#x1B[32m    324#x1B[39m     hist = obj.h

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:1183#x1B[39m, in #x1B[36minit_obj#x1B[39m#x1B[34m(name, objclass, track, as_copy, **kwargs)#x1B[39m
#x1B[32m   1181#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m   1182#x1B[39m     #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m-&gt; #x1B[39m#x1B[32m1183#x1B[39m         fl = #x1B[43mobjclass#x1B[49m#x1B[43m(#x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m=#x1B[49m#x1B[43mtrack#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m   1184#x1B[39m     #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mTypeError#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m e:
#x1B[32m   1185#x1B[39m         #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mTypeError#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mPoorly specified class #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(objclass) +
#x1B[32m   1186#x1B[39m                         #x1B[33m"#x1B[39m#x1B[33m (or poor arguments) #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(kwargs)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01me#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/function.py:90#x1B[39m, in #x1B[36mFunction.__init__#x1B[39m#x1B[34m(self, name, args_f, **kwargs)#x1B[39m
#x1B[32m     81#x1B[39m #x1B[38;5;28;01mdef#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34m__init__#x1B[39m(#x1B[38;5;28mself#x1B[39m, name=#x1B[38;5;28;01mNone#x1B[39;00m, args_f=#x1B[38;5;28mdict#x1B[39m(), **kwargs):
#x1B[32m     82#x1B[39m #x1B[38;5;250m    #x1B[39m#x1B[33;03m"""#x1B[39;00m
#x1B[32m     83#x1B[39m #x1B[33;03m    Instantiate the function superclass with the relevant parameters.#x1B[39;00m
#x1B[32m     84#x1B[39m 
#x1B[32m   (...)#x1B[39m#x1B[32m     88#x1B[39m #x1B[33;03m        arguments to pass to custom __init__ function.#x1B[39;00m
#x1B[32m     89#x1B[39m #x1B[33;03m    """#x1B[39;00m
#x1B[32m---&gt; #x1B[39m#x1B[32m90#x1B[39m     #x1B[38;5;28;43msuper#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43m)#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__init__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[43mname#x1B[49m#x1B[43m=#x1B[49m#x1B[43mname#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m     91#x1B[39m     #x1B[38;5;28mself#x1B[39m.args_f = args_f
#x1B[32m     92#x1B[39m     #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mhasattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, #x1B[33m'#x1B[39m#x1B[33mbehavior#x1B[39m#x1B[33m'#x1B[39m):

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/block/base.py:864#x1B[39m, in #x1B[36mBlock.__init__#x1B[39m#x1B[34m(self, name, flows, h, **kwargs)#x1B[39m
#x1B[32m    862#x1B[39m #x1B[38;5;66;03m# send flows from block level to arch level#x1B[39;00m
#x1B[32m    863#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[33m'#x1B[39m#x1B[33march#x1B[39m#x1B[33m'#x1B[39m #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.roletypes:
#x1B[32m--&gt; #x1B[39m#x1B[32m864#x1B[39m     #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_roletypes#x1B[49m#x1B[43m(#x1B[49m#x1B[33;43m'#x1B[39;49m#x1B[33;43march#x1B[39;49m#x1B[33;43m'#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mcreate_arch_kwargs#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    865#x1B[39m #x1B[38;5;28mself#x1B[39m.mut_kwargs = {role: kwargs.get(role)
#x1B[32m    866#x1B[39m                    #x1B[38;5;28;01mfor#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.get_roles(with_flex=#x1B[38;5;28;01mFalse#x1B[39;00m,
#x1B[32m    867#x1B[39m                                               with_immutable=#x1B[38;5;28;01mFalse#x1B[39;00m)
#x1B[32m    868#x1B[39m                    #x1B[38;5;28;01mif#x1B[39;00m role #x1B[38;5;129;01min#x1B[39;00m kwargs}
#x1B[32m    869#x1B[39m #x1B[38;5;28mself#x1B[39m.check_flows(flows=flows)

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:345#x1B[39m, in #x1B[36mBaseObject.init_roletypes#x1B[39m#x1B[34m(self, initializer, *roletypes, **kwargs)#x1B[39m
#x1B[32m    342#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m roletype #x1B[38;5;129;01mnot#x1B[39;00m #x1B[38;5;129;01min#x1B[39;00m #x1B[38;5;28mself#x1B[39m.roletypes:
#x1B[32m    343#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mRoletype: #x1B[39m#x1B[33m"#x1B[39m + roletype + #x1B[33m"#x1B[39m#x1B[33m not in class variable#x1B[39m#x1B[33m"#x1B[39m +
#x1B[32m    344#x1B[39m                     #x1B[33m"#x1B[39m#x1B[33m self.roletypes: #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.roletypes))
#x1B[32m--&gt; #x1B[39m#x1B[32m345#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_roles#x1B[49m#x1B[43m(#x1B[49m#x1B[43mroletype#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43minitializer#x1B[49m#x1B[43m=#x1B[49m#x1B[43minitializer#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/object/base.py:394#x1B[39m, in #x1B[36mBaseObject.init_roles#x1B[39m#x1B[34m(self, roletype, initializer, **kwargs)#x1B[39m
#x1B[32m    392#x1B[39m     obj_args[#x1B[33m'#x1B[39m#x1B[33mtrack#x1B[39m#x1B[33m'#x1B[39m] = get_sub_include(rolename, #x1B[38;5;28mself#x1B[39m.track)
#x1B[32m    393#x1B[39m #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m394#x1B[39m     obj = #x1B[43mobj_initializer#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mobj_args#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    395#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mAttributeError#x1B[39;00m #x1B[38;5;28;01mas#x1B[39;00m ae:
#x1B[32m    396#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mProblem initializing #x1B[39m#x1B[33m"#x1B[39m + roletype + #x1B[33m"#x1B[39m#x1B[33m_#x1B[39m#x1B[33m"#x1B[39m + rolename
#x1B[32m    397#x1B[39m                     + #x1B[33m"#x1B[39m#x1B[33m: #x1B[39m#x1B[33m"#x1B[39m + #x1B[38;5;28mstr#x1B[39m(initializer)) #x1B[38;5;28;01mfrom#x1B[39;00m#x1B[38;5;250m #x1B[39m#x1B[34;01mae#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/action.py:260#x1B[39m, in #x1B[36mActionArchitecture.__init__#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    258#x1B[39m #x1B[38;5;28mself#x1B[39m.flow_graph = nx.DiGraph()
#x1B[32m    259#x1B[39m #x1B[38;5;28mself#x1B[39m.active_actions = #x1B[38;5;28mset#x1B[39m()
#x1B[32m--&gt; #x1B[39m#x1B[32m260#x1B[39m #x1B[43mArchitecture#x1B[49m#x1B[43m.#x1B[49m#x1B[34;43m__init__#x1B[39;49m#x1B[43m(#x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:108#x1B[39m, in #x1B[36mArchitecture.__init__#x1B[39m#x1B[34m(self, as_copy, h, *args, **kwargs)#x1B[39m
#x1B[32m    106#x1B[39m #x1B[38;5;28mself#x1B[39m.init_hist(h=h)
#x1B[32m    107#x1B[39m #x1B[38;5;28mself#x1B[39m._init_flexroles = []
#x1B[32m--&gt; #x1B[39m#x1B[32m108#x1B[39m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43minit_flexible_roles#x1B[49m#x1B[43m(#x1B[49m#x1B[43m*#x1B[49m#x1B[43m*#x1B[49m#x1B[43mkwargs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    109#x1B[39m #x1B[38;5;28mself#x1B[39m.init_architecture(**kwargs)
#x1B[32m    110#x1B[39m #x1B[38;5;28mself#x1B[39m.build(**kwargs)

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/define/architecture/base.py:255#x1B[39m, in #x1B[36mArchitecture.init_flexible_roles#x1B[39m#x1B[34m(self, **kwargs)#x1B[39m
#x1B[32m    253#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mNo role argument #x1B[39m#x1B[33m"#x1B[39m+role+#x1B[33m"#x1B[39m#x1B[33m to copy.#x1B[39m#x1B[33m"#x1B[39m)
#x1B[32m    254#x1B[39m #x1B[38;5;28;01melif#x1B[39;00m rname #x1B[38;5;129;01min#x1B[39;00m kwargs:
#x1B[32m--&gt; #x1B[39m#x1B[32m255#x1B[39m     #x1B[38;5;28msetattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, rname, {**#x1B[43mkwargs#x1B[49m#x1B[43m[#x1B[49m#x1B[43mrole#x1B[49m#x1B[43m]#x1B[49m})
#x1B[32m    256#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m    257#x1B[39m     #x1B[38;5;28msetattr#x1B[39m(#x1B[38;5;28mself#x1B[39m, rname, #x1B[38;5;28mdict#x1B[39m())

#x1B[31mKeyError#x1B[39m: 'flow'</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_approach" time="0.013"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_approach&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843662d80&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_approach_parallelism_0" time="0.025"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_approach_parallelism_0&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d84384d340&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_approach_parallelism_1" time="0.014"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_approach_parallelism_1&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843bb2cd0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_approach_parallelism_notrack" time="0.014"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_approach_parallelism_notrack&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843c411e0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_comp_mode_inj" time="0.013"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_comp_mode_inj&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843f82540&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_different_components" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_different_components&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d84373e0b0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_epc_math" time="0.018"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_epc_math&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843985ad0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_fault_sample_isave" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_fault_sample_isave&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d84373e0b0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_fault_sample_save" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_fault_sample_save&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843c411e0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_local_tstep" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_local_tstep&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d84373e0b0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_model_copy_different" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_model_copy_different&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843bb2cd0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_model_copy_same" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_model_copy_same&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843bfe5d0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_model_reset" time="0.001"><skipped type="pytest.skip" message="Reset not fully implemented yet and unused throughout.">/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/tank/test_tank.py:69: Reset not fully implemented yet and unused throughout.</skipped></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_nested_sample_isave" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_nested_sample_isave&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843c411e0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_nested_sample_save" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_nested_sample_save&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843bb2cd0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_param_sample_isave" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_param_sample_isave&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843c411e0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_param_sample_save" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_param_sample_save&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d84373e0b0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_save_load_multfault" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_save_load_multfault&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843985ad0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_save_load_nominal" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_save_load_nominal&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d84373e0b0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_save_load_onefault" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_save_load_onefault&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843bfe5d0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_save_load_singlefaults" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_save_load_singlefaults&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843bb2cd0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_singlefaults_isave" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_singlefaults_isave&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843bfe5d0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.tank.test_tank.TankTests" name="test_tank_copy_args" time="0.012"><failure message="KeyError: 'flow'">self = &lt;examples.tank.test_tank.TankTests testMethod=test_tank_copy_args&gt;

    def setUp(self):
        self.maxDiff = None
&gt;       self.mdl = Tank()
                   ^^^^^^

examples/tank/test_tank.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/architecture/base.py:109: in __init__
    self.init_architecture(**kwargs)
examples/tank/tank_model.py:415: in init_architecture
    self.add_fxn('human', HumanActions, 'valve1_sig', 'tank_sig',
fmdtools/define/architecture/function.py:508: in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
fmdtools/define/architecture/base.py:393: in add_sim
    self.add_flex_role_obj(flex_role, name,
fmdtools/define/architecture/base.py:319: in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
fmdtools/define/object/base.py:1183: in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/action.py:260: in __init__
    Architecture.__init__(self, **kwargs)
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'HumanASG' object has no attribute 'flows'") raised in repr()] HumanASG object at 0x55d843c411e0&gt;
kwargs = {'flows': {'tank_sig': tank_sig Signal
- s=SigState(indicator=0, action=0), 'valve1_sig': valve1_sig Signal
- s=SigSta...: valve2_sig Signal
- s=SigState(indicator=1, action=0)}, 'name': 'aa', 'reacttime': 2, 'root': 'tank.fxns.human', ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="examples.taxiway.Paper_Notebook.ipynb" name="Paper_Notebook.ipynb" time="46.233"><failure message="#x1B[31mAttributeError#x1B[39m: Not in dict: t120p0">---------------------------------------------------------------------------
endresults.t120p0.endclass #table should also include local, global metrics
#x1B[31m---------------------------------------------------------------------------#x1B[39m
#x1B[31mKeyError#x1B[39m                                  Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:365#x1B[39m, in #x1B[36mResult.__getattr__#x1B[39m#x1B[34m(self, argstr)#x1B[39m
#x1B[32m    364#x1B[39m         obj = #x1B[38;5;28mself#x1B[39m
#x1B[32m--&gt; #x1B[39m#x1B[32m365#x1B[39m     #x1B[38;5;28;01mreturn#x1B[39;00m #x1B[43mget_dict_attr#x1B[49m#x1B[43m(#x1B[49m#x1B[43mobj#x1B[49m#x1B[43m.#x1B[49m#x1B[43mdata#x1B[49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[34;43m__class__#x1B[39;49m#x1B[43m,#x1B[49m#x1B[43m #x1B[49m#x1B[43m*#x1B[49m#x1B[43margs#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    366#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mKeyError#x1B[39;00m:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:96#x1B[39m, in #x1B[36mget_dict_attr#x1B[39m#x1B[34m(dict_in, des_class, *attr)#x1B[39m
#x1B[32m     95#x1B[39m #x1B[38;5;250m#x1B[39m#x1B[33;03m"""Get attributes *attr from a given nested dict dict_in of class des_class."""#x1B[39;00m
#x1B[32m---&gt; #x1B[39m#x1B[32m96#x1B[39m sub_dict = #x1B[43mdict_in#x1B[49m#x1B[43m[#x1B[49m#x1B[43mattr#x1B[49m#x1B[43m[#x1B[49m#x1B[32;43m0#x1B[39;49m#x1B[43m]#x1B[49m#x1B[43m]#x1B[49m
#x1B[32m     97#x1B[39m #x1B[38;5;28;01mif#x1B[39;00m #x1B[38;5;28mlen#x1B[39m(attr) == #x1B[32m1#x1B[39m:

#x1B[31mKeyError#x1B[39m: 't120p0'

During handling of the above exception, another exception occurred:

#x1B[31mException#x1B[39m                                 Traceback (most recent call last)
#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:368#x1B[39m, in #x1B[36mResult.__getattr__#x1B[39m#x1B[34m(self, argstr)#x1B[39m
#x1B[32m    367#x1B[39m #x1B[38;5;28;01mtry#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m368#x1B[39m     #x1B[38;5;28;01mreturn#x1B[39;00m #x1B[38;5;28;43mself#x1B[39;49m#x1B[43m.#x1B[49m#x1B[43mall_with#x1B[49m#x1B[43m(#x1B[49m#x1B[43margstr#x1B[49m#x1B[43m)#x1B[49m
#x1B[32m    369#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m:

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:442#x1B[39m, in #x1B[36mResult.all_with#x1B[39m#x1B[34m(self, attr)#x1B[39m
#x1B[32m    441#x1B[39m #x1B[38;5;28;01melse#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m442#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m(attr+#x1B[33m"#x1B[39m#x1B[33m not in Result keys: #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(#x1B[38;5;28mself#x1B[39m.keys()))

#x1B[31mException#x1B[39m: t120p0 not in Result keys: dict_keys(['nominal.tend.classify.num_cycled', 'nominal.tend.classify.perc_cycled', 'nominal.tend.classify.num_crashed', 'ma3_lost_sight_t0.tend.classify.num_cycled', 'ma3_lost_sight_t0.tend.classify.perc_cycled', 'ma3_lost_sight_t0.tend.classify.num_crashed'])

During handling of the above exception, another exception occurred:

#x1B[31mAttributeError#x1B[39m                            Traceback (most recent call last)
#x1B[36mCell#x1B[39m#x1B[36m #x1B[39m#x1B[32mIn[23]#x1B[39m#x1B[32m, line 1#x1B[39m
#x1B[32m----&gt; #x1B[39m#x1B[32m1#x1B[39m #x1B[43mendresults#x1B[49m#x1B[43m.#x1B[49m#x1B[43mt120p0#x1B[49m.endclass #x1B[38;5;66;03m#table should also include local, global metrics#x1B[39;00m

#x1B[36mFile #x1B[39m#x1B[32m~/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools-full/lib/python3.11/site-packages/fmdtools/analyze/result.py:370#x1B[39m, in #x1B[36mResult.__getattr__#x1B[39m#x1B[34m(self, argstr)#x1B[39m
#x1B[32m    368#x1B[39m     #x1B[38;5;28;01mreturn#x1B[39;00m #x1B[38;5;28mself#x1B[39m.all_with(argstr)
#x1B[32m    369#x1B[39m #x1B[38;5;28;01mexcept#x1B[39;00m #x1B[38;5;167;01mException#x1B[39;00m:
#x1B[32m--&gt; #x1B[39m#x1B[32m370#x1B[39m     #x1B[38;5;28;01mraise#x1B[39;00m #x1B[38;5;167;01mAttributeError#x1B[39;00m(#x1B[33m"#x1B[39m#x1B[33mNot in dict: #x1B[39m#x1B[33m"#x1B[39m+#x1B[38;5;28mstr#x1B[39m(argstr))

#x1B[31mAttributeError#x1B[39m: Not in dict: t120p0</failure></testcase><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_avoid" time="2.774" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_avoid_plot" time="2.992" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_heli_cycle" time="1.361" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_heli_cycle_plot" time="1.538" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_lost_sight" time="5.919" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_lost_sight_plot" time="5.626" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_one_cycle" time="1.403" /><testcase classname="examples.taxiway.test_asset.AssetTests" name="test_one_cycle_plot" time="2.034" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_atc_lost_ground_perception" time="34.743" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_atc_lost_ground_perception_plot" time="34.889" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_atc_wrong_land_command" time="34.399" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_atc_wrong_land_command_lost_sight" time="34.046" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_atc_wrong_land_command_sight_plot" time="38.094" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_default_plots" time="21.281" /><testcase classname="examples.taxiway.test_model.ModelTests" name="test_scen" time="17.467" /><testcase classname="fmdtools.analyze.common" name="fmdtools.analyze.common.auto_filetype" time="0.004" /><testcase classname="fmdtools.analyze.common" name="fmdtools.analyze.common.calc_average" time="0.003" /><testcase classname="fmdtools.analyze.common" name="fmdtools.analyze.common.calc_expected" time="0.003" /><testcase classname="fmdtools.analyze.common" name="fmdtools.analyze.common.calc_metric" time="0.003" /><testcase classname="fmdtools.analyze.common" name="fmdtools.analyze.common.calc_metric_ci" time="0.022" /><testcase classname="fmdtools.analyze.common" name="fmdtools.analyze.common.calc_percent" time="0.003" /><testcase classname="fmdtools.analyze.common" name="fmdtools.analyze.common.calc_rate" time="0.002" /><testcase classname="fmdtools.analyze.common" name="fmdtools.analyze.common.calc_sum" time="0.002" /><testcase classname="fmdtools.analyze.common" name="fmdtools.analyze.common.calc_total" time="0.002" /><testcase classname="fmdtools.analyze.common" name="fmdtools.analyze.common.create_indiv_filename" time="0.003" /><testcase classname="fmdtools.analyze.common" name="fmdtools.analyze.common.diff" time="0.004" /><testcase classname="fmdtools.analyze.common" name="fmdtools.analyze.common.join_key" time="0.004" /><testcase classname="fmdtools.analyze.common" name="fmdtools.analyze.common.to_include_keys" time="0.004" /><testcase classname="fmdtools.analyze.graph.base" name="fmdtools.analyze.graph.base.Graph" time="0.662" /><testcase classname="fmdtools.analyze.graph.base" name="fmdtools.analyze.graph.base.Graph._get_edge_style" time="0.006" /><testcase classname="fmdtools.analyze.graph.base" name="fmdtools.analyze.graph.base.Graph._get_node_style" time="0.005" /><testcase classname="fmdtools.analyze.graph.base" name="fmdtools.analyze.graph.base.Graph.add_node_groups" time="0.127" /><testcase classname="fmdtools.analyze.graph.base" name="fmdtools.analyze.graph.base.Graph.draw_drawio" time="0.003"><failure message="393             Additional arguments for graph styling and positioning.&#10;394             &#10;395         Returns&#10;396         -------&#10;397         str&#10;398             DrawIO XML content if saveas is empty, otherwise the filename.&#10;399             &#10;400         Examples&#10;401         --------&#10;402         &gt;&gt;&gt; xml_content = graph.draw_drawio()  # Get XML content&#10;UNEXPECTED EXCEPTION: NameError(&quot;name 'graph' is not defined&quot;)&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py&quot;, line 1355, in __run&#10;    exec(compile(example.source, filename, &quot;single&quot;,&#10;  File &quot;&lt;doctest fmdtools.analyze.graph.base.Graph.draw_drawio[0]&gt;&quot;, line 1, in &lt;module&gt;&#10;NameError: name 'graph' is not defined&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/analyze/graph/base.py:402: UnexpectedException">393             Additional arguments for graph styling and positioning.
394             
395         Returns
396         -------
397         str
398             DrawIO XML content if saveas is empty, otherwise the filename.
399             
400         Examples
401         --------
402         &gt;&gt;&gt; xml_content = graph.draw_drawio()  # Get XML content
UNEXPECTED EXCEPTION: NameError("name 'graph' is not defined")
Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py", line 1355, in __run
    exec(compile(example.source, filename, "single",
  File "&lt;doctest fmdtools.analyze.graph.base.Graph.draw_drawio[0]&gt;", line 1, in &lt;module&gt;
NameError: name 'graph' is not defined
/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/analyze/graph/base.py:402: UnexpectedException</failure></testcase><testcase classname="fmdtools.analyze.graph.base" name="fmdtools.analyze.graph.base.Graph.set_heatmap" time="0.130" /><testcase classname="fmdtools.analyze.graph.model" name="fmdtools.analyze.graph.model.ModelGraph" time="0.012"><failure message="211     get_states: bool&#10;212         whether to get states for the graph&#10;213     **kwargs:&#10;214         keyword arguments for self.nx_from_obj&#10;215 &#10;216     Examples&#10;217     --------&#10;218     &gt;&gt;&gt; from fmdtools.define.block.function import ExampleFunction&#10;219     &gt;&gt;&gt; mg = ModelGraph(ExampleFunction())&#10;220     &gt;&gt;&gt; mg.get_nodes()&#10;Expected:&#10;    ['examplefunction', 'examplefunction.m', 'examplefunction.p', 'examplefunction.s', 'examplefunction.sp', 'examplefunction.t', 'examplefunction.exampleflow', 'examplefunction.dynamic_behavior']&#10;Got:&#10;    ['examplefunction', 'examplefunction.t', 'examplefunction.sp', 'examplefunction.p', 'examplefunction.s', 'examplefunction.m', 'examplefunction.exampleflow', 'examplefunction.dynamic_behavior']&#10;&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/analyze/graph/model.py:220: DocTestFailure">211     get_states: bool
212         whether to get states for the graph
213     **kwargs:
214         keyword arguments for self.nx_from_obj
215 
216     Examples
217     --------
218     &gt;&gt;&gt; from fmdtools.define.block.function import ExampleFunction
219     &gt;&gt;&gt; mg = ModelGraph(ExampleFunction())
220     &gt;&gt;&gt; mg.get_nodes()
Expected:
    ['examplefunction', 'examplefunction.m', 'examplefunction.p', 'examplefunction.s', 'examplefunction.sp', 'examplefunction.t', 'examplefunction.exampleflow', 'examplefunction.dynamic_behavior']
Got:
    ['examplefunction', 'examplefunction.t', 'examplefunction.sp', 'examplefunction.p', 'examplefunction.s', 'examplefunction.m', 'examplefunction.exampleflow', 'examplefunction.dynamic_behavior']

/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/analyze/graph/model.py:220: DocTestFailure</failure></testcase><testcase classname="fmdtools.analyze.graph.model" name="fmdtools.analyze.graph.model.create_inheritance_subgraph" time="0.008" /><testcase classname="fmdtools.analyze.graph.style" name="fmdtools.analyze.graph.style.FlowEdgeStyle" time="0.003" /><testcase classname="fmdtools.analyze.graph.style" name="fmdtools.analyze.graph.style.edge_style_factory" time="0.811" /><testcase classname="fmdtools.analyze.graph.style" name="fmdtools.analyze.graph.style.node_style_factory" time="1.790" /><testcase classname="fmdtools.analyze.graph.style" name="fmdtools.analyze.graph.style.to_legend_label" time="0.003" /><testcase classname="fmdtools.analyze.history" name="fmdtools.analyze.history.History" time="0.004" /><testcase classname="fmdtools.analyze.history" name="fmdtools.analyze.history.History.cut" time="0.003" /><testcase classname="fmdtools.analyze.history" name="fmdtools.analyze.history.History.get_degraded_hist" time="0.004" /><testcase classname="fmdtools.analyze.history" name="fmdtools.analyze.history.History.get_fault_time" time="0.003" /><testcase classname="fmdtools.analyze.history" name="fmdtools.analyze.history.History.get_faulty_hist" time="0.004" /><testcase classname="fmdtools.analyze.history" name="fmdtools.analyze.history.History.get_mean_bound_errhist" time="0.004" /><testcase classname="fmdtools.analyze.history" name="fmdtools.analyze.history.History.get_mean_ci_errhist" time="0.015" /><testcase classname="fmdtools.analyze.history" name="fmdtools.analyze.history.History.get_mean_std_errhist" time="0.004" /><testcase classname="fmdtools.analyze.history" name="fmdtools.analyze.history.History.get_percentile_errhist" time="0.010" /><testcase classname="fmdtools.analyze.history" name="fmdtools.analyze.history.History.get_slice" time="0.003" /><testcase classname="fmdtools.analyze.phases" name="fmdtools.analyze.phases.PhaseMap.calc_modephase_time" time="0.003" /><testcase classname="fmdtools.analyze.phases" name="fmdtools.analyze.phases.PhaseMap.calc_phase_time" time="0.003" /><testcase classname="fmdtools.analyze.phases" name="fmdtools.analyze.phases.PhaseMap.calc_samples_in_phases" time="0.003" /><testcase classname="fmdtools.analyze.phases" name="fmdtools.analyze.phases.PhaseMap.find_modephase" time="0.003" /><testcase classname="fmdtools.analyze.phases" name="fmdtools.analyze.phases.PhaseMap.get_phase_times" time="0.003" /><testcase classname="fmdtools.analyze.phases" name="fmdtools.analyze.phases.PhaseMap.get_sample_times" time="0.003" /><testcase classname="fmdtools.analyze.phases" name="fmdtools.analyze.phases.find_interval_overlap" time="0.003" /><testcase classname="fmdtools.analyze.phases" name="fmdtools.analyze.phases.from_hist" time="0.004" /><testcase classname="fmdtools.analyze.phases" name="fmdtools.analyze.phases.join_phasemaps" time="0.003" /><testcase classname="fmdtools.analyze.result" name="fmdtools.analyze.result.Result" time="0.004" /><testcase classname="fmdtools.analyze.result" name="fmdtools.analyze.result.Result.__eq__" time="0.004" /><testcase classname="fmdtools.analyze.result" name="fmdtools.analyze.result.Result.__sub__" time="0.003" /><testcase classname="fmdtools.analyze.result" name="fmdtools.analyze.result.Result.align_external_dict" time="0.003" /><testcase classname="fmdtools.analyze.result" name="fmdtools.analyze.result.Result.fromdict" time="0.003" /><testcase classname="fmdtools.analyze.result" name="fmdtools.analyze.result.Result.get" time="0.003" /><testcase classname="fmdtools.analyze.result" name="fmdtools.analyze.result.Result.get_metric" time="0.006" /><testcase classname="fmdtools.analyze.result" name="fmdtools.analyze.result.Result.get_metric_ci" time="0.012" /><testcase classname="fmdtools.analyze.result" name="fmdtools.analyze.result.Result.get_vals" time="0.004" /><testcase classname="fmdtools.analyze.result" name="fmdtools.analyze.result.Result.is_flat" time="0.003" /><testcase classname="fmdtools.analyze.tabulate" name="fmdtools.analyze.tabulate.Comparison" time="1.766" /><testcase classname="fmdtools.analyze.tabulate" name="fmdtools.analyze.tabulate.FMEA" time="0.051" /><testcase classname="fmdtools.analyze.tabulate" name="fmdtools.analyze.tabulate.result_summary" time="0.417" /><testcase classname="fmdtools.analyze.tabulate" name="fmdtools.analyze.tabulate.result_summary_fmea" time="1.793" /><testcase classname="fmdtools.define.architecture.action" name="fmdtools.define.architecture.action.ActionArchitecture" time="0.014" /><testcase classname="fmdtools.define.architecture.action" name="fmdtools.define.architecture.action.ActionArchitectureActGraph" time="0.006" /><testcase classname="fmdtools.define.architecture.action" name="fmdtools.define.architecture.action.ActionArchitectureFlowGraph" time="0.006" /><testcase classname="fmdtools.define.architecture.action" name="fmdtools.define.architecture.action.ActionArchitectureGraph" time="0.007" /><testcase classname="fmdtools.define.architecture.base" name="fmdtools.define.architecture.base.Architecture.as_drawio" time="0.002"><failure message="637             Additional arguments passed to the graph creation.&#10;638             &#10;639         Returns&#10;640         -------&#10;641         str&#10;642             DrawIO XML content if saveas is empty, otherwise None.&#10;643             &#10;644         Examples&#10;645         --------&#10;646         &gt;&gt;&gt; xml_content = arch.as_drawio()  # Get XML content&#10;UNEXPECTED EXCEPTION: NameError(&quot;name 'arch' is not defined&quot;)&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py&quot;, line 1355, in __run&#10;    exec(compile(example.source, filename, &quot;single&quot;,&#10;  File &quot;&lt;doctest fmdtools.define.architecture.base.Architecture.as_drawio[0]&gt;&quot;, line 1, in &lt;module&gt;&#10;NameError: name 'arch' is not defined&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py:646: UnexpectedException">637             Additional arguments passed to the graph creation.
638             
639         Returns
640         -------
641         str
642             DrawIO XML content if saveas is empty, otherwise None.
643             
644         Examples
645         --------
646         &gt;&gt;&gt; xml_content = arch.as_drawio()  # Get XML content
UNEXPECTED EXCEPTION: NameError("name 'arch' is not defined")
Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py", line 1355, in __run
    exec(compile(example.source, filename, "single",
  File "&lt;doctest fmdtools.define.architecture.base.Architecture.as_drawio[0]&gt;", line 1, in &lt;module&gt;
NameError: name 'arch' is not defined
/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py:646: UnexpectedException</failure></testcase><testcase classname="fmdtools.define.architecture.component" name="fmdtools.define.architecture.component.ComponentArchitecture" time="0.014" /><testcase classname="fmdtools.define.architecture.function" name="fmdtools.define.architecture.function.FunctionArchitecture" time="0.016" /><testcase classname="fmdtools.define.architecture.function" name="fmdtools.define.architecture.function.FunctionArchitectureFlowGraph" time="0.010" /><testcase classname="fmdtools.define.architecture.function" name="fmdtools.define.architecture.function.FunctionArchitectureFxnGraph" time="0.010" /><testcase classname="fmdtools.define.architecture.function" name="fmdtools.define.architecture.function.FunctionArchitectureGraph" time="0.014" /><testcase classname="fmdtools.define.architecture.function" name="fmdtools.define.architecture.function.FunctionArchitectureTypeGraph" time="0.008" /><testcase classname="fmdtools.define.architecture.geom" name="fmdtools.define.architecture.geom.GeomArchitecture" time="0.009" /><testcase classname="fmdtools.define.architecture.geom" name="fmdtools.define.architecture.geom.GeomArchitecture.all_at" time="0.011" /><testcase classname="fmdtools.define.base" name="fmdtools.define.base.is_bool" time="0.002" /><testcase classname="fmdtools.define.base" name="fmdtools.define.base.is_numeric" time="0.002" /><testcase classname="fmdtools.define.base" name="fmdtools.define.base.nan_to_x" time="0.002" /><testcase classname="fmdtools.define.block.action" name="fmdtools.define.block.action.Action" time="0.006" /><testcase classname="fmdtools.define.block.base" name="fmdtools.define.block.base.SimParam.get_hist_ind" time="0.002" /><testcase classname="fmdtools.define.block.base" name="fmdtools.define.block.base.SimParam.get_shift" time="0.003" /><testcase classname="fmdtools.define.block.base" name="fmdtools.define.block.base.SimParam.get_timerange" time="0.003" /><testcase classname="fmdtools.define.block.component" name="fmdtools.define.block.component.Component" time="0.009" /><testcase classname="fmdtools.define.block.function" name="fmdtools.define.block.function.Function" time="0.006" /><testcase classname="fmdtools.define.container.base" name="fmdtools.define.container.base.BaseContainer.assign" time="0.003" /><testcase classname="fmdtools.define.container.base" name="fmdtools.define.container.base.BaseContainer.copy" time="0.003" /><testcase classname="fmdtools.define.container.base" name="fmdtools.define.container.base.BaseContainer.create_hist" time="0.002" /><testcase classname="fmdtools.define.container.base" name="fmdtools.define.container.base.BaseContainer.get_field_dict" time="0.002" /><testcase classname="fmdtools.define.container.base" name="fmdtools.define.container.base.BaseContainer.set_field" time="0.002" /><testcase classname="fmdtools.define.container.base" name="fmdtools.define.container.base.BaseContainer.to_default" time="0.002" /><testcase classname="fmdtools.define.container.base" name="fmdtools.define.container.base.check_container_pick" time="0.002" /><testcase classname="fmdtools.define.container.mode" name="fmdtools.define.container.mode.Fault.calc_rate" time="0.003" /><testcase classname="fmdtools.define.container.mode" name="fmdtools.define.container.mode.HumanErrorMode" time="0.003" /><testcase classname="fmdtools.define.container.mode" name="fmdtools.define.container.mode.Mode" time="0.005" /><testcase classname="fmdtools.define.container.mode" name="fmdtools.define.container.mode.Mode.add_fault" time="0.003" /><testcase classname="fmdtools.define.container.mode" name="fmdtools.define.container.mode.Mode.get_fault" time="0.003" /><testcase classname="fmdtools.define.container.parameter" name="fmdtools.define.container.parameter.Parameter" time="0.003" /><testcase classname="fmdtools.define.container.rand" name="fmdtools.define.container.rand.Rand" time="0.005" /><testcase classname="fmdtools.define.container.rand" name="fmdtools.define.container.rand.Rand.get_rand_states" time="0.003" /><testcase classname="fmdtools.define.container.rand" name="fmdtools.define.container.rand.calc_prob_density_for_random" time="0.002" /><testcase classname="fmdtools.define.container.rand" name="fmdtools.define.container.rand.calc_prob_for_choice" time="0.002" /><testcase classname="fmdtools.define.container.rand" name="fmdtools.define.container.rand.calc_prob_for_integers" time="0.002" /><testcase classname="fmdtools.define.container.rand" name="fmdtools.define.container.rand.calc_prob_for_permuted" time="0.003" /><testcase classname="fmdtools.define.container.rand" name="fmdtools.define.container.rand.calc_prob_for_shuffle_permutation" time="0.002" /><testcase classname="fmdtools.define.container.rand" name="fmdtools.define.container.rand.get_exp_ray_pdf" time="0.003" /><testcase classname="fmdtools.define.container.rand" name="fmdtools.define.container.rand.get_hypergeometric_pmf" time="0.002" /><testcase classname="fmdtools.define.container.rand" name="fmdtools.define.container.rand.get_lognormal_pdf" time="0.003" /><testcase classname="fmdtools.define.container.rand" name="fmdtools.define.container.rand.get_prob_for_rand" time="0.003" /><testcase classname="fmdtools.define.container.rand" name="fmdtools.define.container.rand.get_standard_t_pdf" time="0.003" /><testcase classname="fmdtools.define.container.rand" name="fmdtools.define.container.rand.get_triangular_pdf" time="0.004" /><testcase classname="fmdtools.define.container.state" name="fmdtools.define.container.state.State" time="0.005" /><testcase classname="fmdtools.define.container.state" name="fmdtools.define.container.state.State.add" time="0.004" /><testcase classname="fmdtools.define.container.state" name="fmdtools.define.container.state.State.div" time="0.002" /><testcase classname="fmdtools.define.container.state" name="fmdtools.define.container.state.State.get" time="0.003" /><testcase classname="fmdtools.define.container.state" name="fmdtools.define.container.state.State.gett" time="0.002" /><testcase classname="fmdtools.define.container.state" name="fmdtools.define.container.state.State.inc" time="0.003" /><testcase classname="fmdtools.define.container.state" name="fmdtools.define.container.state.State.limit" time="0.002" /><testcase classname="fmdtools.define.container.state" name="fmdtools.define.container.state.State.mul" time="0.002" /><testcase classname="fmdtools.define.container.state" name="fmdtools.define.container.state.State.put" time="0.002" /><testcase classname="fmdtools.define.container.state" name="fmdtools.define.container.state.State.roundto" time="0.002" /><testcase classname="fmdtools.define.container.state" name="fmdtools.define.container.state.State.same" time="0.003" /><testcase classname="fmdtools.define.container.state" name="fmdtools.define.container.state.State.set_atts" time="0.002" /><testcase classname="fmdtools.define.container.state" name="fmdtools.define.container.state.State.sub" time="0.002" /><testcase classname="fmdtools.define.container.time" name="fmdtools.define.container.time.Time" time="0.004" /><testcase classname="fmdtools.define.environment" name="fmdtools.define.environment.Environment" time="0.020" /><testcase classname="fmdtools.define.environment" name="fmdtools.define.environment.Environment.copy" time="0.039" /><testcase classname="fmdtools.define.flow.base" name="fmdtools.define.flow.base.Flow" time="0.004" /><testcase classname="fmdtools.define.flow.commsflow" name="fmdtools.define.flow.commsflow.CommsFlow" time="0.005" /><testcase classname="fmdtools.define.flow.multiflow" name="fmdtools.define.flow.multiflow.MultiFlow" time="0.004" /><testcase classname="fmdtools.define.flow.multiflow" name="fmdtools.define.flow.multiflow.MultiFlow.create_hist" time="0.004" /><testcase classname="fmdtools.define.flow.multiflow" name="fmdtools.define.flow.multiflow.MultiFlow.get_view" time="0.004" /><testcase classname="fmdtools.define.object.base" name="fmdtools.define.object.base.BaseObject" time="0.005" /><testcase classname="fmdtools.define.object.base" name="fmdtools.define.object.base.BaseObject.assign_roles" time="0.004" /><testcase classname="fmdtools.define.object.base" name="fmdtools.define.object.base.BaseObject.get_att_roletype" time="0.003" /><testcase classname="fmdtools.define.object.base" name="fmdtools.define.object.base.BaseObject.get_node_attrs" time="0.003" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.BaseCoords.find_all_prop" time="0.004" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.BaseCoords.find_all_props" time="0.005" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.BaseCoords.get" time="0.004" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.BaseCoords.get_neighbors" time="0.008" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.BaseCoords.get_properties" time="0.004" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.BaseCoords.set" time="0.004" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.BaseCoords.set_pts" time="0.004" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.BaseCoords.set_range" time="0.008" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.BaseCoords.to_gridpoint" time="0.005" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.BaseCoords.to_index" time="0.004" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.Coords" time="0.008" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.Coords.copy" time="0.005" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.Coords.find_all" time="0.005" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.Coords.find_closest" time="0.004" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.Coords.in_area" time="0.004" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.Coords.set_rand_pts" time="0.003" /><testcase classname="fmdtools.define.object.coords" name="fmdtools.define.object.coords.MetricCoords" time="0.004" /><testcase classname="fmdtools.define.object.geom" name="fmdtools.define.object.geom.Geom.all_at" time="0.005" /><testcase classname="fmdtools.define.object.geom" name="fmdtools.define.object.geom.Geom.vect_at_shape" time="0.004" /><testcase classname="fmdtools.define.object.geom" name="fmdtools.define.object.geom.Geom.vect_to_shape" time="0.004" /><testcase classname="fmdtools.define.object.geom" name="fmdtools.define.object.geom.GeomLine" time="0.004" /><testcase classname="fmdtools.define.object.geom" name="fmdtools.define.object.geom.GeomLine.get_args" time="0.003" /><testcase classname="fmdtools.define.object.geom" name="fmdtools.define.object.geom.GeomPoint" time="0.005" /><testcase classname="fmdtools.define.object.geom" name="fmdtools.define.object.geom.GeomPoint.get_args" time="0.002" /><testcase classname="fmdtools.define.object.geom" name="fmdtools.define.object.geom.GeomPoly" time="0.004" /><testcase classname="fmdtools.define.object.geom" name="fmdtools.define.object.geom.GeomPoly.get_args" time="0.005" /><testcase classname="fmdtools.define.object.geom" name="fmdtools.define.object.geom.LineParam" time="0.005" /><testcase classname="fmdtools.define.object.geom" name="fmdtools.define.object.geom.PointParam" time="0.003" /><testcase classname="fmdtools.define.object.geom" name="fmdtools.define.object.geom.PolyParam" time="0.003" /><testcase classname="fmdtools.define.object.timer" name="fmdtools.define.object.timer.Timer" time="0.003" /><testcase classname="fmdtools.sim.propagate" name="fmdtools.sim.propagate.MultiEventSimulation" time="4.177" /><testcase classname="fmdtools.sim.propagate" name="fmdtools.sim.propagate.MultiSimulation" time="2.805" /><testcase classname="fmdtools.sim.propagate" name="fmdtools.sim.propagate.NestedSimulation" time="1.358" /><testcase classname="fmdtools.sim.propagate" name="fmdtools.sim.propagate.SimEvent" time="0.012"><failure message="337         Whether the event has simulated. Default is False.&#10;338 &#10;339     Examples&#10;340     --------&#10;341     &gt;&gt;&gt; from fmdtools.define.block.function import ExampleFunction&#10;342     &gt;&gt;&gt; se = SimEvent(time=5.0, copy=True, to_return=[&quot;classify&quot;])&#10;343     &gt;&gt;&gt; se&#10;344     SimEvent(time=5.0, copy=True, to_return=['classify'])&#10;345     &gt;&gt;&gt; se.run(ExampleFunction())&#10;346     &gt;&gt;&gt; se.mdl_copy # note that copied models are gotten just before the simulation&#10;Differences (unified diff with -expected +actual):&#10;    @@ -1,5 +1,5 @@&#10;     examplefunction ExampleFunction&#10;    +- t=Time(time=4.0, timers={})&#10;    +- s=ExampleState(x=4.0, y=0.0)&#10;     - m=ExampleMode(mode='standby', faults=set(), sub_faults=False)&#10;    -- s=ExampleState(x=4.0, y=0.0)&#10;    -- t=Time(time=4.0, timers={})&#10;     - exf=ExampleFlow(s=(x=1.0, y=1.0))&#10;&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py:346: DocTestFailure">337         Whether the event has simulated. Default is False.
338 
339     Examples
340     --------
341     &gt;&gt;&gt; from fmdtools.define.block.function import ExampleFunction
342     &gt;&gt;&gt; se = SimEvent(time=5.0, copy=True, to_return=["classify"])
343     &gt;&gt;&gt; se
344     SimEvent(time=5.0, copy=True, to_return=['classify'])
345     &gt;&gt;&gt; se.run(ExampleFunction())
346     &gt;&gt;&gt; se.mdl_copy # note that copied models are gotten just before the simulation
Differences (unified diff with -expected +actual):
    @@ -1,5 +1,5 @@
     examplefunction ExampleFunction
    +- t=Time(time=4.0, timers={})
    +- s=ExampleState(x=4.0, y=0.0)
     - m=ExampleMode(mode='standby', faults=set(), sub_faults=False)
    -- s=ExampleState(x=4.0, y=0.0)
    -- t=Time(time=4.0, timers={})
     - exf=ExampleFlow(s=(x=1.0, y=1.0))

/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py:346: DocTestFailure</failure></testcase><testcase classname="fmdtools.sim.propagate" name="fmdtools.sim.propagate.Simulation" time="0.137"><failure message="534     &gt;&gt;&gt; sim = Simulation(mdl=esf, scen=s, ctimes = [2, 4], to_return={1.0: 's.x', &quot;end&quot;: [&quot;classify&quot;, &quot;graph&quot;]})&#10;535     &gt;&gt;&gt; sim&#10;536     Simulation with SimEvents:&#10;537     - 1.0=SimEvent(to_return={'s.x': None})&#10;538     - 2.0=SimEvent(copy=True)&#10;539     - 3.0=SimEvent(injection=Injection(faults={'examplefunction': ['low']}, disturbances={}))&#10;540     - 4.0=SimEvent(copy=True)&#10;541     - end=SimEvent(to_return={'classify': None, 'graph': None})&#10;542     &gt;&gt;&gt; res, hist = sim()&#10;543     &gt;&gt;&gt; sim.mdl&#10;Differences (unified diff with -expected +actual):&#10;    @@ -1,5 +1,5 @@&#10;     examplefunction ExampleFunction&#10;    +- t=Time(time=100.0, timers={})&#10;    +- s=ExampleState(x=20.0, y=294.0)&#10;     - m=ExampleMode(mode='low', faults={'low'}, sub_faults=False)&#10;    -- s=ExampleState(x=20.0, y=294.0)&#10;    -- t=Time(time=100.0, timers={})&#10;     - exf=ExampleFlow(s=(x=1964.0, y=1.0))&#10;&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py:543: DocTestFailure">534     &gt;&gt;&gt; sim = Simulation(mdl=esf, scen=s, ctimes = [2, 4], to_return={1.0: 's.x', "end": ["classify", "graph"]})
535     &gt;&gt;&gt; sim
536     Simulation with SimEvents:
537     - 1.0=SimEvent(to_return={'s.x': None})
538     - 2.0=SimEvent(copy=True)
539     - 3.0=SimEvent(injection=Injection(faults={'examplefunction': ['low']}, disturbances={}))
540     - 4.0=SimEvent(copy=True)
541     - end=SimEvent(to_return={'classify': None, 'graph': None})
542     &gt;&gt;&gt; res, hist = sim()
543     &gt;&gt;&gt; sim.mdl
Differences (unified diff with -expected +actual):
    @@ -1,5 +1,5 @@
     examplefunction ExampleFunction
    +- t=Time(time=100.0, timers={})
    +- s=ExampleState(x=20.0, y=294.0)
     - m=ExampleMode(mode='low', faults={'low'}, sub_faults=False)
    -- s=ExampleState(x=20.0, y=294.0)
    -- t=Time(time=100.0, timers={})
     - exf=ExampleFlow(s=(x=1964.0, y=1.0))

/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/propagate.py:543: DocTestFailure</failure></testcase><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.BaseSample.get_metric" time="0.008" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.FaultDomain.add_all" time="0.009" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.FaultDomain.add_all_fxn_modes" time="0.009" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.FaultDomain.add_all_fxnclass_modes" time="0.009" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.FaultDomain.add_fault" time="0.009" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.FaultDomain.add_fault_space" time="0.010" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.FaultDomain.add_faults" time="0.008" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.FaultDomain.add_singlecomp_modes" time="0.022"><failure message="654 &#10;655         Parameters&#10;656         ----------&#10;657         *fxns : str&#10;658             Names of the functions containing the components.&#10;659 &#10;660         Examples&#10;661         --------&#10;662         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone&#10;663         &gt;&gt;&gt; fd = FaultDomain(Drone())&#10;UNEXPECTED EXCEPTION: KeyError('flow')&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py&quot;, line 1355, in __run&#10;    exec(compile(example.source, filename, &quot;single&quot;,&#10;  File &quot;&lt;doctest fmdtools.sim.sample.FaultDomain.add_singlecomp_modes[1]&gt;&quot;, line 1, in &lt;module&gt;&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 109, in __init__&#10;    self.init_architecture(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py&quot;, line 701, in init_architecture&#10;    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py&quot;, line 508, in add_fxn&#10;    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 393, in add_sim&#10;    self.add_flex_role_obj(flex_role, name,&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 319, in add_flex_role_obj&#10;    obj = init_obj(name=name, objclass=objclass, track=track,&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 1183, in init_obj&#10;    fl = objclass(name=name, track=track, **kwargs)&#10;         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py&quot;, line 90, in __init__&#10;    super().__init__(name=name, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py&quot;, line 864, in __init__&#10;    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 345, in init_roletypes&#10;    self.init_roles(roletype, initializer=initializer, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 394, in init_roles&#10;    obj = obj_initializer(**obj_args)&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py&quot;, line 73, in __init__&#10;    Architecture.__init__(self, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 108, in __init__&#10;    self.init_flexible_roles(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 255, in init_flexible_roles&#10;    setattr(self, rname, {**kwargs[role]})&#10;                            ~~~~~~^^^^^^&#10;KeyError: 'flow'&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:663: UnexpectedException">654 
655         Parameters
656         ----------
657         *fxns : str
658             Names of the functions containing the components.
659 
660         Examples
661         --------
662         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone
663         &gt;&gt;&gt; fd = FaultDomain(Drone())
UNEXPECTED EXCEPTION: KeyError('flow')
Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py", line 1355, in __run
    exec(compile(example.source, filename, "single",
  File "&lt;doctest fmdtools.sim.sample.FaultDomain.add_singlecomp_modes[1]&gt;", line 1, in &lt;module&gt;
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 109, in __init__
    self.init_architecture(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py", line 701, in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py", line 508, in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 393, in add_sim
    self.add_flex_role_obj(flex_role, name,
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 319, in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 1183, in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py", line 90, in __init__
    super().__init__(name=name, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 864, in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 345, in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 394, in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py", line 73, in __init__
    Architecture.__init__(self, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 108, in __init__
    self.init_flexible_roles(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 255, in init_flexible_roles
    setattr(self, rname, {**kwargs[role]})
                            ~~~~~~^^^^^^
KeyError: 'flow'
/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:663: UnexpectedException</failure></testcase><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.FaultSample" time="0.004" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.FaultSample.add_fault_phases" time="0.021"><failure message="1083             The default is {}.&#10;1084         n_joint : int&#10;1085             Number of joint fault modes to include in sample.&#10;1086         **joint_kwargs : kwargs&#10;1087             baserate and p_cond arguments to add_joint_fault_scenario.&#10;1088 &#10;1089         Examples&#10;1090         --------&#10;1091         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone&#10;1092         &gt;&gt;&gt; mdl = Drone()&#10;UNEXPECTED EXCEPTION: KeyError('flow')&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py&quot;, line 1355, in __run&#10;    exec(compile(example.source, filename, &quot;single&quot;,&#10;  File &quot;&lt;doctest fmdtools.sim.sample.FaultSample.add_fault_phases[1]&gt;&quot;, line 1, in &lt;module&gt;&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 109, in __init__&#10;    self.init_architecture(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py&quot;, line 701, in init_architecture&#10;    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py&quot;, line 508, in add_fxn&#10;    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 393, in add_sim&#10;    self.add_flex_role_obj(flex_role, name,&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 319, in add_flex_role_obj&#10;    obj = init_obj(name=name, objclass=objclass, track=track,&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 1183, in init_obj&#10;    fl = objclass(name=name, track=track, **kwargs)&#10;         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py&quot;, line 90, in __init__&#10;    super().__init__(name=name, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py&quot;, line 864, in __init__&#10;    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 345, in init_roletypes&#10;    self.init_roles(roletype, initializer=initializer, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 394, in init_roles&#10;    obj = obj_initializer(**obj_args)&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py&quot;, line 73, in __init__&#10;    Architecture.__init__(self, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 108, in __init__&#10;    self.init_flexible_roles(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 255, in init_flexible_roles&#10;    setattr(self, rname, {**kwargs[role]})&#10;                            ~~~~~~^^^^^^&#10;KeyError: 'flow'&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:1092: UnexpectedException">1083             The default is {}.
1084         n_joint : int
1085             Number of joint fault modes to include in sample.
1086         **joint_kwargs : kwargs
1087             baserate and p_cond arguments to add_joint_fault_scenario.
1088 
1089         Examples
1090         --------
1091         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone
1092         &gt;&gt;&gt; mdl = Drone()
UNEXPECTED EXCEPTION: KeyError('flow')
Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py", line 1355, in __run
    exec(compile(example.source, filename, "single",
  File "&lt;doctest fmdtools.sim.sample.FaultSample.add_fault_phases[1]&gt;", line 1, in &lt;module&gt;
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 109, in __init__
    self.init_architecture(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py", line 701, in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py", line 508, in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 393, in add_sim
    self.add_flex_role_obj(flex_role, name,
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 319, in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 1183, in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py", line 90, in __init__
    super().__init__(name=name, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 864, in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 345, in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 394, in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py", line 73, in __init__
    Architecture.__init__(self, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 108, in __init__
    self.init_flexible_roles(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 255, in init_flexible_roles
    setattr(self, rname, {**kwargs[role]})
                            ~~~~~~^^^^^^
KeyError: 'flow'
/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:1092: UnexpectedException</failure></testcase><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.FaultSample.add_fault_times" time="0.021"><failure message="1013             Weight factors corresponding to the times The default is [].&#10;1014         n_joint : int&#10;1015             Number of joint fault modes.&#10;1016         **joint_kwargs : kwargs&#10;1017             baserate and p_cond arguments to add_joint_fault_scenario.&#10;1018 &#10;1019         Examples&#10;1020         --------&#10;1021         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone&#10;1022         &gt;&gt;&gt; mdl = Drone()&#10;UNEXPECTED EXCEPTION: KeyError('flow')&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py&quot;, line 1355, in __run&#10;    exec(compile(example.source, filename, &quot;single&quot;,&#10;  File &quot;&lt;doctest fmdtools.sim.sample.FaultSample.add_fault_times[1]&gt;&quot;, line 1, in &lt;module&gt;&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 109, in __init__&#10;    self.init_architecture(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py&quot;, line 701, in init_architecture&#10;    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py&quot;, line 508, in add_fxn&#10;    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 393, in add_sim&#10;    self.add_flex_role_obj(flex_role, name,&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 319, in add_flex_role_obj&#10;    obj = init_obj(name=name, objclass=objclass, track=track,&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 1183, in init_obj&#10;    fl = objclass(name=name, track=track, **kwargs)&#10;         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py&quot;, line 90, in __init__&#10;    super().__init__(name=name, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py&quot;, line 864, in __init__&#10;    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 345, in init_roletypes&#10;    self.init_roles(roletype, initializer=initializer, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 394, in init_roles&#10;    obj = obj_initializer(**obj_args)&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py&quot;, line 73, in __init__&#10;    Architecture.__init__(self, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 108, in __init__&#10;    self.init_flexible_roles(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 255, in init_flexible_roles&#10;    setattr(self, rname, {**kwargs[role]})&#10;                            ~~~~~~^^^^^^&#10;KeyError: 'flow'&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:1022: UnexpectedException">1013             Weight factors corresponding to the times The default is [].
1014         n_joint : int
1015             Number of joint fault modes.
1016         **joint_kwargs : kwargs
1017             baserate and p_cond arguments to add_joint_fault_scenario.
1018 
1019         Examples
1020         --------
1021         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone
1022         &gt;&gt;&gt; mdl = Drone()
UNEXPECTED EXCEPTION: KeyError('flow')
Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py", line 1355, in __run
    exec(compile(example.source, filename, "single",
  File "&lt;doctest fmdtools.sim.sample.FaultSample.add_fault_times[1]&gt;", line 1, in &lt;module&gt;
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 109, in __init__
    self.init_architecture(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py", line 701, in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py", line 508, in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 393, in add_sim
    self.add_flex_role_obj(flex_role, name,
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 319, in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 1183, in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py", line 90, in __init__
    super().__init__(name=name, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 864, in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 345, in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 394, in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py", line 73, in __init__
    Architecture.__init__(self, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 108, in __init__
    self.init_flexible_roles(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 255, in init_flexible_roles
    setattr(self, rname, {**kwargs[role]})
                            ~~~~~~^^^^^^
KeyError: 'flow'
/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:1022: UnexpectedException</failure></testcase><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.FaultSample.add_joint_fault_scenario" time="0.021"><failure message="974             Default is 'ind' which calculates the rate as independent (rate1*rate2*...).&#10;975             Can also be 'max', which uses the max fault likelihood.&#10;976         p_cond : float&#10;977             Conditional fault probability for joint fault modes. Used if not using&#10;978             independent base rate assumptions to calculate. Default is 1.0.&#10;979 &#10;980         Examples&#10;981         --------&#10;982         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone&#10;983         &gt;&gt;&gt; fd = FaultDomain(Drone())&#10;UNEXPECTED EXCEPTION: KeyError('flow')&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py&quot;, line 1355, in __run&#10;    exec(compile(example.source, filename, &quot;single&quot;,&#10;  File &quot;&lt;doctest fmdtools.sim.sample.FaultSample.add_joint_fault_scenario[1]&gt;&quot;, line 1, in &lt;module&gt;&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 109, in __init__&#10;    self.init_architecture(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py&quot;, line 701, in init_architecture&#10;    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py&quot;, line 508, in add_fxn&#10;    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 393, in add_sim&#10;    self.add_flex_role_obj(flex_role, name,&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 319, in add_flex_role_obj&#10;    obj = init_obj(name=name, objclass=objclass, track=track,&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 1183, in init_obj&#10;    fl = objclass(name=name, track=track, **kwargs)&#10;         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py&quot;, line 90, in __init__&#10;    super().__init__(name=name, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py&quot;, line 864, in __init__&#10;    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 345, in init_roletypes&#10;    self.init_roles(roletype, initializer=initializer, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 394, in init_roles&#10;    obj = obj_initializer(**obj_args)&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py&quot;, line 73, in __init__&#10;    Architecture.__init__(self, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 108, in __init__&#10;    self.init_flexible_roles(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 255, in init_flexible_roles&#10;    setattr(self, rname, {**kwargs[role]})&#10;                            ~~~~~~^^^^^^&#10;KeyError: 'flow'&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:983: UnexpectedException">974             Default is 'ind' which calculates the rate as independent (rate1*rate2*...).
975             Can also be 'max', which uses the max fault likelihood.
976         p_cond : float
977             Conditional fault probability for joint fault modes. Used if not using
978             independent base rate assumptions to calculate. Default is 1.0.
979 
980         Examples
981         --------
982         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone
983         &gt;&gt;&gt; fd = FaultDomain(Drone())
UNEXPECTED EXCEPTION: KeyError('flow')
Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py", line 1355, in __run
    exec(compile(example.source, filename, "single",
  File "&lt;doctest fmdtools.sim.sample.FaultSample.add_joint_fault_scenario[1]&gt;", line 1, in &lt;module&gt;
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 109, in __init__
    self.init_architecture(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py", line 701, in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py", line 508, in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 393, in add_sim
    self.add_flex_role_obj(flex_role, name,
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 319, in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 1183, in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py", line 90, in __init__
    super().__init__(name=name, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 864, in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 345, in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 394, in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py", line 73, in __init__
    Architecture.__init__(self, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 108, in __init__
    self.init_flexible_roles(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 255, in init_flexible_roles
    setattr(self, rname, {**kwargs[role]})
                            ~~~~~~^^^^^^
KeyError: 'flow'
/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:983: UnexpectedException</failure></testcase><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.FaultSample.add_single_fault_scenario" time="0.021"><failure message="929             Time of the fault scenario.&#10;930         weight : float, optional&#10;931             Weighting factor for the scenario rate. The default is 1.0.&#10;932         kwargs : kwargs&#10;933             Non-default arguments for the fault (e.g., disturbances etc.)&#10;934 &#10;935         Examples&#10;936         --------&#10;937         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone&#10;938         &gt;&gt;&gt; mdl = Drone()&#10;UNEXPECTED EXCEPTION: KeyError('flow')&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py&quot;, line 1355, in __run&#10;    exec(compile(example.source, filename, &quot;single&quot;,&#10;  File &quot;&lt;doctest fmdtools.sim.sample.FaultSample.add_single_fault_scenario[1]&gt;&quot;, line 1, in &lt;module&gt;&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 109, in __init__&#10;    self.init_architecture(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py&quot;, line 701, in init_architecture&#10;    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py&quot;, line 508, in add_fxn&#10;    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 393, in add_sim&#10;    self.add_flex_role_obj(flex_role, name,&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 319, in add_flex_role_obj&#10;    obj = init_obj(name=name, objclass=objclass, track=track,&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 1183, in init_obj&#10;    fl = objclass(name=name, track=track, **kwargs)&#10;         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py&quot;, line 90, in __init__&#10;    super().__init__(name=name, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py&quot;, line 864, in __init__&#10;    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 345, in init_roletypes&#10;    self.init_roles(roletype, initializer=initializer, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 394, in init_roles&#10;    obj = obj_initializer(**obj_args)&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py&quot;, line 73, in __init__&#10;    Architecture.__init__(self, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 108, in __init__&#10;    self.init_flexible_roles(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 255, in init_flexible_roles&#10;    setattr(self, rname, {**kwargs[role]})&#10;                            ~~~~~~^^^^^^&#10;KeyError: 'flow'&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:938: UnexpectedException">929             Time of the fault scenario.
930         weight : float, optional
931             Weighting factor for the scenario rate. The default is 1.0.
932         kwargs : kwargs
933             Non-default arguments for the fault (e.g., disturbances etc.)
934 
935         Examples
936         --------
937         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone
938         &gt;&gt;&gt; mdl = Drone()
UNEXPECTED EXCEPTION: KeyError('flow')
Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py", line 1355, in __run
    exec(compile(example.source, filename, "single",
  File "&lt;doctest fmdtools.sim.sample.FaultSample.add_single_fault_scenario[1]&gt;", line 1, in &lt;module&gt;
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 109, in __init__
    self.init_architecture(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py", line 701, in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py", line 508, in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 393, in add_sim
    self.add_flex_role_obj(flex_role, name,
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 319, in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 1183, in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py", line 90, in __init__
    super().__init__(name=name, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 864, in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 345, in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 394, in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py", line 73, in __init__
    Architecture.__init__(self, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 108, in __init__
    self.init_flexible_roles(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 255, in init_flexible_roles
    setattr(self, rname, {**kwargs[role]})
                            ~~~~~~^^^^^^
KeyError: 'flow'
/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:938: UnexpectedException</failure></testcase><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.ParameterDomain" time="0.005" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.ParameterDomain.get_var_iters" time="0.003" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.ParameterHistSample" time="0.004" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.ParameterResultSample" time="0.004" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.ParameterSample.add_variable_ranges" time="0.005" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.ParameterSample.add_variable_replicates" time="0.003" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.ParameterSample.add_variable_scenario" time="0.003" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.ParameterSample.combine_orthogonal" time="0.003" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.ParameterSample.combine_product" time="0.002" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.ParameterSample.combine_random" time="0.003" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.SampleApproach.add_faultdomain" time="0.021"><failure message="1184             (e.g., to call Faultdomain.add_all, use &quot;all&quot;)&#10;1185         *args : args&#10;1186             Arguments to add_method.&#10;1187         **kwargs : kwargs&#10;1188             Keyword arguments to add_method&#10;1189 &#10;1190         Examples&#10;1191         --------&#10;1192         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone&#10;1193         &gt;&gt;&gt; s = SampleApproach(Drone())&#10;UNEXPECTED EXCEPTION: KeyError('flow')&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py&quot;, line 1355, in __run&#10;    exec(compile(example.source, filename, &quot;single&quot;,&#10;  File &quot;&lt;doctest fmdtools.sim.sample.SampleApproach.add_faultdomain[1]&gt;&quot;, line 1, in &lt;module&gt;&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 109, in __init__&#10;    self.init_architecture(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py&quot;, line 701, in init_architecture&#10;    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py&quot;, line 508, in add_fxn&#10;    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 393, in add_sim&#10;    self.add_flex_role_obj(flex_role, name,&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 319, in add_flex_role_obj&#10;    obj = init_obj(name=name, objclass=objclass, track=track,&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 1183, in init_obj&#10;    fl = objclass(name=name, track=track, **kwargs)&#10;         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py&quot;, line 90, in __init__&#10;    super().__init__(name=name, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py&quot;, line 864, in __init__&#10;    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 345, in init_roletypes&#10;    self.init_roles(roletype, initializer=initializer, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 394, in init_roles&#10;    obj = obj_initializer(**obj_args)&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py&quot;, line 73, in __init__&#10;    Architecture.__init__(self, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 108, in __init__&#10;    self.init_flexible_roles(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 255, in init_flexible_roles&#10;    setattr(self, rname, {**kwargs[role]})&#10;                            ~~~~~~^^^^^^&#10;KeyError: 'flow'&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:1193: UnexpectedException">1184             (e.g., to call Faultdomain.add_all, use "all")
1185         *args : args
1186             Arguments to add_method.
1187         **kwargs : kwargs
1188             Keyword arguments to add_method
1189 
1190         Examples
1191         --------
1192         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone
1193         &gt;&gt;&gt; s = SampleApproach(Drone())
UNEXPECTED EXCEPTION: KeyError('flow')
Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py", line 1355, in __run
    exec(compile(example.source, filename, "single",
  File "&lt;doctest fmdtools.sim.sample.SampleApproach.add_faultdomain[1]&gt;", line 1, in &lt;module&gt;
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 109, in __init__
    self.init_architecture(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py", line 701, in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py", line 508, in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 393, in add_sim
    self.add_flex_role_obj(flex_role, name,
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 319, in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 1183, in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py", line 90, in __init__
    super().__init__(name=name, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 864, in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 345, in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 394, in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py", line 73, in __init__
    Architecture.__init__(self, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 108, in __init__
    self.init_flexible_roles(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 255, in init_flexible_roles
    setattr(self, rname, {**kwargs[role]})
                            ~~~~~~^^^^^^
KeyError: 'flow'
/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:1193: UnexpectedException</failure></testcase><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.SampleApproach.add_faultsample" time="0.022"><failure message="1235             Phasemap to instantiate the FaultSample with. If a dict/tuple is provided,&#10;1236             uses a PhaseMap with the dict/tuple as phases. The default is {}.&#10;1237             If a list, passes to JointFaultSample&#10;1238         **kwargs : kwargs&#10;1239             add_method kwargs.&#10;1240 &#10;1241         Examples&#10;1242         --------&#10;1243         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone&#10;1244         &gt;&gt;&gt; s = SampleApproach(Drone())&#10;UNEXPECTED EXCEPTION: KeyError('flow')&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py&quot;, line 1355, in __run&#10;    exec(compile(example.source, filename, &quot;single&quot;,&#10;  File &quot;&lt;doctest fmdtools.sim.sample.SampleApproach.add_faultsample[1]&gt;&quot;, line 1, in &lt;module&gt;&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 109, in __init__&#10;    self.init_architecture(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py&quot;, line 701, in init_architecture&#10;    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py&quot;, line 508, in add_fxn&#10;    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 393, in add_sim&#10;    self.add_flex_role_obj(flex_role, name,&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 319, in add_flex_role_obj&#10;    obj = init_obj(name=name, objclass=objclass, track=track,&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 1183, in init_obj&#10;    fl = objclass(name=name, track=track, **kwargs)&#10;         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py&quot;, line 90, in __init__&#10;    super().__init__(name=name, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py&quot;, line 864, in __init__&#10;    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 345, in init_roletypes&#10;    self.init_roles(roletype, initializer=initializer, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py&quot;, line 394, in init_roles&#10;    obj = obj_initializer(**obj_args)&#10;          ^^^^^^^^^^^^^^^^^^^^^^^^^^^&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py&quot;, line 73, in __init__&#10;    Architecture.__init__(self, **kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 108, in __init__&#10;    self.init_flexible_roles(**kwargs)&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py&quot;, line 255, in init_flexible_roles&#10;    setattr(self, rname, {**kwargs[role]})&#10;                            ~~~~~~^^^^^^&#10;KeyError: 'flow'&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:1244: UnexpectedException">1235             Phasemap to instantiate the FaultSample with. If a dict/tuple is provided,
1236             uses a PhaseMap with the dict/tuple as phases. The default is {}.
1237             If a list, passes to JointFaultSample
1238         **kwargs : kwargs
1239             add_method kwargs.
1240 
1241         Examples
1242         --------
1243         &gt;&gt;&gt; from examples.multirotor.drone_mdl_rural import Drone
1244         &gt;&gt;&gt; s = SampleApproach(Drone())
UNEXPECTED EXCEPTION: KeyError('flow')
Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py", line 1355, in __run
    exec(compile(example.source, filename, "single",
  File "&lt;doctest fmdtools.sim.sample.SampleApproach.add_faultsample[1]&gt;", line 1, in &lt;module&gt;
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 109, in __init__
    self.init_architecture(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/examples/multirotor/drone_mdl_rural.py", line 701, in init_architecture
    self.add_fxn('store_ee', StoreEE, 'ee_1', 'force_st', 'hsig_bat',
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/function.py", line 508, in add_fxn
    self.add_sim('fxns', name, fclass, *flownames, **fkwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 393, in add_sim
    self.add_flex_role_obj(flex_role, name,
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 319, in add_flex_role_obj
    obj = init_obj(name=name, objclass=objclass, track=track,
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 1183, in init_obj
    fl = objclass(name=name, track=track, **kwargs)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/function.py", line 90, in __init__
    super().__init__(name=name, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/block/base.py", line 864, in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 345, in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/object/base.py", line 394, in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/component.py", line 73, in __init__
    Architecture.__init__(self, **kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 108, in __init__
    self.init_flexible_roles(**kwargs)
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/define/architecture/base.py", line 255, in init_flexible_roles
    setattr(self, rname, {**kwargs[role]})
                            ~~~~~~^^^^^^
KeyError: 'flow'
/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/sample.py:1244: UnexpectedException</failure></testcase><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.combine_orthogonal" time="0.003" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.combine_random" time="0.003" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.sample_times_even" time="0.003" /><testcase classname="fmdtools.sim.sample" name="fmdtools.sim.sample.sample_times_quad" time="0.003" /><testcase classname="fmdtools.sim.scenario" name="fmdtools.sim.scenario.Sequence" time="0.003" /><testcase classname="fmdtools.sim.scenario" name="fmdtools.sim.scenario.Sequence.update_sequence" time="0.003" /><testcase classname="fmdtools.sim.scenario" name="fmdtools.sim.scenario.SingleFaultScenario.from_fault" time="0.002" /><testcase classname="fmdtools.sim.search" name="fmdtools.sim.search.BaseProblem.get_opt_hist" time="0.003" /><testcase classname="fmdtools.sim.search" name="fmdtools.sim.search.DisturbanceProblem" time="0.030" /><testcase classname="fmdtools.sim.search" name="fmdtools.sim.search.HistoryObjective" time="0.003" /><testcase classname="fmdtools.sim.search" name="fmdtools.sim.search.ParameterSimProblem" time="0.170" /><testcase classname="fmdtools.sim.search" name="fmdtools.sim.search.ProblemArchitecture" time="0.067" /><testcase classname="fmdtools.sim.search" name="fmdtools.sim.search.ProblemArchitecture.update_full_problem" time="0.043" /><testcase classname="fmdtools.sim.search" name="fmdtools.sim.search.ProblemArchitecture.update_problem" time="0.027" /><testcase classname="fmdtools.sim.search" name="fmdtools.sim.search.ResponseCoords" time="0.004"><failure message="1915 &#10;1916     Class for sampling functions and displaying them on maps.&#10;1917 &#10;1918     Examples&#10;1919     --------&#10;1920     &gt;&gt;&gt; rm = ResponseCoords(lambda a, b: a*b, p={'x_size': 3, 'y_size': 3, 'blocksize': 2})&#10;UNEXPECTED EXCEPTION: AttributeError(&quot;'ResponseCoords' object has no attribute 'add_property_arrays'&quot;)&#10;Traceback (most recent call last):&#10;  File &quot;/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py&quot;, line 1355, in __run&#10;    exec(compile(example.source, filename, &quot;single&quot;,&#10;  File &quot;&lt;doctest fmdtools.sim.search.ResponseCoords[0]&gt;&quot;, line 1, in &lt;module&gt;&#10;  File &quot;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/search.py&quot;, line 1937, in __init__&#10;    self.add_property_arrays(returns)&#10;    ^^^^^^^^^^^^^^^^^^^^^^^^&#10;AttributeError: 'ResponseCoords' object has no attribute 'add_property_arrays'&#10;/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/search.py:1920: UnexpectedException">1915 
1916     Class for sampling functions and displaying them on maps.
1917 
1918     Examples
1919     --------
1920     &gt;&gt;&gt; rm = ResponseCoords(lambda a, b: a*b, p={'x_size': 3, 'y_size': 3, 'blocksize': 2})
UNEXPECTED EXCEPTION: AttributeError("'ResponseCoords' object has no attribute 'add_property_arrays'")
Traceback (most recent call last):
  File "/home/bamboo/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/python3.11/doctest.py", line 1355, in __run
    exec(compile(example.source, filename, "single",
  File "&lt;doctest fmdtools.sim.search.ResponseCoords[0]&gt;", line 1, in &lt;module&gt;
  File "/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/search.py", line 1937, in __init__
    self.add_property_arrays(returns)
    ^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'ResponseCoords' object has no attribute 'add_property_arrays'
/home/bamboo/bamboo-agent-home/xml-data/build-dir/RAD-TEST-UVF/fmdtools/fmdtools/sim/search.py:1920: UnexpectedException</failure></testcase><testcase classname="fmdtools.sim.search" name="fmdtools.sim.search.ResultConstraint.con_from_value" time="0.002" /><testcase classname="fmdtools.sim.search" name="fmdtools.sim.search.ResultObjective.get_result_value" time="0.003" /><testcase classname="fmdtools.sim.search" name="fmdtools.sim.search.SimpleProblem" time="0.003" /><testcase classname="fmdtools.sim.search" name="fmdtools.sim.search.SingleFaultScenarioProblem" time="0.031" /><testcase classname="tests.test_graph.ModelGraphTests" name="test_fault_plot" time="0.061"><failure message="Exception: Error simulating ('move_water', 'short') scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 10.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 10.0=SimEvent(copy=True)
- end=SimEvent(to_return={'graph': None, 'classify': None, 'faults': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:395: in run
    self.mdl_copy = mdl(time=self.time, **kwar, copy=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 10.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
SingleFaultScenario(sequence={10.0: Injection(faults={'move_water': ['short']}, disturbances={})}, times=(10,), function='move_water', fault='short', rate=1e-05, name='move_water_short_t10', time=10, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 10.0=SimEvent(copy=True)
- end=SimEvent(to_return={'graph': None, 'classify': None, 'faults': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;tests.test_graph.ModelGraphTests testMethod=test_fault_plot&gt;

    def test_fault_plot(self):
&gt;       er, mh = propagate.one_fault(self.mdl, 'move_water', 'short', time=10,
                                     to_return=['graph', 'classify', 'faults'])

tests/test_graph.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:162: in one_fault
    return sequence(mdl, scen=scen, name=str((fxnname, fault)), **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:222: in sequence
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
SingleFaultScenario(sequence={10.0: Injection(faults={'move_water': ['short']}, disturbances={})}, times=(10,), function='move_water', fault='short', rate=1e-05, name='move_water_short_t10', time=10, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating ('move_water', 'short') scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="tests.test_graph.ModelGraphTests" name="test_flowgraph_plot" time="0.755" /><testcase classname="tests.test_graph.ModelGraphTests" name="test_fxngraph_plot" time="0.436" /><testcase classname="tests.test_graph.ModelGraphTests" name="test_modelgraph_plot" time="0.606" /><testcase classname="tests.test_graph.ModelGraphTests" name="test_result_from_plot" time="0.060"><failure message="Exception: Error simulating ('move_water', 'short') scenario(s)">self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:728: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:734: in execute_static_behaviors
    self.static_behavior()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))

    def static_behavior(self):
        """Define how the function will behave with different faults."""
        self.set_faults()
        if self.m.has_fault('short'):
            self.ee_in.s.current = 500*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        elif self.m.has_fault('mech_break'):
            self.ee_in.s.current = 0.2*10/5000*self.sig_in.s.power*self.ee_in.s.voltage
            self.s.eff = 0.0
        else:
            self.ee_in.s.current = 10/5000*self.sig_in.s.power * \
                self.ee_in.s.voltage*min(13.0, self.wat_out.s.pressure)
            # if we wanted to enforce nominall eff state, we would include:
            # self.s.eff = 1.0
    
        velocity = self.sig_in.s.power*self.s.eff * \
            min(1000, self.ee_in.s.voltage)*self.wat_in.s.level
        self.wat_out.s.pressure = 10/500 * velocity/self.wat_out.s.area
        self.wat_out.s.flowrate = 0.3/500 * velocity*self.wat_out.s.area
    
        self.wat_in.s.assign(self.wat_out.s, 'pressure', 'flowrate')
&gt;       print(a)
              ^
E       NameError: name 'a' is not defined

examples/pump/ex_pump.py:436: NameError

The above exception was the direct cause of the following exception:

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 10.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
&gt;                   self.update_static_behaviors(proptype=proptype)

fmdtools/define/block/base.py:796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/base.py:724: in update_static_behaviors
    self.execute_static_behaviors()
fmdtools/define/block/base.py:732: in execute_static_behaviors
    self.update_arch_behaviors("static")
fmdtools/define/architecture/base.py:163: in update_arch_behaviors
    self.prop_static()
fmdtools/define/architecture/base.py:203: in prop_static
    sim(time=self.t.time, proptype='static-once', inc_at="")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = move_water MoveWat
- t=MoveWatTime(time=0.0, timers={'pressure_limit': Timer pressure_limit: mode= standby, time= 0.0}...(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
- wat_out=Water(s=(flowrate=0.0, pressure=0.0, area=1.0, level=1.0))
time = 0.0, proptype = 'static-once', faults = [], disturbances = {}
inc_at = '', end_of_simulation = False, copy = False

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating move_water of class MoveWat at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = Simulation with SimEvents:
- 10.0=SimEvent(copy=True)
- end=SimEvent(to_return={'graph': None, 'classify': None, 'faults': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:632: in run
    simevent.run(self.mdl, scen=self.scen, **kwargs)
fmdtools/sim/propagate.py:395: in run
    self.mdl_copy = mdl(time=self.time, **kwar, copy=True)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = pump Pump
- t=Time(time=0.0, timers={})
- m=Mode(mode='nominal', faults=set(), sub_faults=False)
FLOWS:
- ee_1=Electri...minal', faults=set(), sub_faults=False))
- export_water=ExportWater(m=(mode='nominal', faults=set(), sub_faults=False))
time = 10.0, proptype = 'both', faults = [], disturbances = {}, inc_at = 'all'
end_of_simulation = False, copy = True

    def __call__(self, time=None, proptype="both", faults=[], disturbances={},
                 inc_at="all", end_of_simulation=False, copy=False):
        """
        Call the Simulable to propagate behavior at a single time-step.
    
        Parameters
        ----------
        time : float/'end'
            Time at which to simulate the Simulable. Default is None, which uses
            self.t.time. If 'end' is provided, will be simulated until the end of
            the simulation (sp.end_time or sp.end_condition)
        proptype : str
            Type of propagation step to update ('static', 'dynamic', or 'both')
        faults : dict/list
            Faults to inject during this propagation step. (to be injected at time.)
            With structure ['fault1', 'fault2'...]
        disturbances : dict
            Variables to change during this propagation step. (to be injected at time.)
            With structure {'var1': value}
        inc_at : bool
            When to increment the history. If "all", increment at each time the sim
            iterates through. If "time", increment only at t==time.
        end_of_simulation : bool
            Whether this is the end of the simulation (and history should be cut).
        copy : bool
            If true, returns a copy of the model just before fault injection and
            stops simulation
        """
        try:
            if time == 'end':
                time = self.sp.end_time
            start_time, end_time = self.t.get_sim_times(time)
            sim_times = self.sp.get_timerange(start_time, end_time)
            for t in sim_times:
                if t == end_time:
                    if copy:
                        return self.copy()
                    if t != self.t.time:  # faults are only injected if not run yet
                        self.set_vars(**disturbances)
                        self.inject_faults(faults)
                self.t.update_time(t)
                if self.t.executing:
                    self.update_stochastic_states()
                    self.update_dynamic_behaviors(proptype=proptype)
                    self.update_static_behaviors(proptype=proptype)
                    self.set_sub_faults()
                    if inc_at == "all" or (inc_at == "time" and t == time):
                        self.inc_sim_time()
                        self.h.log(self, self.t.t_ind, self.t.time)
                    if self.sp.end_condition:
                        if get_var(self, self.sp.end_condition)():
                            break
    
            if end_of_simulation:
                self.cut_hist()
        except Exception as e:
&gt;           raise Exception("Error simulating " + self.name +
                            " of class " + self.__class__.__name__ +
                            " at time=" + str(self.t.time)) from e
E           Exception: Error simulating pump of class Pump at time=0.0

fmdtools/define/block/base.py:808: Exception

The above exception was the direct cause of the following exception:

self = MultiEventSimulation of
SingleFaultScenario(sequence={10.0: Injection(faults={'move_water': ['short']}, disturbances={})}, times=(10,), function='move_water', fault='short', rate=1e-05, name='move_water_short_t10', time=10, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
&gt;           self.run(**kwargs)

fmdtools/sim/propagate.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:1023: in run
    self.run_nom(with_copy=True)
fmdtools/sim/propagate.py:1008: in run_nom
    outs = nomsim(**sim_kwar)
           ^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:620: in __call__
    res, hist = super().__call__(**kwargs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Simulation with SimEvents:
- 10.0=SimEvent(copy=True)
- end=SimEvent(to_return={'graph': None, 'classify': None, 'faults': None})
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating nominal scenario(s)

fmdtools/sim/propagate.py:482: Exception

The above exception was the direct cause of the following exception:

self = &lt;tests.test_graph.ModelGraphTests testMethod=test_result_from_plot&gt;

    def test_result_from_plot(self):
        des_res = ['graph', 'classify', 'faults']
&gt;       er, hist = propagate.one_fault(self.mdl, 'move_water', 'short',
                                       time=10, track='all', to_return=des_res)

tests/test_graph.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/sim/propagate.py:162: in one_fault
    return sequence(mdl, scen=scen, name=str((fxnname, fault)), **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:222: in sequence
    return sim(**get_sim_call_kwargs(sim, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/sim/propagate.py:975: in __call__
    rets = super().__call__(**kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MultiEventSimulation of
SingleFaultScenario(sequence={10.0: Injection(faults={'move_water': ['short']}, disturbances={})}, times=(10,), function='move_water', fault='short', rate=1e-05, name='move_water_short_t10', time=10, phase='')
kwargs = {}

    def __call__(self, **kwargs):
        """Run the sim, save its results (if needed), return its result and history."""
        try:
            self.run(**kwargs)
        except Exception as e:
&gt;           raise Exception("Error simulating "+self.name+" scenario(s)") from e
E           Exception: Error simulating ('move_water', 'short') scenario(s)

fmdtools/sim/propagate.py:482: Exception</failure></testcase><testcase classname="tests.test_graph.ModelGraphTests" name="test_typegraph_plot" time="0.161" /><testcase classname="tests.test_hierarchical.define_Tests" name="test_arg_passdown" time="0.003"><failure message="KeyError: 'flow'">self = &lt;tests.test_hierarchical.define_Tests testMethod=test_arg_passdown&gt;

    def setUp(self):
&gt;       self.mdl = OverFxn()
                   ^^^^^^^^^

tests/test_hierarchical.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'ExFxnArch' object has no attribute 'flows'") raised in repr()] ExFxnArch object at 0x55d843e40e10&gt;
kwargs = {'flows': {}, 'name': 'fa', 'root': 'overfxn', 'sp': {'dt': 1.0, 'end_condition': '', 'end_time': 100.0, 'phases': (('na', 0.0, 100.0),), ...}, ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="tests.test_hierarchical.define_Tests" name="test_fault_injection" time="0.004"><failure message="KeyError: 'flow'">self = &lt;tests.test_hierarchical.define_Tests testMethod=test_fault_injection&gt;

    def setUp(self):
&gt;       self.mdl = OverFxn()
                   ^^^^^^^^^

tests/test_hierarchical.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'ExFxnArch' object has no attribute 'flows'") raised in repr()] ExFxnArch object at 0x55d845fb4f90&gt;
kwargs = {'flows': {}, 'name': 'fa', 'root': 'overfxn', 'sp': {'dt': 1.0, 'end_condition': '', 'end_time': 100.0, 'phases': (('na', 0.0, 100.0),), ...}, ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="tests.test_hierarchical.define_Tests" name="test_prop_method" time="0.004"><failure message="KeyError: 'flow'">self = &lt;tests.test_hierarchical.define_Tests testMethod=test_prop_method&gt;

    def setUp(self):
&gt;       self.mdl = OverFxn()
                   ^^^^^^^^^

tests/test_hierarchical.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'ExFxnArch' object has no attribute 'flows'") raised in repr()] ExFxnArch object at 0x55d84664d1f0&gt;
kwargs = {'flows': {}, 'name': 'fa', 'root': 'overfxn', 'sp': {'dt': 1.0, 'end_condition': '', 'end_time': 100.0, 'phases': (('na', 0.0, 100.0),), ...}, ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="tests.test_hierarchical.define_Tests" name="test_propagation" time="0.004"><failure message="KeyError: 'flow'">self = &lt;tests.test_hierarchical.define_Tests testMethod=test_propagation&gt;

    def setUp(self):
&gt;       self.mdl = OverFxn()
                   ^^^^^^^^^

tests/test_hierarchical.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
fmdtools/define/block/function.py:90: in __init__
    super().__init__(name=name, **kwargs)
fmdtools/define/block/base.py:864: in __init__
    self.init_roletypes('arch', **self.create_arch_kwargs(**kwargs))
fmdtools/define/object/base.py:345: in init_roletypes
    self.init_roles(roletype, initializer=initializer, **kwargs)
fmdtools/define/object/base.py:394: in init_roles
    obj = obj_initializer(**obj_args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
fmdtools/define/architecture/base.py:108: in __init__
    self.init_flexible_roles(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;[AttributeError("'ExFxnArch' object has no attribute 'flows'") raised in repr()] ExFxnArch object at 0x55d843e49ca0&gt;
kwargs = {'flows': {}, 'name': 'fa', 'root': 'overfxn', 'sp': {'dt': 1.0, 'end_condition': '', 'end_time': 100.0, 'phases': (('na', 0.0, 100.0),), ...}, ...}
role = 'flow', rname = 'flows'

    def init_flexible_roles(self, **kwargs):
        """
        Initialize flexible roles.
    
        If initializing as a copy, uses a passed copy instead.
    
        Parameters
        ----------
        **kwargs : kwargs
            Existing roles (if any).
        """
        for role in self.flexible_roles:
            rname = role+'s'
            if self.as_copy and rname in kwargs:
                setattr(self, rname, {**kwargs[rname]})
            elif self.as_copy:
                raise Exception("No role argument "+role+" to copy.")
            elif rname in kwargs:
&gt;               setattr(self, rname, {**kwargs[role]})
                                        ^^^^^^^^^^^^
E               KeyError: 'flow'

fmdtools/define/architecture/base.py:255: KeyError</failure></testcase><testcase classname="tests.test_packages.define_Tests" name="test_pdf_translation_options" time="0.009" /></testsuite></testsuites>